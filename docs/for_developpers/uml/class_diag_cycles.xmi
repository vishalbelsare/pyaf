<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="2.1" xmlns:xmi="http://schema.omg.org/spec/XMI/2.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:uml="http://schema.omg.org/spec/UML/2.1">
  <xmi:Documentation exporter="umbrello uml modeller 2.37.3 (Applications 22.12.3) http://umbrello.kde.org" exporterVersion="2.0.4"/>
  <uml:Model xmi:id="m1" name="UML Model">
    <packagedElement xmi:type="uml:Stereotype" xmi:id="folder" name="folder"/>
    <packagedElement xmi:type="uml:Stereotype" xmi:id="dataType" name="dataType"/>
    <packagedElement xmi:type="uml:Stereotype" xmi:id="constructor" name="constructor"/>
    <packagedElement xmi:type="uml:Stereotype" xmi:id="class-or-package" name="class-or-package"/>
    <packagedElement xmi:type="uml:Model" xmi:id="Logical_View" name="Logical View">
      <uml:Package xmi:id="Datatypes" name="Datatypes" stereotype="folder">
        <packagedElement xmi:type="uml:DataType" xmi:id="u9CUQj40wke6k" name="array" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uRs0v9QAfE7td" name="bool" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="u8OC8MX3w96m4" name="tuple" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="us6kRDi88dqyu" name="float" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uflKAzaz4ozb2" name="int" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uNmiYsTVqoJoo" name="list" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uVFYqlQv44BlN" name="long" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="ugWmBt0uWHYFW" name="dict" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uHWf8zoUhsnrH" name="object" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uKpC2Xzd9clGk" name="set" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="ugOBJvbb8orVV" name="str" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uIEm0LO1PxELG" name="undef" stereotype="dataType"/>
      </uml:Package>
      <packagedElement xmi:type="uml:Class" xmi:id="uR7STKbsESNhb" name="cCroston_Model">
        <generalization xmi:type="uml:Generalization" xmi:id="uZ70TeawNe57w" general="uvZs0S0d7eyjW"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uDvkM7HsHN27O" name="mNbLags" type="uflKAzaz4ozb2" initialValue="1"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uZnbxWvSfZ0ED" name="mAlpha" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uMdeFmSTgldUo" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u1HI4MmuNFvbw" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uN7zUkEvQNR4F" name="cycle_residue_name" visibility="private" type="ujvQZAVED7aLp" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uW4O0girAke4s" name="P" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7WJCqHMg3Coz" name="iExogenousInfo" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uWVbF4301LTke" name="dumpCoefficients">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uWgpRPrud9K07" name="iMax" visibility="private" type="uflKAzaz4ozb2" value="10"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uxLBu9CKzXOMc" name="set_name"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ud0JUHPhXru5R" name="get_coeff" comment="default : any other value is the legacy croston method">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ucJ5O0jRQzqhQ" type="us6kRDi88dqyu" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uHa5E4Xby6BhD" name="alpha" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uh1hoIRtGPiAm" name="croston_type" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uqp04gufZXOrg" name="estimate_alpha" comment="print(&quot;CROSTON_OPTIONS&quot; , self.mOptions.mCrostonOptions.__dict__) choose the best alpha based on L2 print(lPerfs) print(&quot;CROSTON_OPTIMIZED_ALPHA&quot; , self.mAlpha)">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uQHZu4zZMJqWa" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uWcYjRz7Lo1Ao" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="urUrrJUW9uY3A" name="croston">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uezMrNitOq6ST" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uMMckCRZz6VW1" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uauI02U1ec9yH" name="horizon_index" visibility="private" type="uflKAzaz4ozb2" value="1"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uJ6SSjUYLrHTk" name="simple_ses" comment="Croston implementation is slow #182. Use statsmodels  Avoid warnings from statsmodels for constant signals ">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="us4UiIHTjuumF" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uq0TTuxBqzPWT" name="x" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uMZxyk9VGM6ip" name="alpha" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uV9C41Q69tDob" name="compute_forecast" comment="print(df.shape) print(df.columns) print(df[['Date', 'Signal', '_Signal', 'row_number', '_Signal_ConstantTrend_residue_zeroCycle_residue']].tail(12)) print(list(counts.unique())) print(counts.describe()) assert(not np.isnan(counts[:-1]).any())  q is often called the “demand” and a the “inter-arrival time”. Use statmopdels library to perform SES to avoid recursion and also avoid reinventing the wheel. fill first empty fit data with zero counts (when signal starts with zeros)">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCHLt8Rehk3zQ" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uog21WKHlb5up" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5ZyZ1g4eImej" name="alpha" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uJb392RtbL2Bf" name="method" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uR2DbAdc3nXqM" name="horizon_index" visibility="private" type="uflKAzaz4ozb2" value="1"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uaWQ5JHyIjirm" name="fit" comment="print(&quot;ESTIMATE_CROSTON_MODEL_START&quot; , self.mCycleResidueName); print(&quot;OFFSET&quot;, (self.mCycleResidueName, self.mOffset)) print(&quot;ESTIMATE_CROSTON_MODEL_END&quot; , self.mOutName);"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u6w994pjxnjuS" name="transformDataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7GBWJ7eGLcXA" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ugOL0is6yGw5b" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u6MYUDVGlQAFT" name="horizon_index" visibility="private" type="uflKAzaz4ozb2" value="1"/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="u4oDSikeeXlqv" name="tsar">
        <packagedElement xmi:type="uml:Class" xmi:id="uvZs0S0d7eyjW" name="cAbstractAR"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="ujvQZAVED7aLp" name="new_class"/>
      <packagedElement xmi:type="uml:Class" xmi:id="upu5DdfGD6JGr" name="cAbstract_RNN_Model">
        <generalization xmi:type="uml:Generalization" xmi:id="uZB7gqlJIObph" general="uvZs0S0d7eyjW"/>
        <generalization xmi:type="uml:Generalization" xmi:id="uAdPRM3vjlKK2" general="uvZs0S0d7eyjW"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uyWXnStp5qZcd" name="mNbLags" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uUchqJoWs9Rsz" name="mNbExogenousLags" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uvMnEE1QnjXOa" name="mHiddenUnits" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ukB20WULoyFuI" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uh4krWdd3Nkpg" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uE3cOh6TKteJc" name="cycle_residue_name" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7SBjiskyeVt8" name="P" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uHkF5meEZ68rF" name="iExogenousInfo" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uhY13R1uSWLYt" name="dumpCoefficients">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ummmcRfCINl99" name="iMax" visibility="private" type="uflKAzaz4ozb2" value="10"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uXmH1oq0Nwg6i" name="build_RNN_Architecture">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uWDWUuSzmTVGt" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCWyzdPNfZCNH" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uJzEVElSTbfEE" name="fit_inputs_and_targets_scalers">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u8KL0zOk2Nqjx" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uibNxL5TNxUKf" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="udoHqmeQGnvGK" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uh90yaGa1QSl1" name="get_default_keras_options">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u1uXlpqdrEsXd" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uTsflD07v80j1" name="get_keras_options">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXG5yNqGA3Qcr" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uznNO4Rtnn7g1" name="fit_keras_model">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uP6i2QJl74cFP" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="udjbYalC91Gyu" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uMAV6W4NxW7IA" name="predict_keras_model">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uzgaRL2amxQHC" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXpIgbg4xoYdy" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uzTKu1HXVlcN6" name="fit"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uZqduv9OGrKpA" name="transformDataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uEZTQkDPVOtTZ" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uUoIOFfdPmcrs" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVZZOYl5dbARP" name="horizon_index" visibility="private" type="uflKAzaz4ozb2" value="1"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uzwTl5lh3zyK0" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uGtaIdFcZvhP6" name="cycle_residue_name" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uktR4sfodf5B8" name="P" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="um4vdOa4CZQgl" name="iExogenousInfo" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uQBOmFR8x2pVg" name="build_RNN_Architecture">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uwiC2puUEuTld" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPSGFihj1dMHs" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u5EPgRjxi6we7" name="fit_inputs_and_targets_scalers">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXvxc9A6SLVU7" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ukUi6UoMfFwjT" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubu13twA5y1kj" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uecBc2C7OWi1r" name="get_default_pytorch_options">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uBOc69DqL2yXt" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ulCER3i32p3CY" name="get_pytorch_options">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u26ZyU42bZ3Bi" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u7vzda8iZA1qL" name="fit_pytorch_model">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="urTqq6vyGgfkl" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uQTt6aYeAqnwh" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uyoL8avbeCjIh" name="predict_pytorch_model">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5870qqRO1M0k" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uAcW9tIOMHRRQ" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uyIJJyOTuKkm6" name="transformDataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uxKa7hLMMU4aJ" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ukZtN3hUkzxVJ" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubnGMB3YRhx5M" name="horizon_index" visibility="private" type="uflKAzaz4ozb2" value="1"/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="u3UhTKGgkawN2" name="cMLP_Model">
        <generalization xmi:type="uml:Generalization" xmi:id="uebAnpeTD6rdl" general="upu5DdfGD6JGr"/>
        <generalization xmi:type="uml:Generalization" xmi:id="uTKCkOzkyznbC" general="upu5DdfGD6JGr"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uwp44KTCDO8v7" name="mHiddenUnits" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uP1DLxZ3qxyho" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uE3lt2ee2SMZP" name="cycle_residue_name" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uIH5fMTMTdduX" name="P" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uzpfh7AL49pAY" name="iExogenousInfo" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uJNfWelEHWHqb" name="reshape_inputs">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="utRIqvenVjBAC" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u0v9o0ey20OGj" name="iInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u7gleJhpimUaG" name="build_RNN_Architecture">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uzHJcgM4sC9eW" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="upNM1vJHlqjik" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uX1VVpwtcsnEt" name="build_RNN_Architecture_template">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u2FA3E44IxZMr" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uOgsLtOAD2dd9" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7AxeQTthKtWH" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uKAnPZuI3K8d2" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="udX8yLKuOFyV9" name="cycle_residue_name" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uk4B5Nu6fqPZR" name="P" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uvJY1S53R5397" name="iExogenousInfo" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uJcvFSfku8QiF" name="reshape_inputs">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u9ixlvLkRV6sJ" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uFqtABrxq5t8M" name="iInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="unlTnMN7wWERQ" name="create_model">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uoSnqStKdRRkG" name="iNbInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubinLt5qbdyXS" name="iHidden" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uEUwI9qmexzrX" name="build_RNN_Architecture">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uE4ImyCZHvzdN" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uWTpJ5V3oTUnl" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uQDG2XBIORq4n" name="set_name"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="us5qlqlYczy5J" name="cLSTM_Model">
        <generalization xmi:type="uml:Generalization" xmi:id="uyHMqjzSGPjId" general="upu5DdfGD6JGr"/>
        <generalization xmi:type="uml:Generalization" xmi:id="ua8SBXU07Q16l" general="upu5DdfGD6JGr"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uMAYLmWotLIai" name="mHiddenUnits" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uP2Prb8Qpuoii" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="upAnHJ2ne5427" name="cycle_residue_name" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uku90OieTn192" name="P" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uFXEstpbjgc1s" name="iExogenousInfo" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u1PFBzSVOJNFO" name="reshape_inputs">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXbgOUnBhkUoM" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXHwAF8aw6pfK" name="iInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u3ZV4V26BVG2i" name="build_RNN_Architecture">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uHy4IN92tCS0K" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uk6rBrb7k2te6" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uttdZL9Emsb2O" name="build_RNN_Architecture_template">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uFVsNzEqGlDvj" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u0CJeP5MyFGIu" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uuKuew5my74OC" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uL41yTHBNnpw4" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uOJU8GfdpaCMu" name="cycle_residue_name" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPcGTM4HUyTkA" name="P" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u2cPY6cIxtBLQ" name="iExogenousInfo" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uyN7ccbp3xxar" name="reshape_inputs">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uRIlvk6guURqH" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uphPqHE8M1yM1" name="iInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="usQQlSgjCfm1k" name="create_model">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uLboGt3yL3W21" name="iNbInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u8ZVR4wsuuYny" name="iHidden" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ugZjkESWTgzSF" name="fit_pytorch_model" comment="Force some sampling for LSTM. Too slow to train. Keep the last 1024 rows.">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ux2pSd1CsRk0W" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXN07XYVtV2Tm" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uglk3NQcPyy8y" name="build_RNN_Architecture">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uesode7YWZ6oU" name="iARInputs" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uem0XhcU6gfXI" name="iARTarget" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u8syzK28vEpl2" name="set_name"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="ueDUNLAuEO6pl" name="cLSTMWithOneOutput">
        <generalization xmi:type="uml:Generalization" xmi:id="ubA6s38IvSsWS" general="uTcCFF3lkmiih"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u3yUDFSmeYW3k" name="mLSTM" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="urvKSTuYp1dtL" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ukjYTDto4Oc6W" name="iLSTM" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uvf2HRI8UQxFx" name="forward">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uD1PrsiP0YjH3" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ucBDsJZuYBu57" name="X" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="uAig6rKMvuIvh" name="torch">
        <packagedElement xmi:type="uml:Package" xmi:id="u32ysVgSCbQOo" name="nn">
          <packagedElement xmi:type="uml:Class" xmi:id="uTcCFF3lkmiih" name="Module"/>
        </packagedElement>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uA6nW3whLXUdX" name="cAbstractSignalTransform">
        <ownedAttribute xmi:type="uml:Property" xmi:id="ujJpx4Fiz63xA" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="un72HFbESKPow" name="mScaling" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u8x1ja49UCH98" name="mDebug" type="uRs0v9QAfE7td" initialValue="False"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="utkUsDXaS9o6L" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uitpQqkCTivjD" name="is_applicable">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u8iITz3qYmOST" type="uRs0v9QAfE7td" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="udgJopbVmRKhn" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uWhl5X60MPXZF" name="checkSignalType" comment="print(df.info());">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u4AfoWN7zgzDC" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uqQSVEGV81vAH" name="fit_scaling_params" comment="self.mMeanValue = np.mean(sig); self.mStdValue = np.std(sig); lEps = 1.0e-10">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uifLq0JQlUv9s" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="utSg7W6HyGaZF" name="scale_value">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPg5Fl9x9CTGN" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uU2jfEywCQFmq" name="x" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uyMa6lYPg36gr" name="scale_signal" comment="print(&quot;SCALE_START&quot;, sig.values[1:5]); print(&quot;SCALE_END&quot;, sig1.values[1:5]);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ua8PcX3CfeA6f" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u6O4oKj5d9W5C" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="urbzh4KxtWiOn" name="rescale_value">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u9maJqJ84NhGn" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uH65wRddi1EUZ" name="x" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uq0bT0muWCfu7" name="rescale_signal" comment="print(&quot;RESCALE_START&quot;, sig1.values[1:5]); print(&quot;RESCALE_END&quot;, sig.values[1:5]);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uHyRoLJUmx7Ug" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uwE2vE62Iizyx" name="sig1" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uLDJxNQ7EDXc3" name="fit" comment="print(&quot;FIT_START&quot;, self.mOriginalSignal, sig.values[1:5]); print(&quot;FIT_END&quot;, self.mOriginalSignal, sig1.values[1:5]);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="upJmNyIoW1dWD" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="upuSbTVBmcj6M" name="apply" comment="print(&quot;APPLY_START&quot;, self.mOriginalSignal, sig.values[1:5]); print(&quot;APPLY_END&quot;, self.mOriginalSignal, sig2.values[1:5]);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uMdv4GcSRkXqR" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5L3Ugfv4FMWc" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uFytguC6ERyk6" name="invert" comment="print(&quot;INVERT_START&quot;, self.mOriginalSignal, sig1.values[1:5]); print(&quot;INVERT_END&quot;, self.mOriginalSignal, rescaled_sig.values[1:5]);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uxOZ4UhPk8guF" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ungfDKaM6H4F4" name="sig1" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uiMS1DDfRS23c" name="transformDataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uEy2CyifgAmHm" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="usM0gmSr2PILU" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="udmWCyVJARXae" name="test"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uuBxt2evxRvPJ" name="dump_apply_invert">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5YeiTf1lHKrs" name="sig_before_apply" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uTmaUkw57ENLQ" name="sig_after_apply" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="usQfdklOgbaoE" name="check_not_nan">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPz2Q3RwY4jc7" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uGKqx3IX7WWsA" name="name" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uubxTNT5BvTDN" name="cSignalTransform_None">
        <generalization xmi:type="uml:Generalization" xmi:id="ui7zNZyWVARiT" general="uA6nW3whLXUdX"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uQj7rZmQNjduX" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;NoTransf&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uLTqmAFAv7DMl" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uDu9gHVUIJZpN" name="mScaling" type="uRs0v9QAfE7td" initialValue="True"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ugJJ09BQPtans" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u3wRzpf1nIV8d" name="get_name">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uxj82wxTZFAyR" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="unIy5gtcsIF1D" name="iSig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uyTRmh2SgVQuE" name="specific_fit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uYPKvU4HqFNWr" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uf4YbtcEjhw6q" name="specific_apply">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uGKNxflOopzkj" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uUNySWWrI3Nrb" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u3nLxayoyFG2P" name="specific_invert">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uU4Td35UfUfOC" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="udFRwREFR0rgm" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uhChgwj4IW3Uy" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="ug8Te23ZloGHA" name="cSignalTransform_Accumulate">
        <generalization xmi:type="uml:Generalization" xmi:id="ukhsKHETFZnVx" general="uA6nW3whLXUdX"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uCieX5aXQoC0k" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;Integration&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uzRT7pizGbgT7" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ulI9yxBPhvOOD" name="mScaling" type="uRs0v9QAfE7td" initialValue="True"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ulhSzaDib6ls0" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ucZY8QHnJZd2A" name="get_name">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uo0ITM0iRCvDG" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uFCUD4rOUNIVL" name="iSig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u7GQeLpZ2q8nw" name="specific_fit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uQqv2iPpiKJyp" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uSnPt1dPPJsxF" name="specific_apply">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uZTSwfZUvoRis" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uK3ouOJbeFjIo" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uvYeiTTO7J6Sh" name="specific_invert">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPEEXMfaecmmC" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5jncdmRd1eXk" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uKzg4nawVIgMi" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="usCXsB30PGS1i" name="cSignalTransform_Quantize">
        <generalization xmi:type="uml:Generalization" xmi:id="usp5PaY10vwg7" general="uA6nW3whLXUdX"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ugWBsQhMgnClX" name="mQuantiles" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uWZnOmCnb4xYF" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;Quantization&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uM1JrRxiUv5uB" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="usUA2FuPYQlq3" name="mScaling" type="uRs0v9QAfE7td" initialValue="True"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ubdnUW6kwGOdT" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uhkeQdu2VHlfh" name="iQuantiles" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ukGJN7souTuxZ" name="get_name">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ullHZjxKvDdvO" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u51WQk3E6bjWo" name="iSig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u1qv2vGcl2XVS" name="is_applicable">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uWJEdOOIuUBHo" type="uRs0v9QAfE7td" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uN9grbC85akrv" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="urCn7a4dfVx6d" name="specific_fit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5OdleuRliA26" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="um13ZegqCgWBa" name="signal2quant">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uKDP5nwul3W62" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uOACq7C5B7HTw" name="x" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u6FtcJNXEOzBp" name="specific_apply">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uP1q7FwliOtR5" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXMsUG8una280" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u7nykWQ0LX7IN" name="quant2signal">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u9aus5X0WlcdS" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uZEaWZB3pn0JE" name="x" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uysTJd43sJJ0v" name="specific_invert">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uyPogWmbXoPic" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uotQtv53W8pYw" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uStc8nzJOVvDp" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uYTuR9fOSZefY" name="cSignalTransform_BoxCox">
        <generalization xmi:type="uml:Generalization" xmi:id="u4EAsx6T30vn2" general="uA6nW3whLXUdX"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uemsgsqQCuakH" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;BoxCox&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uDB3MLPXhyIYa" name="mLambda" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uNoj9taSsp3pB" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u3aOpfQm9es18" name="mScaling" type="uRs0v9QAfE7td" initialValue="True"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ujn10CropSiJK" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uuIx2VNyV0Etw" name="iLambda" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uOldQDUkPnA75" name="get_name">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uvhSC4asKm8bx" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ux7hCgZSg3cSo" name="iSig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u7eZxe39VTHZL" name="specific_fit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uZEG1p6aDRLjJ" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uHvjwYDI5ZnVW" name="specific_apply">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uyKZ5066oXl4J" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5EOHQ7z5O2rp" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uIr5g7spjgizz" name="invert_value">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u06bjenErYPvp" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPsjSWjA4GXYX" name="y" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uXwMy2nQtDCO4" name="specific_invert">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uvywfd3rnLhQt" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubFe4imsXY8WA" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u94PimE8VWnfV" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uhvdjXnwVrKsz" name="cSignalTransform_Differencing">
        <generalization xmi:type="uml:Generalization" xmi:id="u59sk2WQBKr55" general="uA6nW3whLXUdX"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uMLBSuDraODUQ" name="mFirstValue" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uAZAh1kbg2ooz" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;Difference&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uqOJ5kqJMLT2a" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uR3WqIpeZQahY" name="mScaling" type="uRs0v9QAfE7td" initialValue="True"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uaSjXNSDJfLQ4" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uYONqAooqdABm" name="get_name">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ujU3GWc4IYHbY" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uuSZP1tGY9ume" name="iSig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uHZQRhKXVFhjA" name="specific_fit" comment="print(sig.head());">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uei9FDZn2EcAk" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ukOvQNP5ZcbXE" name="specific_apply">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ufbwhmge3n4B0" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ugd19Jgre6obD" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u1bGcGq6OGdqe" name="specific_invert">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubiiRTRCoTHNZ" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uxUdRvB87Quf8" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ukfSxXofaCHS7" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="u0vAaqT0VA4N5" name="cSignalTransform_RelativeDifferencing">
        <generalization xmi:type="uml:Generalization" xmi:id="uqusW2wxIhIil" general="uA6nW3whLXUdX"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uG3wd3tgVMQqB" name="mFirstValue" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uvNpLZgKPvG6g" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;RelativeDifference&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="un3RtQyYtXrqE" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uvNTQLW3CpBOo" name="mScaling" type="uRs0v9QAfE7td" initialValue="True"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uvFUIDuL30sXW" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u5YQqZM0U29bF" name="get_name">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u00RbMuf22GUj" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u3hXMPXuw0mBR" name="iSig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uRGmCbCVuT5Kr" name="specific_fit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="utMtHEiMmb33B" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uRm8ynib9pgm4" name="specific_apply" comment="print(&quot;RelDiff_apply_DEBUG_START&quot; , self.mFirstValue, sig.values[0:10]); print(sig1) print(sig_shifted) print(&quot;RelDiff_apply_DEBUG_END&quot; , rate[0:10]);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uLyXUFS6anmpG" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uJleBEfg5SEPy" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ufkOcipyycLXE" name="cumprod_no_overflow">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uwKprl0xkTn0r" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uWiOJIrzfuJ92" name="rate" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uEaXiJNsu1iWF" name="specific_invert" comment="print(&quot;RelDiff_invert_DEBUG_START&quot; , self.mFirstValue, sig.values[0:10]); Avoid unnecessary clipping. np.exp(10) == 22026.465794806718 and np.exp(-10) == 4.5399929762484854e-05 print(&quot;rate&quot; , rate) print(&quot;rate_cum&quot;, rate_cum) print(&quot;RelDiff_invert_DEBUG_START&quot; , sig_orig[0:10])">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uO7VV9MVTqfI8" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uzTQii9wX9hgo" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uoNiX8Gu9Fur0" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="ud7SAHRwSRjyq" name="cSignalTransform_Logit">
        <generalization xmi:type="uml:Generalization" xmi:id="uoEOCe445Kbxf" general="uA6nW3whLXUdX"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uiPiG9AezrAQR" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;Logit&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u5rfeCAOcPFcl" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ucClL1ICIfWZp" name="mScaling" type="uRs0v9QAfE7td" initialValue="True"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="udM8FSv9sFB7P" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uA39nZnJwXBmN" name="get_name">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5QKvornva6J5" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCc8fScVBk70v" name="iSig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u1hng5bJJ52Hf" name="is_applicable">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uFL4vOa51XMO0" type="uRs0v9QAfE7td" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uK0lFVjmeOxzM" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="urwN2FpjmuPoG" name="specific_fit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uFXfja3uDkMCA" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u02YJ2YfGJgh8" name="logit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uWGoA7oQ7oYva" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="upr2TiqLgEY0Y" name="x" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u1FoJRu7i3sYc" name="inv_logit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uaMKm69WcJSVo" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="urFD99iQKvwL5" name="y" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ug0Jf0ylhCXrk" name="specific_apply" comment="logit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uiFIq25101jRl" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u1SZPTb2s74L5" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uv3eNLshQVnxV" name="specific_invert" comment="logit">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u10uyqMpXaxqk" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uTsFw7CaoXc27" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u0sBXYcp09B7b" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uq0LrPP3PkV72" name="cSignalTransform_Anscombe">
        <generalization xmi:type="uml:Generalization" xmi:id="u4WkP9Zx90pKE" general="uA6nW3whLXUdX"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ut6hwToey9BJj" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uU4Jy4R3Iuttf" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;Anscombe&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u1vtbrq1iIGiP" name="mConstant" type="us6kRDi88dqyu" initialValue="3.0"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uqOa1LGxFDKsx" name="mScaling" type="uRs0v9QAfE7td" initialValue="True"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="u2QhbtcOQZi67" name="cSignalTransform_Fisher">
        <generalization xmi:type="uml:Generalization" xmi:id="uCqyfRFuthdnU" general="uA6nW3whLXUdX"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uHWMFrnGmngwQ" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;Fisher&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u513DL1Jz4dxl" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uheCtkELV9Oju" name="mScaling" type="uRs0v9QAfE7td" initialValue="True"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uxKtak8jVDcjI" name="cTransformationEstimator">
        <ownedAttribute xmi:type="uml:Property" xmi:id="uZ47PjMQpovOi" name="mTransformList" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uMIdGWCoHnYrx" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uSIVFkA5WOFZo" name="validateTransformation" comment="print(&quot;Adding Transformation &quot; , lName);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uiYOBm5nBHyLe" name="transf" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCWHi8JmwXNUe" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ueAbsf4JDA7qu" name="iTime" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u4rbx56bPpWrs" name="iSignal" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uxOLLVNY0byKh" name="defineTransformations">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uj7rZN0BxJjtG" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uDZlHn7Za7epv" name="iTime" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uE0C66zItQcuI" name="iSignal" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="u3cR0eISUWAxi" name="cSignalDecomposition">
        <ownedAttribute xmi:type="uml:Property" xmi:id="uRoXpw52ShJ7j" name="mOptions" type="uIEm0LO1PxELG" initialValue="()"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="udeb0VCi9ojHI" name="mExogenousData" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uCdbvcJBAVvZF" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uuACekITyA07J" name="checkData">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u4l06fDd8WCbk" name="iInputDS" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uNdpeDxsyLDxU" name="iTime" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uuZ3ekTsdUeWm" name="iSignal" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uokuCNxCOB2jS" name="iHorizon" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7lO40gVn1BPP" name="iExogenousData" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uMqAUcBFt9APZ" name="tsopts" stereotype="class-or-package"/>
      <packagedElement xmi:type="uml:Class" xmi:id="u1nHQ65kdzj1f" name="cAbstractAR">
        <ownedAttribute xmi:type="uml:Property" xmi:id="ucKvg4dfGsr1G" name="mCycleFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u8kHeVRpGWFWH" name="mARFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u6eACzILVoHjw" name="mCycleResidueName" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u2Br17c44RQTc" name="mCycle" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uJFYqVrYRL7YI" name="mTrend" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uGWlXohnNWRyA" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u4kR7Nx9ZAinz" name="mFormula" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uPsFeQrq1BR9Q" name="mTargetName" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uiZuIUDISbiwt" name="mInputNames" type="uNmiYsTVqoJoo" initialValue="[]"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u0ozNYvXmc16S" name="mExogenousInfo" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uIY8LLHuoVCpF" name="mLagsForSeries" type="ugWmBt0uWHYFW" initialValue="{cycle_residue_name:[]}"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ubEZx9UOVqGoe" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="unkbHtyq3ZV6t" name="cycle_residue_name" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uOIrqOBs1Su5l" name="iExogenousInfo" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uzVcOYgt6gESQ" name="compute_ar_residue" comment="df_detail = df[[self.mSignal, self.mTrend.mOutName, self.mCycle.mOutName, self.mOutName, self.mOutName + '_residue']] print(&quot;compute_ar_residue_detail &quot;, (self.mOutName, self.mDecompositionType, df_detail.describe(include='all').to_dict()))">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="umB42SOU21cgF" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uzUL5inTKXjoh" name="plot"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uC2pG7oXaXH6Y" name="register_lag" comment="print(&quot;register_lag&quot;, (series , p , name))">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u07OkqLkSwkCs" name="series" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u8TqbzN5cn4i3" name="p" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="umeq1fUhFugGM" name="dumpCoefficients"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uTz03XZqrNOMC" name="computePerf"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uoJV1ghZWOJLD" name="shift_series">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uaJ1oaEjwwVT8" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ux529QFXEMXRH" name="series" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uLTSceOFzfDC8" name="p" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="urppJMIH5Gzre" name="idefault" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ugndGcN5jGJNO" name="getDefaultValue">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uuaCk5Eg1vBmS" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="um1iSu2Egoiij" name="series" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uV6nQYUanEDhg" name="generateLagsForForecast" comment="lDict[self.mCycleResidueName] = df[self.mCycleResidueName]  Investigate Large Horizon Models #213 : The model can produce overflows in its inputs when iterated.  Exogenous variables lags">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ujjEt9vDBfPXO" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u13A57zVxST4o" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uTmFIyxkngkDO" name="cZeroAR">
        <generalization xmi:type="uml:Generalization" xmi:id="uXGrBIQkgVJAG" general="u1nHQ65kdzj1f"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uMx5AZb3TeaKf" name="mOutName" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uktAjnKkc4RWW" name="mNbLags" type="uflKAzaz4ozb2" initialValue="0"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="upkxG6oefMR27" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;NoAR&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u1yQ8d8dc7LoZ" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uX1JKoz1BbbxU" name="mConstantValue" type="us6kRDi88dqyu" initialValue="0.0"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u3h1VXuvQChwv" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uRN23nMJ6TSmy" name="cycle_residue_name" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uhQGWtRUuvnJ9" name="fit" comment="multiplicative models self.mTimeInfo.addVars(self.mARFrame); self.mARFrame[series] = self.mCycleFrame[series]"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u1Aw3ZrrnjZM1" name="transformDataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5fHtKwCByV1z" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uuXGCYWm0RnR5" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uSH9D01e6QJtz" name="horizon_index" visibility="private" type="uflKAzaz4ozb2" value="1"/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uVrVvaDwQwBYQ" name="cAutoRegressiveEstimator">
        <ownedAttribute xmi:type="uml:Property" xmi:id="uVMAmOqNU3Qwh" name="mCycleFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uJNYagu5g8VJU" name="mARFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uHj6huV5QdgQK" name="mARList" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uyB93rF6tT3H4" name="mExogenousInfo" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uNxqFdwhwwil2" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uxE6mo1sJlEQ2" name="plotAR"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uo6MASQSPhs7c" name="is_not_constant">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPLArNQqzZnPW" type="uRs0v9QAfE7td" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7KrnvqcZsl9h" name="iSeries" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u6JehlY8psVHS" name="shift_series">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uOdflleQQUEG1" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uSqyA2ZTvhPfH" name="series" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uGqbpcgsUOFkw" name="p" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uCO4j0qSzBB6u" name="generateLagsForTraining">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="upviCwJBqddyf" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uug6it6sMaGzb" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uMcW7XdkQ8Hif" name="series" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uqozXeYHOHcQw" name="pMinMax" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ufcZBm04NbPFK" name="preselect_exog_vars">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7HezD8Wm6xRa" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uluwPaexpvajT" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uUYgWdrMNgrXU" name="cycle_residue" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ugLPP1V4uPPvG" name="addLagsForTraining" comment="Exogenous variables lags Exog variables can be configured but not used (&quot;AR&quot; activated and &quot;ARX&quot; disabled). ARX,XGBX, ... only ARX,XGBX, ... only @profile">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ujmn0F1SBGs9b" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u66YfFbixivUv" name="cycle_residue" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uvTz4eTD0YzFj" name="estimate_ar_models_for_cycle" comment="print(self.mARFrame.info());">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uD0ARoUIMmId5" name="cycle_residue" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="us23X8cdJWWQn" name="check_not_nan" comment="print(&quot;check_not_nan&quot;);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uk4egE3u8FdSo" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ux22u2Q19ElG0" name="name" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u0WDWEUADAK7G" name="get_nb_lags">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="up9qcQ8ZwLBrL" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="usphBUia6EtDo" name="add_model_if_activated" comment="@profile">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="urCKs5g8NYChI" name="cycle_residue" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uSfDke7qLYETa" name="model_type_str" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPXkW8J9XQHz9" name="model_class" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u4QRmAjg6pCa5" name="iLags" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uUbvUaev8L8IB" name="iAddExogenous" visibility="private" type="uRs0v9QAfE7td" value="True"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uT0Ug1qNE3jGM" name="estimate" comment="The signal is scaled to be between 0 and 1 Keep this test as simple as possible. TODO : need to define/design how to deal with exogenous variables in croston-based models."/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uqTXfxrZtzFEz" name="cAbstractCycle">
        <ownedAttribute xmi:type="uml:Property" xmi:id="u2EoZVvii0Tob" name="mTrendFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uza3Gf5gDBYpd" name="mCycleFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u4LeEPKGtmH3w" name="mTrend" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uf0l1inalL7mm" name="mTrend_residue_name" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u4OEPQMBkOA5V" name="mFormula" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="utQWgO5uv9Kb3" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ua5B6cgfG0mCr" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uBnIC08deaAHB" name="trend" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uLUNqk2IRJ2hY" name="getCycleResidueName">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uf5FczSQBLZwi" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uZL1fU0NPGckr" name="plot"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uzMoE7EF4HSQX" name="check_not_nan" comment="print(&quot;check_not_nan&quot;); print(&quot;check_cycle_residue &quot;, (name, self.mDecompositionType, sig[:-1].min(), sig[:-1].max(), sig[:-1].mean(), sig[:-1].std()))">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uLfh3lxv8btpD" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uNh4vhwtoQ0YU" name="name" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="upcVodfUaUvYc" name="compute_cycle_residue" comment="This is questionable. But if only a few values are zero, it is the safest. df_detail = df[[self.mSignal, self.mTrend.mOutName, self.getCycleName(), self.getCycleResidueName()]] print(&quot;compute_cycle_residue_detail &quot;, (lOutName, self.mDecompositionType, df_detail.describe(include='all').to_dict()))">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u3v7W4mbugwt5" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ukU6Ni56wMecc" name="compute_target_means_by_cycle_value" comment="we encode only using estimation">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uHdaJhqQ4EP4E" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uU7D9EeyDP125" name="iCycleFrame" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ukdsLTICNualb" name="iCycleName" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u6SarybF6EFot" name="compute_target_means_default_value" comment="we encode only using estimation">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPmYdbI5w10m8" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uHl97yKUOrZA4" name="computePerf" comment="self.mCycleFrame.to_csv(self.getCycleResidueName() + &quot;.csv&quot;); self.mCycleFrame[[self.mTrend_residue_name, self.getCycleName()]].to_csv(self.getCycleName() + &quot;.csv&quot;);"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uaxDsX9Nj2tJX" name="dumpCyclePerf"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uJ1fzpHjvhIND" name="cZeroCycle">
        <generalization xmi:type="uml:Generalization" xmi:id="uOqomTFpvoOWh" general="uqTXfxrZtzFEz"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u1MTZHApG1sBQ" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;NoCycle&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uTQSpFMwYwZfy" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uX2XoupGaDakf" name="mConstantValue" type="us6kRDi88dqyu" initialValue="0.0"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u9Erjsm2AQdhY" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7tWhA4oeqAHL" name="trend" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uIrEkFK4lmb2S" name="getCycleName">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uk0hgCK4PQZ3l" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uT7riFYJZmEs0" name="dump_values"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uqNfmS2WbJa3C" name="fit" comment="multiplicative models"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uI0rfdbWL44bw" name="transformDataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uGsvayZBRRsam" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uao9SzEyvJS04" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uTPMJ3RwCxK47" name="cSeasonalPeriodic">
        <generalization xmi:type="uml:Generalization" xmi:id="uokoni6bW5dXo" general="uqTXfxrZtzFEz"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ukBqnARAvhZRF" name="mDatePart" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uJ90Yd8IhwdZT" name="mEncodedValueDict" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uHPBrrnXDwR0i" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;Seasonal_&quot;"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uN3ILfbNnLG02" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVxOUYmxFiDOD" name="trend" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="um24T4DoT4AAh" name="date_part" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ufichRs13oCkO" name="getCycleName">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ujC3F06msnKZD" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u423Kdrh3M2pM" name="dump_values"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u2ACq4Ov8hpNK" name="hasEnoughData" comment="these are just guessses of how much dataa is needed to get valid signal stats/means of each seasonal unit. TODO : add these in the options. (None, None) =&gt; no limit 10 days 10 hours 10 minutes 10 months 10 weeks 10 years 10 years 10 weeks 10 years 10 weeks 10 weeks 10 weeks 10 weeks 10 weeks 10 weeks 10 weeks 10 months 10 months">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uyONTzTFkNJdT" type="uRs0v9QAfE7td" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uijZh5cqTfZL9" name="iTimeMin" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u49bqRbNgrlM9" name="iTimeMax" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uAx3CSB1LsRz3" name="compute_date_parts">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uU37EpC2Irff2" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uhbcLS1TMm6ru" name="iTimeValues" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uZ6scia9UK12U" name="fit" comment="print(&quot;encoding '&quot; + lName + &quot;' &quot; + str(self.mEncodedValueDict)); The longer the seasonal, the more complex it is."/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uCG6hwIRq9MBX" name="transformDataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubCoeIGK7e0Fs" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uW9JhQV7HM0h5" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="u3H2S0KTwrCiu" name="cBestCycleForTrend">
        <generalization xmi:type="uml:Generalization" xmi:id="uSr2Dg0902b11" general="uqTXfxrZtzFEz"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ubh7VMa3S4glT" name="mCycleFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u3yfZUTZR0q4w" name="mCyclePerfByLength" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uypzZOMLvZw4J" name="mBestCycleValueDict" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uXrrOOGPJcsLu" name="mBestCycleLength" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u02XKeGJn4vcw" name="mCriterion" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uSrzQdMwVzhUf" name="mFormula" type="ugOBJvbb8orVV" initialValue="&quot;BestCycle&quot;"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uutTIxfuoMONt" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uEUAN64bsWJQO" name="trend" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubn0uRIDpaQHU" name="criterion" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ul3E5GSshC3yr" name="getCycleName">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u198QctXOWaHF" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u9r0e2yzpDGWX" name="dump_values"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uWCWqQNwfWpcA" name="computeBestCycle" comment="less MAPE is better, less categories is better, the last is the length to have a total order. MAPE =&gt; MASE self.transformDataset(self.mCycleFrame);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uDJaJN6EYcIlw" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ukH47pDxQUwC2" name="get_tested_cycles">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="udDrjoXrdkhB3" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uTIOXFl4xg9Le" name="signal_length" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="unxsgAwSvnXN6" name="generate_cycles" comment="validate the cycles on the validation part"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="utC8FlK14OLwj" name="fit" comment="print(&quot;cycle_fit&quot; , self.mTrend_residue_name);"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u3Dfl8wSu3sNL" name="transformDataset" comment="print(&quot;BEST_CYCLE&quot; , self.mBestCycleLength) print(self.mBestCycleValueDict); multiplicative models">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uQ2zOgGirbmaY" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="udPQP3gmgEhec" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uxrTqZubGIuhd" name="cCycleEstimator">
        <ownedAttribute xmi:type="uml:Property" xmi:id="uubc8OQ8IEatb" name="mTrendFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="umGTJSPfQrsAX" name="mCycleFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uWmlcwprdoIDS" name="mCycleList" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uUU6qdkJIwfeD" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uuyGMrtIL4AHa" name="addSeasonal">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u0VS1gONbVvQn" name="trend" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uhaKruuwWAB5h" name="seas_type" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uJrYOe4u9ZqGS" name="resolution" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uEWbPubGKnQgZ" name="defineCycles" comment="The signal is scaled to be between 0 and 1 Keep this test as simple as possible. The order used here is mandatory. see filterSeasonals before changing this order."/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u4QVQZnX4qYYq" name="plotCycles"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u0y9VpUP6gKDr" name="estimateCycles" comment="Avoid dataframe fragmentation warnings."/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="usYLyon0iv4DR" name="filterSeasonals" comment="check that the MAPE is not above 1.0 less MAPE is better, less categories is better, the last is the name of the seasonal to have a total order. MAPE =&gt; MASE">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u9STTdI33mUtu" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uYx1uQ403wIuX" name="estimateAllCycles"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uLFVWU4hcQyY7" name="cSignalDecompositionForecaster">
        <ownedOperation xmi:type="uml:Operation" xmi:id="uNmf8UlZPbU7M" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uDgm1uFJdr4y1" name="merge_frames">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uFON7Ic74NRzK" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVMzxdQZuOyN8" name="iFullFrame" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u0DbkHsog6yOi" name="iOneSignalFrame" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="utDqQFAueLyLH" name="iTimeInfo" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uAz1ZI2Ia596i" name="forecast">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u4IL8yHI19SKM" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uZ6uQBIReinyl" name="iDecomsposition" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="udtPu1Hh1nwQQ" name="iInputDS" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uDvGLH03AGBsz" name="iHorizons" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="unp086rhZhHLt" name="cSignalQuantizer">
        <ownedOperation xmi:type="uml:Operation" xmi:id="ut4JQCYu8lPBk" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uxfTB8DBKYIUr" name="signal2quant">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPUxRJtRN0tQb" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ulvwgfGs7QdSq" name="x" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uyCb7uqCEW9iL" name="curve" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uq1bJzwI18rCn" name="quant2signal">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uOkyMP6wV4s09" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ucm607OlTFMN9" name="series" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPiZoGs2koZ3K" name="iSignal" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXWYIXaCIHxDM" name="Q" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uVRi4MMQyvn2G" name="quantizeSignal" comment="return lSignal_Q">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7lyUPe14I935" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ukIr2VL0acaXs" name="iSignal" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u9WLmbUyYlU2t" name="Q" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="udKBKv2lgIZGu" name="cSignalDecompositionOneTransform">
        <ownedAttribute xmi:type="uml:Property" xmi:id="upLrR8xhIGWSo" name="mTime" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ucSOpe1HXOq5C" name="mSignal" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u6ZFUKZQTMM8r" name="mTimeInfo" type="uIEm0LO1PxELG" initialValue="()"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uS0GUQSFDOGVP" name="mTransformation" type="uubxTNT5BvTDN" initialValue="()"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u5E2Ks3lGS4yq" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ucuMSIrExYph2" name="setParams" comment="print(&quot;setParams , head&quot;, iInputDS.head()); print(&quot;setParams , tail&quot;, iInputDS.tail()); print(&quot;setParams , columns&quot;, iInputDS.columns);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uNYGSrGoYjElj" name="iInputDS" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ustazivR0dxYq" name="iTime" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ukf0HcyQZk1Cz" name="iSignal" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uG4rJxl8ZasRm" name="iHorizon" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uyU3RPrUrRkKB" name="iTransformation" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uOa3CJx3z9sLG" name=";" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u97diZ5GpNtTp" name="iDecomspositionType" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ugjq2vwUJcYuE" name="iExogenousData" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uW6iB0e4cCsgP" name="updatePerfsForAllModels" comment="lTimer = tsutil.cTimer((&quot;UPDATE_PERFS_FOR_ALL_MODELS&quot;, {&quot;Signal&quot; : self.mOriginalSignal, &quot;Transformation&quot; : self.mSignal, &quot;DecompositionType&quot; : self.mDecompositionType}, len(iModels))) lTimer2 = tsutil.cTimer((&quot;UPDATE_PERFS_FOR_MODEL&quot;, model)) print(name, model.__dict__);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uAGNMRQzQy6bd" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uboyH0y4BeVmZ" name="iModels" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u6Ci8puPDoLz1" name="train" comment="estimate time info assert(self.mTimeInfo.mSignalFrame.shape[0] == iInputDS.shape[0]) self.mSignalFrame[self.mSignal] = self.mSignalFrame[self.mSignal].astype(np.float32); estimate the trendlTrendEstimator.plotTrend(); estimate cycles autoregressive forecast perfs">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u3biFmM5MBq9f" name="iInputDS" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ujUZWwPTR7oDd" name="iSplit" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uoveH0Gcs17gn" name="iTime" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uwCaflIMKnp2I" name="iSignal" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uR4IJTeHYZUhA" name=";" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uwlhYyQHMtr67" name="iHorizon" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u8711jpbNSM2g" name="iTransformation" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uRHDxewJNGlfw" name="iDecomspositionType" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uArlsc7ZTSQfS" name="tsti" stereotype="class-or-package"/>
      <packagedElement xmi:type="uml:Class" xmi:id="ucfXEnnZd4gT8" name="tstransf" stereotype="class-or-package"/>
      <packagedElement xmi:type="uml:Class" xmi:id="usRfxirrOBrnP" name="cTraining_Arg">
        <ownedAttribute xmi:type="uml:Property" xmi:id="uDwskKvUrEt06" name="mInputDS" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uzdvx8FpBIBvY" name="mTime" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ufHBfNAS7jrmz" name="mSignal" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uZMLS4y3d4Yjg" name="mHorizon" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u0Fkp4nWA3Omi" name="mTransformation" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="udxmNiZ9gShvw" name="mSigDec" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ucMZJE1DJAyCd" name="mSplit" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uWu5IYx7J0dI3" name="mResult" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uH6T99Q0mRDO8" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uipPPc96dxQJm" name="name" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uL7ETIjNqId8p" name="cSignalDecompositionTrainer">
        <ownedAttribute xmi:type="uml:Property" xmi:id="uk4xZ2qvZANVb" name="mOptions" type="uIEm0LO1PxELG" initialValue="()"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uYczJpiqunGm6" name="mExogenousData" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ujRxU6qecjKiH" name="mTransformList" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uZFpuAwHhFL1m" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uYxyszxOGwEtH" name="define_splits">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uxPl34qKEm9Gy" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uoDA1ROaTRznh" name="train" comment="self.cleanup_after_model_selection()">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uiGkoK4qoVbZA" name="iInputDS" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5tBU244p1q0c" name="iSplits" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ulqO2fiLRIhWe" name="iTime" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uGaCpdwmMjvFT" name="iSignals" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ulzRWvokl91PG" name="iHorizon" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uArMQP1Sv6kgk" name="finalize_training"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u5HZUchzwnypK" name="defineTransformations">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ugCDxLmzozBSM" name="iInputDS" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="utZVKAZwZuU4I" name="iSplit" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uHEF9eO1b1yBx" name="iTime" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uRf0DEZZIOmOW" name="iSignal" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u9UHnO7ypi9yR" name="train_all_transformations" comment="print([transform1.mFormula for transform1 in self.mTransformList]);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uyoFvXzCylzDc" name="iInputDS" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uBEzZEMrp6Edl" name="iSplits" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCk68JjOME8Ue" name="iTimes" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uZSogGEKmXQCe" name="iSignals" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uIGTcQteSFKEI" name="iHorizons" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uW9wNO8aKBIc7" name="cleanup_after_model_selection" comment="store only model names here. delete failing transformations"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="usMOgteztFLF0" name="cAbstractTrend">
        <ownedAttribute xmi:type="uml:Property" xmi:id="upPHVLQ0ziQfr" name="mTimeInfo" type="uIEm0LO1PxELG" initialValue="()"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uC4KCeiB9wzAK" name="mTrendFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uGwZTOxRxMO7t" name="mTrendPerf" type="uIEm0LO1PxELG" initialValue="()"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ud8Nkc9MdcgBo" name="mOutName" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uZ1iRgsTmpQlk" name="mFormula" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uHExlQs1kpTiY" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uZpMOcg2UEsDJ" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u3wIkWjm2FuXr" name="check_not_nan" comment="print(&quot;check_not_nan&quot;);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVbBY1huE1kk4" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u9cyCmj0JNfkX" name="name" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u1P45xww8kwuZ" name="computePerf" comment="self.mTrendFrame.to_csv(self.mOutName + '_residue' + &quot;.csv&quot;);"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uWo0o7fQ0DSno" name="compute_trend_residue" comment="This is questionable. But if only a few values are zero, it is the safest.">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uwsgWcD1iyiMN" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u1ozqqFJxYO3R" name="addTrendInputVariables"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uB25uTDQSfO5L" name="fit"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uTB1uSTUM138h" name="transformDataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ugvfzpo2wKt09" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uGMyQ9sDbozfX" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uZfsgUiUADNg6" name="compute">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPIB6S0sa6MP8" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uzHLc9ooc9znC" name="tsperf" stereotype="class-or-package"/>
      <packagedElement xmi:type="uml:Class" xmi:id="uCUnWpvj7Xl3p" name="cConstantTrend">
        <generalization xmi:type="uml:Generalization" xmi:id="u0vL8fDFwfT35" general="usMOgteztFLF0"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uoekbQt6aD7NV" name="mMean" type="us6kRDi88dqyu" initialValue="0.0"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u1Muz2chsohiH" name="mOutName" type="ugOBJvbb8orVV" initialValue="&quot;ConstantTrend&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u1UQxbQdwIFlv" name="mFormula" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ud3W7soTkmdPQ" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uwoxvtrSdoE38" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u0hlIdKwTrF20" name="fit_specific"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uHXYkRtRB6kOv" name="compute">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u76pJe9Xy9Vcd" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uh1Bw0nfKyfK1" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uXg3FMRHMngcO" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uaGQQUSgaKYRT" name="cLag1Trend">
        <generalization xmi:type="uml:Generalization" xmi:id="uPVMsifqSbN75" general="usMOgteztFLF0"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="up1GGJM55vGkm" name="mDefaultValue" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uCIbfPZXUHra0" name="mOutName" type="ugOBJvbb8orVV" initialValue="&quot;Lag1Trend&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u4qqBkqAFTARh" name="mFormula" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uP878PTJOMknb" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="udXfxrUBilw66" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ugz4DYCCscjR1" name="replaceFirstMissingValue" comment="print(self.mDefaultValue, type(self.mDefaultValue)); Be explicit here .... some integer index does not work. print(df.head());">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ucrzu3jQeS5be" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCzVfsjjQ40pc" name="series" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uqmmljl4c9Gf6" name="fit_specific"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uOCoPK42mulaO" name="compute">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uqg3uabBhENoV" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u8CjOXc6JhREB" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u9ocozO6X6qEe" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uwl2oqz9h7Wdj" name="cMovingAverageTrend">
        <generalization xmi:type="uml:Generalization" xmi:id="u6XyAZqaARQL6" general="usMOgteztFLF0"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u1w1DBBmXwyAl" name="mOutName" type="ugOBJvbb8orVV" initialValue="&quot;MovingAverage&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="udLKdeAFOC2mB" name="mWindow" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u9N4crwiMbWIQ" name="mFormula" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uNawJHvBjoyLs" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ucJfJenWxCw6W" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u3Je3uQaqpxvJ" name="iWindow" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uLOsuiRDes5tK" name="fit_specific"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uzyGBZhuybO8o" name="compute">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7vb49FaLd9lR" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5O2Ir8ebWNKq" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uUQcN5fscdmTt" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="ujEXUx4pr64kM" name="cMovingMedianTrend">
        <generalization xmi:type="uml:Generalization" xmi:id="u3laHx4Kh6ws5" general="usMOgteztFLF0"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u9eoMSHIydWbv" name="mOutName" type="ugOBJvbb8orVV" initialValue="&quot;MovingMedian&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u1r7EP2Pl1HTa" name="mWindow" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uLULZEw4LPxBz" name="mFormula" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u3PxTNT2K9QpY" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="utdyzzKqmqXTB" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uxF7DzKjthlgZ" name="iWindow" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u9PLSQmjcZ63c" name="fit_specific"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u3EvnL7CIAmbu" name="compute">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXq8PA5viPGMJ" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u6keXRzNBdWcn" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uocNp84Y2gUk8" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uYxIki8MPqNHO" name="cLinearTrend">
        <generalization xmi:type="uml:Generalization" xmi:id="uYV94mpXQFtzb" general="usMOgteztFLF0"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u8USvF3vYpa0b" name="mTrendRidge" type="uIEm0LO1PxELG" initialValue="(solver='cholesky',alpha=0.0)"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uZVv9fOs92ztA" name="mOutName" type="ugOBJvbb8orVV" initialValue="&quot;LinearTrend&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u6PhqE6hmLCdc" name="mFormula" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uhb3qgz5k3C49" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u9dENnSbakBur" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uX6pq5phofWAs" name="fit_specific"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uYZ7SVPLh4Zv2" name="compute">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ue0qF7qDGAKES" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uOkicqnmOsRPD" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uoRtj1J1CDvuA" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uP4IQhFCXv0vB" name="linear_model" stereotype="class-or-package"/>
      <packagedElement xmi:type="uml:Class" xmi:id="u9wB2uEDWBDUM" name="cPolyTrend">
        <generalization xmi:type="uml:Generalization" xmi:id="u5rIrRwYInpDn" general="usMOgteztFLF0"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uUp6BERXGpK9n" name="mTrendRidge" type="uIEm0LO1PxELG" initialValue="(solver='cholesky',alpha=0.0)"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ul3TB4QggKnk9" name="mOutName" type="ugOBJvbb8orVV" initialValue="&quot;PolyTrend&quot;"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uZFOyxaWB19CZ" name="mFormula" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u5n2I6YzU2yzg" name="mComplexity" type="uHWf8zoUhsnrH"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="udhdtuEWV0lNL" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uiYpOWD9lhqpz" name="fit_specific"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u4MaEJWYiSDmM" name="compute">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u1jqlUuFJyT1a" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5v4RMvxy8XHg" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uh1R285NrRbG1" name="dump_values"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="u4gyFWDbb9P9V" name="cTrendEstimator">
        <ownedAttribute xmi:type="uml:Property" xmi:id="uoV71sXs6auMz" name="mTimeInfo" type="uIEm0LO1PxELG" initialValue="()"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ube1knJKalrY7" name="mTrendFrame" type="uHWf8zoUhsnrH" initialValue="None"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uh9nDop24Np8e" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uNdifeXEbF0tS" name="needMovingTrend">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u1prSTKKssD5p" type="uRs0v9QAfE7td" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubYJrTrpwY0Kh" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCYpLtxQTJ8zW" name="i" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uN3f1i1RzHbiW" name="defineTrends" comment="logger = tsutil.get_pyaf_logger(); logger.info(&quot;ACTIVE_TRENDS&quot; + str(self.mOptions.mActiveTrends)); logger.info(&quot;TRENDS&quot; + str([tr.mOutName for tr in self.mTrendList]));"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uUxO7ibqSRz03" name="plotTrend"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uGEfOQtjbITFo" name="addTrendInputVariables"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ukCOsz7mdkz8K" name="check_residue" comment="print(&quot;check_trend_residue &quot;, (name, trend.mDecompositionType, sig.min(), sig.max(), sig.mean(), sig .std()))">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uSKLynNnhldqM" name="trend" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVSgKaZ0FqJZT" name="sig" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCfbvXTIiGBBe" name="name" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uVQf0zb53V5BO" name="estimateTrends"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uCnY1i5AHfq2j" name="estimateTrend"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uFGbd2Oy1fUBu" name="cTimeSeriesModel">
        <ownedAttribute xmi:type="uml:Property" xmi:id="uYCrMATEtf1Yl" name="mDecompositionType" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="udZEE7khumjMZ" name="mTrend" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ue3x85l02VCC2" name="mCycle" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uCD4HYQv9qcDP" name="mAR" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uKNYI0r63hLNM" name="mFitPerformances" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ucexMMQ5xWhcl" name="mForecastPerformances" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uLjU52FraZD14" name="mTestPerformances" type="ugWmBt0uWHYFW" initialValue="{}"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u5d1FVjRC1jFA" name="mOutName" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uRykE90vhiqxu" name="mOriginalSignal" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uSjpyrGWyr0vX" name="mTimeInfo" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u6yOSe91kMx2B" name="mTime" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uITV71bnsNUis" name="mSignal" type="uHWf8zoUhsnrH"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uca4YEiqzTT6I" name="mTrainingVersionInfo" type="uIEm0LO1PxELG" initialValue="()"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uoSMTjU6dJ90R" name="__init__" stereotype="constructor">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u3XObE1V8knWt" name="transf" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uIJ3hKnfoRfwy" name="iDecompType" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ulaDBzUBWwVhq" name="trend" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uw6XfIdlbbGOZ" name="cycle" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uwaCk0eazm241" name="autoreg" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ucaZpOor1mcWg" name="get_model_category">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ugiTJvtz1yLmk" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u40Q8Ct1tm2go" name="getComplexity" comment="This is just a way to give priority to additive decompositions (default = 0 for additive).">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uHsCPF9TgFXly" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uTccJUCvRZPbn" name="getComplexity_as_ordering_string">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u2KMfH80h8PCJ" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uAeR38TdONj6r" name="updateAllPerfs"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uceZ2IGFAGYPe" name="updatePerfs" comment="Investigate Large Horizon Models #213 : generate all prediction intervals for all models. Keep the model that holds the best perf at the horizon H. Consider perfs a horizon H instead of looking at horizon 1 (WIP ...). Don't compute all the perf indicators for the model selection (AUC is not relevant here, speed issues). Compute all the perf indicators for the selected model at the end of training. lTimer = tsutil.cTimer((&quot;UPDATE_MODEL_PERFS&quot;, {&quot;Signal&quot; : self.mOriginalSignal, &quot;Model&quot; : self.mOutName}))">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uQVQe5FLNtsT7" name="compute_all_indicators" visibility="private" type="uRs0v9QAfE7td" value="False"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uwOLcMkm4YzSG" name="get_perfs_summary">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u95oCJKdziQO5" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uH8sMNeOlP0YX" name="aggregate_criteria">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uexxCBlTvdNza" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uX0n8oLTMOvhg" name="criteria" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uov8RICqFJ1i2" name="get_aggregated_criterion_values_for_model_selection">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uyY66TQ4HX668" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ulIRcBxebyAy6" name="computePredictionIntervals" comment="prediction intervals"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uxLJiNvvLztL8" name="getFormula">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="usOBtcXyVezVF" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uEQkFyaDtrRNc" name="signal_info">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uDtnrDfsKwbSV" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u9CiSgmNHtCGz" name="perf_info"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u8f7qKXuNy1pt" name="decomposition_info"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uWrQCUXIypA4r" name="decomposition_detail_info"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uH2QBjPIdrL78" name="getInfo"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uaXBLmbKg6qFv" name="compute_model_forecast">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u98V6UUNAkCbh" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u7WEjPMSGGyk0" name="iTrendValue" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uR2kEEFMCmthv" name="iCycleValue" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uS1lu8SdFAIqA" name="iARValue" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uqplocyB1swtG" name="forecastOneStepAhead" comment="df1.to_csv(&quot;before.csv&quot;); add new line with new time value, row_number and nromalized time add signal tranformed column df1.to_csv(&quot;after_transformation.csv&quot;);print(&quot;Transformation update : &quot; , df1.columns); df1.to_csv(&quot;after_time.csv&quot;); print(&quot;TimeInfo update : &quot; , df1.columns); compute the trend based on the transformed column and compute trend residueprint(&quot;Trend update : &quot; , df1.columns); df1.to_csv(&quot;after_trend.csv&quot;); compute the cycle and its residue based on the trend residue df1.to_csv(&quot;after_cycle.csv&quot;);print(&quot;Cycle update : &quot; , df1.columns); compute the AR componnet and its residue based on the cycle residue df1.to_csv(&quot;after_ar.csv&quot;);print(&quot;AR update : &quot; , df1.columns); compute the forecast and its residue (forecast = trend  + cycle + AR) print(&quot;TimeSeriesModel_forecast_invert&quot;);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uxIKsp5DD97jv" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="upOhtmh9AQEbS" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uQOR1mO7yMN2h" name="horizon_index" visibility="private" type="uflKAzaz4ozb2" value="1"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="un8YlVmpGvqYh" name="perf_mode" visibility="private" type="uRs0v9QAfE7td" value="False"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="urbdgC4rd9VGW" name="forecast_all_horizons" comment="print(df1.info()); replace the signal with the forecast in the last line  of the dataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uAyB3veM5uy6U" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uqhcqHdCLzwcz" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubZ8DAQeBrK3X" name="iHorizon" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uXAkDeyxcdmGT" name="forecast" comment="print(df.head()) print(df1.head())">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uj5aDwWmwLTjK" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uNWjUHm5n2DQB" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uKVKyosYruhzS" name="iHorizon" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uaoLBNZHQEUc4" name="applyForecastRectifier">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uTKg0pABySYkn" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uSEBtiM3UPtyt" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uQotYnNIeX509" name="addPredictionIntervals" comment="0.95 the prediction intervals are only computed for the training horizon print(lForcastValues.head(lHorizon)) print(iHorizon, self.mTimeInfo.mHorizon, lHorizon, lForcastValues.shape) print(lWidths)">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uwS7xwLcsdfaV" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="urYMOHeDbag8u" name="iInputDS" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="up8wvUSZt2HsG" name="iForecastFrame" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uBThRfm3ugcoe" name="iHorizon" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uXR9hxbSuFpxD" name="addForecastQuantiles" comment="the prediction intervals are only computed for the training horizon">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uA5VFT0tr8iar" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ue1UOcwT2JaWZ" name="iInputDS" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ueBcU8P0jBAjP" name="iForecastFrame" visibility="private" type="uIEm0LO1PxELG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="umd2WiTURtn3Q" name="iHorizon" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u2xtAQ4RLbK6g" name="plotForecasts">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u1ZsfVu8T1A7r" name="df" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ulPiooPlpiGc8" name="to_dict">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uQfiaBKGLmRxd" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ukWqnASVPfxDD" name="iWithOptions" visibility="private" type="uRs0v9QAfE7td" value="False"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uOyc0ICQLtThk" name="getForecastDatasetForPlots">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uFHWiC7u6BVik" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ulvZzBEX2Z753" name="plotResidues" comment="NormalizedTimeColumn;">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u2VZ3uqbgwUHu" name="name" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ujx3Eo74W6I3L" name="format" visibility="private" type="uHWf8zoUhsnrH" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="upwXz5xy9z9gA" name="iOutputDF" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uNrPBWFuBmF8v" name="get_title_details_for_plots">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="us7FJeAV6XwWY" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uEoi7FCHBEJMH" name="iPrefix" visibility="private" type="uIEm0LO1PxELG" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u01lwKFr7u72Q" name="standardPlots" comment="print(lOutput.columns) print(lOutput[lTime].dtype); Add more informative title for this plot.  Investigate Model Esthetics for PyAF #212 lOutput.plot()">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ukiSGsf3jLQKS" name="name" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVDgCNbsvHsYa" name="format" visibility="private" type="uHWf8zoUhsnrH" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uiZNk4AsY9Aur" name="getPlotsAsDict"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u3FBO4zXvlqc2" name="getPredictionIntervalPlot">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCqFiSVCXMvsk" type="ugOBJvbb8orVV" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVTXTEV0E0cKk" name="df" visibility="private" type="uHWf8zoUhsnrH" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uSyhsb9gbL8BQ" name="getVersions">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uRMFHbNoeu3vl" type="ugOBJvbb8orVV" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ug2D6e50zibgw" name="clean_dataframes" comment="print(self.mTrend.mSignalFrame.columns)"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="u8vOzWIeyGFt7" name="self" stereotype="class-or-package"/>
      <xmi:Extension extender="umbrello">
        <diagrams resolution="96">
          <diagram xmi.id="uN919dazZ2VBU" name="class diagram" type="1" documentation="" backgroundcolor="#ffffff" fillcolor="#ffffc0" font="Cantarell,11,-1,5,50,0,0,0,0,0" griddotcolor="#f7f7f7" linecolor="#990000" linewidth="0" textcolor="#000000" usefillcolor="1" showattribassocs="1" showatts="1" showattsig="0" showops="1" showopsig="0" showpackage="1" showpubliconly="0" showscope="1" showstereotype="1" localid="-1" showgrid="0" snapgrid="0" snapcsgrid="0" snapx="25" snapy="25" zoom="100" canvasheight="800" canvaswidth="1100" isopen="1">
            <widgets>
              <classwidget xmi.id="uJ1fzpHjvhIND" localid="u38J1l8NG5v6y" textcolor="#000000" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="0" usesdiagramusefillcolor="0" fillcolor="#ffffc0" font="Cantarell,11,-1,5,50,0,0,0,0,0" autoresize="1" x="513" y="612" width="179" height="162" isinstance="0" showstereotype="1" showoperations="1" showpubliconly="0" showopsigs="600" showpackage="1" showscope="1" showattributes="1" showattsigs="600"/>
              <classwidget xmi.id="u3H2S0KTwrCiu" localid="uV39ansMn0bCG" textcolor="#000000" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="0" usesdiagramusefillcolor="0" fillcolor="#ffffc0" font="Cantarell,11,-1,5,50,0,0,0,0,0" autoresize="1" x="147" y="532" width="179" height="270" isinstance="0" showstereotype="1" showoperations="1" showpubliconly="0" showopsigs="600" showpackage="1" showscope="1" showattributes="1" showattsigs="600"/>
              <classwidget xmi.id="uqTXfxrZtzFEz" localid="u2qIJ8wgytU8K" textcolor="#000000" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="0" usesdiagramusefillcolor="0" fillcolor="#ffffc0" font="Cantarell,11,-1,5,50,0,0,0,0,0" autoresize="1" x="447" y="97" width="297" height="288" isinstance="0" showstereotype="1" showoperations="1" showpubliconly="0" showopsigs="600" showpackage="1" showscope="1" showattributes="1" showattsigs="600"/>
              <classwidget xmi.id="uTPMJ3RwCxK47" localid="u1YGLUDTwWJ14" textcolor="#000000" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="0" usesdiagramusefillcolor="0" fillcolor="#ffffc0" font="Cantarell,11,-1,5,50,0,0,0,0,0" autoresize="1" x="831" y="544" width="179" height="198" isinstance="0" showstereotype="1" showoperations="1" showpubliconly="0" showopsigs="600" showpackage="1" showscope="1" showattributes="1" showattsigs="600"/>
            </widgets>
            <messages/>
            <associations>
              <assocwidget xmi.id="uOqomTFpvoOWh" localid="uWPjohcCAI3eT" textcolor="none" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="1" usesdiagramusefillcolor="1" fillcolor="none" font="Cantarell,11,-1,5,50,0,0,0,0,0" autoresize="1" seqnum="" type="500" widgetaid="uJ1fzpHjvhIND" widgetbid="uqTXfxrZtzFEz" indexa="0" totalcounta="0" indexb="0" totalcountb="0">
                <linepath layout="Direct">
                  <startpoint startx="601.246" starty="612"/>
                  <endpoint endx="597.73" endy="385"/>
                </linepath>
              </assocwidget>
              <assocwidget xmi.id="uokoni6bW5dXo" localid="uRgljrsQfRWSa" textcolor="none" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="1" usesdiagramusefillcolor="1" fillcolor="none" font="Cantarell,11,-1,5,50,0,0,0,0,0" autoresize="1" seqnum="" type="500" widgetaid="uTPMJ3RwCxK47" widgetbid="uqTXfxrZtzFEz" indexa="0" totalcounta="0" indexb="0" totalcountb="0">
                <linepath layout="Direct">
                  <startpoint startx="840.463" starty="544"/>
                  <endpoint endx="711.918" endy="385"/>
                </linepath>
              </assocwidget>
              <assocwidget xmi.id="uSr2Dg0902b11" localid="u3zsA3dcUiTHB" textcolor="none" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="1" usesdiagramusefillcolor="1" fillcolor="none" font="Cantarell,11,-1,5,50,0,0,0,0,0" autoresize="1" seqnum="" type="500" widgetaid="u3H2S0KTwrCiu" widgetbid="uqTXfxrZtzFEz" indexa="0" totalcounta="0" indexb="0" totalcountb="0">
                <linepath layout="Direct">
                  <startpoint startx="326" starty="560.797"/>
                  <endpoint endx="474.148" endy="385"/>
                </linepath>
              </assocwidget>
            </associations>
          </diagram>
        </diagrams>
      </xmi:Extension>
    </packagedElement>
    <packagedElement xmi:type="uml:Model" xmi:id="Use_Case_View" name="Use Case View"/>
    <packagedElement xmi:type="uml:Model" xmi:id="Component_View" name="Component View"/>
    <packagedElement xmi:type="uml:Model" xmi:id="Deployment_View" name="Deployment View"/>
    <packagedElement xmi:type="uml:Model" xmi:id="Entity_Relationship_Model" name="Entity Relationship Model"/>
  </uml:Model>
  <xmi:Extension extender="umbrello">
    <docsettings viewid="uN919dazZ2VBU" documentation="" uniqueid="uWPjohcCAI3eT"/>
    <listview>
      <listitem id="Views" type="800" open="1">
        <listitem id="Component_View" type="821" open="1"/>
        <listitem id="Deployment_View" type="827" open="1"/>
        <listitem id="Entity_Relationship_Model" type="836" open="1"/>
        <listitem id="Logical_View" type="801" open="1">
          <listitem id="upu5DdfGD6JGr" type="813" open="0">
            <listitem id="uzwTl5lh3zyK0" type="815" open="0"/>
            <listitem id="uh4krWdd3Nkpg" type="815" open="0"/>
            <listitem id="uQBOmFR8x2pVg" type="815" open="0"/>
            <listitem id="uXmH1oq0Nwg6i" type="815" open="0"/>
            <listitem id="uhY13R1uSWLYt" type="815" open="0"/>
            <listitem id="u5EPgRjxi6we7" type="815" open="0"/>
            <listitem id="uJzEVElSTbfEE" type="815" open="0"/>
            <listitem id="uznNO4Rtnn7g1" type="815" open="0"/>
            <listitem id="u7vzda8iZA1qL" type="815" open="0"/>
            <listitem id="uzTKu1HXVlcN6" type="815" open="0"/>
            <listitem id="uh90yaGa1QSl1" type="815" open="0"/>
            <listitem id="uecBc2C7OWi1r" type="815" open="0"/>
            <listitem id="uTsflD07v80j1" type="815" open="0"/>
            <listitem id="ulCER3i32p3CY" type="815" open="0"/>
            <listitem id="ukB20WULoyFuI" type="814" open="0"/>
            <listitem id="uvMnEE1QnjXOa" type="814" open="0"/>
            <listitem id="uUchqJoWs9Rsz" type="814" open="0"/>
            <listitem id="uyWXnStp5qZcd" type="814" open="0"/>
            <listitem id="uMAV6W4NxW7IA" type="815" open="0"/>
            <listitem id="uyoL8avbeCjIh" type="815" open="0"/>
            <listitem id="uyIJJyOTuKkm6" type="815" open="0"/>
            <listitem id="uZqduv9OGrKpA" type="815" open="0"/>
          </listitem>
          <listitem id="u1nHQ65kdzj1f" type="813" open="0">
            <listitem id="ubEZx9UOVqGoe" type="815" open="0"/>
            <listitem id="uzVcOYgt6gESQ" type="815" open="0"/>
            <listitem id="uTz03XZqrNOMC" type="815" open="0"/>
            <listitem id="umeq1fUhFugGM" type="815" open="0"/>
            <listitem id="uV6nQYUanEDhg" type="815" open="0"/>
            <listitem id="ugndGcN5jGJNO" type="815" open="0"/>
            <listitem id="u8kHeVRpGWFWH" type="814" open="0"/>
            <listitem id="uGWlXohnNWRyA" type="814" open="0"/>
            <listitem id="u2Br17c44RQTc" type="814" open="0"/>
            <listitem id="ucKvg4dfGsr1G" type="814" open="0"/>
            <listitem id="u6eACzILVoHjw" type="814" open="0"/>
            <listitem id="u0ozNYvXmc16S" type="814" open="0"/>
            <listitem id="u4kR7Nx9ZAinz" type="814" open="0"/>
            <listitem id="uiZuIUDISbiwt" type="814" open="0"/>
            <listitem id="uIY8LLHuoVCpF" type="814" open="0"/>
            <listitem id="uPsFeQrq1BR9Q" type="814" open="0"/>
            <listitem id="uJFYqVrYRL7YI" type="814" open="0"/>
            <listitem id="uzUL5inTKXjoh" type="815" open="0"/>
            <listitem id="uC2pG7oXaXH6Y" type="815" open="0"/>
            <listitem id="uoJV1ghZWOJLD" type="815" open="0"/>
          </listitem>
          <listitem id="uqTXfxrZtzFEz" type="813" open="0">
            <listitem id="ua5B6cgfG0mCr" type="815" open="0"/>
            <listitem id="uzMoE7EF4HSQX" type="815" open="0"/>
            <listitem id="upcVodfUaUvYc" type="815" open="0"/>
            <listitem id="ukU6Ni56wMecc" type="815" open="0"/>
            <listitem id="u6SarybF6EFot" type="815" open="0"/>
            <listitem id="uHl97yKUOrZA4" type="815" open="0"/>
            <listitem id="uaxDsX9Nj2tJX" type="815" open="0"/>
            <listitem id="uLUNqk2IRJ2hY" type="815" open="0"/>
            <listitem id="utQWgO5uv9Kb3" type="814" open="0"/>
            <listitem id="uza3Gf5gDBYpd" type="814" open="0"/>
            <listitem id="u4OEPQMBkOA5V" type="814" open="0"/>
            <listitem id="u4LeEPKGtmH3w" type="814" open="0"/>
            <listitem id="uf0l1inalL7mm" type="814" open="0"/>
            <listitem id="u2EoZVvii0Tob" type="814" open="0"/>
            <listitem id="uZL1fU0NPGckr" type="815" open="0"/>
          </listitem>
          <listitem id="uA6nW3whLXUdX" type="813" open="0">
            <listitem id="utkUsDXaS9o6L" type="815" open="0"/>
            <listitem id="upuSbTVBmcj6M" type="815" open="0"/>
            <listitem id="usQfdklOgbaoE" type="815" open="0"/>
            <listitem id="uWhl5X60MPXZF" type="815" open="0"/>
            <listitem id="uuBxt2evxRvPJ" type="815" open="0"/>
            <listitem id="uqQSVEGV81vAH" type="815" open="0"/>
            <listitem id="uLDJxNQ7EDXc3" type="815" open="0"/>
            <listitem id="uFytguC6ERyk6" type="815" open="0"/>
            <listitem id="uitpQqkCTivjD" type="815" open="0"/>
            <listitem id="ujJpx4Fiz63xA" type="814" open="0"/>
            <listitem id="u8x1ja49UCH98" type="814" open="0"/>
            <listitem id="un72HFbESKPow" type="814" open="0"/>
            <listitem id="uq0bT0muWCfu7" type="815" open="0"/>
            <listitem id="urbzh4KxtWiOn" type="815" open="0"/>
            <listitem id="uyMa6lYPg36gr" type="815" open="0"/>
            <listitem id="utSg7W6HyGaZF" type="815" open="0"/>
            <listitem id="udmWCyVJARXae" type="815" open="0"/>
            <listitem id="uiMS1DDfRS23c" type="815" open="0"/>
          </listitem>
          <listitem id="usMOgteztFLF0" type="813" open="0">
            <listitem id="uZpMOcg2UEsDJ" type="815" open="0"/>
            <listitem id="u1ozqqFJxYO3R" type="815" open="0"/>
            <listitem id="u3wIkWjm2FuXr" type="815" open="0"/>
            <listitem id="uWo0o7fQ0DSno" type="815" open="0"/>
            <listitem id="uZfsgUiUADNg6" type="815" open="0"/>
            <listitem id="u1P45xww8kwuZ" type="815" open="0"/>
            <listitem id="uB25uTDQSfO5L" type="815" open="0"/>
            <listitem id="uHExlQs1kpTiY" type="814" open="0"/>
            <listitem id="uZ1iRgsTmpQlk" type="814" open="0"/>
            <listitem id="ud8Nkc9MdcgBo" type="814" open="0"/>
            <listitem id="upPHVLQ0ziQfr" type="814" open="0"/>
            <listitem id="uC4KCeiB9wzAK" type="814" open="0"/>
            <listitem id="uGwZTOxRxMO7t" type="814" open="0"/>
            <listitem id="uTB1uSTUM138h" type="815" open="0"/>
          </listitem>
          <listitem id="uVrVvaDwQwBYQ" type="813" open="0">
            <listitem id="uNxqFdwhwwil2" type="815" open="0"/>
            <listitem id="usphBUia6EtDo" type="815" open="0"/>
            <listitem id="ugLPP1V4uPPvG" type="815" open="0"/>
            <listitem id="us23X8cdJWWQn" type="815" open="0"/>
            <listitem id="uvTz4eTD0YzFj" type="815" open="0"/>
            <listitem id="uT0Ug1qNE3jGM" type="815" open="0"/>
            <listitem id="uCO4j0qSzBB6u" type="815" open="0"/>
            <listitem id="u0WDWEUADAK7G" type="815" open="0"/>
            <listitem id="uo6MASQSPhs7c" type="815" open="0"/>
            <listitem id="uJNYagu5g8VJU" type="814" open="0"/>
            <listitem id="uHj6huV5QdgQK" type="814" open="0"/>
            <listitem id="uVMAmOqNU3Qwh" type="814" open="0"/>
            <listitem id="uyB93rF6tT3H4" type="814" open="0"/>
            <listitem id="uxE6mo1sJlEQ2" type="815" open="0"/>
            <listitem id="ufcZBm04NbPFK" type="815" open="0"/>
            <listitem id="u6JehlY8psVHS" type="815" open="0"/>
          </listitem>
          <listitem id="u3H2S0KTwrCiu" type="813" open="0">
            <listitem id="uutTIxfuoMONt" type="815" open="0"/>
            <listitem id="uWCWqQNwfWpcA" type="815" open="0"/>
            <listitem id="u9r0e2yzpDGWX" type="815" open="0"/>
            <listitem id="utC8FlK14OLwj" type="815" open="0"/>
            <listitem id="unxsgAwSvnXN6" type="815" open="0"/>
            <listitem id="ukH47pDxQUwC2" type="815" open="0"/>
            <listitem id="ul3E5GSshC3yr" type="815" open="0"/>
            <listitem id="uXrrOOGPJcsLu" type="814" open="0"/>
            <listitem id="uypzZOMLvZw4J" type="814" open="0"/>
            <listitem id="u02XKeGJn4vcw" type="814" open="0"/>
            <listitem id="ubh7VMa3S4glT" type="814" open="0"/>
            <listitem id="u3yfZUTZR0q4w" type="814" open="0"/>
            <listitem id="uSrzQdMwVzhUf" type="814" open="0"/>
            <listitem id="u3Dfl8wSu3sNL" type="815" open="0"/>
          </listitem>
          <listitem id="uCUnWpvj7Xl3p" type="813" open="0">
            <listitem id="uwoxvtrSdoE38" type="815" open="0"/>
            <listitem id="uHXYkRtRB6kOv" type="815" open="0"/>
            <listitem id="uXg3FMRHMngcO" type="815" open="0"/>
            <listitem id="u0hlIdKwTrF20" type="815" open="0"/>
            <listitem id="ud3W7soTkmdPQ" type="814" open="0"/>
            <listitem id="u1UQxbQdwIFlv" type="814" open="0"/>
            <listitem id="uoekbQt6aD7NV" type="814" open="0"/>
            <listitem id="u1Muz2chsohiH" type="814" open="0"/>
          </listitem>
          <listitem id="uR7STKbsESNhb" type="813" open="0">
            <listitem id="u1HI4MmuNFvbw" type="815" open="0"/>
            <listitem id="uV9C41Q69tDob" type="815" open="0"/>
            <listitem id="urUrrJUW9uY3A" type="815" open="0"/>
            <listitem id="uWVbF4301LTke" type="815" open="0"/>
            <listitem id="uqp04gufZXOrg" type="815" open="0"/>
            <listitem id="uaWQ5JHyIjirm" type="815" open="0"/>
            <listitem id="ud0JUHPhXru5R" type="815" open="0"/>
            <listitem id="uZnbxWvSfZ0ED" type="814" open="0"/>
            <listitem id="uMdeFmSTgldUo" type="814" open="0"/>
            <listitem id="uDvkM7HsHN27O" type="814" open="0"/>
            <listitem id="uxLBu9CKzXOMc" type="815" open="0"/>
            <listitem id="uJ6SSjUYLrHTk" type="815" open="0"/>
            <listitem id="u6w994pjxnjuS" type="815" open="0"/>
          </listitem>
          <listitem id="uxrTqZubGIuhd" type="813" open="0">
            <listitem id="uUU6qdkJIwfeD" type="815" open="0"/>
            <listitem id="uuyGMrtIL4AHa" type="815" open="0"/>
            <listitem id="uEWbPubGKnQgZ" type="815" open="0"/>
            <listitem id="uYx1uQ403wIuX" type="815" open="0"/>
            <listitem id="u0y9VpUP6gKDr" type="815" open="0"/>
            <listitem id="usYLyon0iv4DR" type="815" open="0"/>
            <listitem id="umGTJSPfQrsAX" type="814" open="0"/>
            <listitem id="uWmlcwprdoIDS" type="814" open="0"/>
            <listitem id="uubc8OQ8IEatb" type="814" open="0"/>
            <listitem id="u4QVQZnX4qYYq" type="815" open="0"/>
          </listitem>
          <listitem id="uaGQQUSgaKYRT" type="813" open="0">
            <listitem id="udXfxrUBilw66" type="815" open="0"/>
            <listitem id="uOCoPK42mulaO" type="815" open="0"/>
            <listitem id="u9ocozO6X6qEe" type="815" open="0"/>
            <listitem id="uqmmljl4c9Gf6" type="815" open="0"/>
            <listitem id="uP878PTJOMknb" type="814" open="0"/>
            <listitem id="up1GGJM55vGkm" type="814" open="0"/>
            <listitem id="u4qqBkqAFTARh" type="814" open="0"/>
            <listitem id="uCIbfPZXUHra0" type="814" open="0"/>
            <listitem id="ugz4DYCCscjR1" type="815" open="0"/>
          </listitem>
          <listitem id="uN919dazZ2VBU" type="807" label="class diagram" open="0"/>
          <listitem id="uYxIki8MPqNHO" type="813" open="0">
            <listitem id="u9dENnSbakBur" type="815" open="0"/>
            <listitem id="uYZ7SVPLh4Zv2" type="815" open="0"/>
            <listitem id="uoRtj1J1CDvuA" type="815" open="0"/>
            <listitem id="uX6pq5phofWAs" type="815" open="0"/>
            <listitem id="uhb3qgz5k3C49" type="814" open="0"/>
            <listitem id="u6PhqE6hmLCdc" type="814" open="0"/>
            <listitem id="uZVv9fOs92ztA" type="814" open="0"/>
            <listitem id="u8USvF3vYpa0b" type="814" open="0"/>
          </listitem>
          <listitem id="us5qlqlYczy5J" type="813" open="0">
            <listitem id="uL41yTHBNnpw4" type="815" open="0"/>
            <listitem id="uP2Prb8Qpuoii" type="815" open="0"/>
            <listitem id="uttdZL9Emsb2O" type="815" open="0"/>
            <listitem id="uglk3NQcPyy8y" type="815" open="0"/>
            <listitem id="u3ZV4V26BVG2i" type="815" open="0"/>
            <listitem id="usQQlSgjCfm1k" type="815" open="0"/>
            <listitem id="ugZjkESWTgzSF" type="815" open="0"/>
            <listitem id="uMAYLmWotLIai" type="814" open="0"/>
            <listitem id="uyN7ccbp3xxar" type="815" open="0"/>
            <listitem id="u1PFBzSVOJNFO" type="815" open="0"/>
            <listitem id="u8syzK28vEpl2" type="815" open="0"/>
          </listitem>
          <listitem id="ueDUNLAuEO6pl" type="813" open="0">
            <listitem id="urvKSTuYp1dtL" type="815" open="0"/>
            <listitem id="uvf2HRI8UQxFx" type="815" open="0"/>
            <listitem id="u3yUDFSmeYW3k" type="814" open="0"/>
          </listitem>
          <listitem id="u3UhTKGgkawN2" type="813" open="0">
            <listitem id="uKAnPZuI3K8d2" type="815" open="0"/>
            <listitem id="uP1DLxZ3qxyho" type="815" open="0"/>
            <listitem id="uX1VVpwtcsnEt" type="815" open="0"/>
            <listitem id="uEUwI9qmexzrX" type="815" open="0"/>
            <listitem id="u7gleJhpimUaG" type="815" open="0"/>
            <listitem id="unlTnMN7wWERQ" type="815" open="0"/>
            <listitem id="uwp44KTCDO8v7" type="814" open="0"/>
            <listitem id="uJcvFSfku8QiF" type="815" open="0"/>
            <listitem id="uJNfWelEHWHqb" type="815" open="0"/>
            <listitem id="uQDG2XBIORq4n" type="815" open="0"/>
          </listitem>
          <listitem id="uwl2oqz9h7Wdj" type="813" open="0">
            <listitem id="ucJfJenWxCw6W" type="815" open="0"/>
            <listitem id="uzyGBZhuybO8o" type="815" open="0"/>
            <listitem id="uUQcN5fscdmTt" type="815" open="0"/>
            <listitem id="uLOsuiRDes5tK" type="815" open="0"/>
            <listitem id="uNawJHvBjoyLs" type="814" open="0"/>
            <listitem id="u9N4crwiMbWIQ" type="814" open="0"/>
            <listitem id="u1w1DBBmXwyAl" type="814" open="0"/>
            <listitem id="udLKdeAFOC2mB" type="814" open="0"/>
          </listitem>
          <listitem id="ujEXUx4pr64kM" type="813" open="0">
            <listitem id="utdyzzKqmqXTB" type="815" open="0"/>
            <listitem id="u3EvnL7CIAmbu" type="815" open="0"/>
            <listitem id="uocNp84Y2gUk8" type="815" open="0"/>
            <listitem id="u9PLSQmjcZ63c" type="815" open="0"/>
            <listitem id="u3PxTNT2K9QpY" type="814" open="0"/>
            <listitem id="uLULZEw4LPxBz" type="814" open="0"/>
            <listitem id="u9eoMSHIydWbv" type="814" open="0"/>
            <listitem id="u1r7EP2Pl1HTa" type="814" open="0"/>
          </listitem>
          <listitem id="u9wB2uEDWBDUM" type="813" open="0">
            <listitem id="udhdtuEWV0lNL" type="815" open="0"/>
            <listitem id="u4MaEJWYiSDmM" type="815" open="0"/>
            <listitem id="uh1R285NrRbG1" type="815" open="0"/>
            <listitem id="uiYpOWD9lhqpz" type="815" open="0"/>
            <listitem id="u5n2I6YzU2yzg" type="814" open="0"/>
            <listitem id="uZFOyxaWB19CZ" type="814" open="0"/>
            <listitem id="ul3TB4QggKnk9" type="814" open="0"/>
            <listitem id="uUp6BERXGpK9n" type="814" open="0"/>
          </listitem>
          <listitem id="uTPMJ3RwCxK47" type="813" open="0">
            <listitem id="uN3ILfbNnLG02" type="815" open="0"/>
            <listitem id="uAx3CSB1LsRz3" type="815" open="0"/>
            <listitem id="u423Kdrh3M2pM" type="815" open="0"/>
            <listitem id="uZ6scia9UK12U" type="815" open="0"/>
            <listitem id="ufichRs13oCkO" type="815" open="0"/>
            <listitem id="u2ACq4Ov8hpNK" type="815" open="0"/>
            <listitem id="ukBqnARAvhZRF" type="814" open="0"/>
            <listitem id="uJ90Yd8IhwdZT" type="814" open="0"/>
            <listitem id="uHPBrrnXDwR0i" type="814" open="0"/>
            <listitem id="uCG6hwIRq9MBX" type="815" open="0"/>
          </listitem>
          <listitem id="u3cR0eISUWAxi" type="813" open="0">
            <listitem id="uCdbvcJBAVvZF" type="815" open="0"/>
            <listitem id="uuACekITyA07J" type="815" open="0"/>
            <listitem id="udeb0VCi9ojHI" type="814" open="0"/>
            <listitem id="uRoXpw52ShJ7j" type="814" open="0"/>
          </listitem>
          <listitem id="uLFVWU4hcQyY7" type="813" open="0">
            <listitem id="uNmf8UlZPbU7M" type="815" open="0"/>
            <listitem id="uAz1ZI2Ia596i" type="815" open="0"/>
            <listitem id="uDgm1uFJdr4y1" type="815" open="0"/>
          </listitem>
          <listitem id="udKBKv2lgIZGu" type="813" open="0">
            <listitem id="u5E2Ks3lGS4yq" type="815" open="0"/>
            <listitem id="ucSOpe1HXOq5C" type="814" open="0"/>
            <listitem id="upLrR8xhIGWSo" type="814" open="0"/>
            <listitem id="u6ZFUKZQTMM8r" type="814" open="0"/>
            <listitem id="uS0GUQSFDOGVP" type="814" open="0"/>
            <listitem id="ucuMSIrExYph2" type="815" open="0"/>
            <listitem id="u6Ci8puPDoLz1" type="815" open="0"/>
            <listitem id="uW6iB0e4cCsgP" type="815" open="0"/>
          </listitem>
          <listitem id="uL7ETIjNqId8p" type="813" open="0">
            <listitem id="uZFpuAwHhFL1m" type="815" open="0"/>
            <listitem id="uW9wNO8aKBIc7" type="815" open="0"/>
            <listitem id="uYxyszxOGwEtH" type="815" open="0"/>
            <listitem id="u5HZUchzwnypK" type="815" open="0"/>
            <listitem id="uArMQP1Sv6kgk" type="815" open="0"/>
            <listitem id="uYczJpiqunGm6" type="814" open="0"/>
            <listitem id="uk4xZ2qvZANVb" type="814" open="0"/>
            <listitem id="ujRxU6qecjKiH" type="814" open="0"/>
            <listitem id="u9UHnO7ypi9yR" type="815" open="0"/>
            <listitem id="uoDA1ROaTRznh" type="815" open="0"/>
          </listitem>
          <listitem id="unp086rhZhHLt" type="813" open="0">
            <listitem id="ut4JQCYu8lPBk" type="815" open="0"/>
            <listitem id="uq1bJzwI18rCn" type="815" open="0"/>
            <listitem id="uVRi4MMQyvn2G" type="815" open="0"/>
            <listitem id="uxfTB8DBKYIUr" type="815" open="0"/>
          </listitem>
          <listitem id="ug8Te23ZloGHA" type="813" open="0">
            <listitem id="ulhSzaDib6ls0" type="815" open="0"/>
            <listitem id="uKzg4nawVIgMi" type="815" open="0"/>
            <listitem id="ucZY8QHnJZd2A" type="815" open="0"/>
            <listitem id="uzRT7pizGbgT7" type="814" open="0"/>
            <listitem id="uCieX5aXQoC0k" type="814" open="0"/>
            <listitem id="ulI9yxBPhvOOD" type="814" open="0"/>
            <listitem id="uSnPt1dPPJsxF" type="815" open="0"/>
            <listitem id="u7GQeLpZ2q8nw" type="815" open="0"/>
            <listitem id="uvYeiTTO7J6Sh" type="815" open="0"/>
          </listitem>
          <listitem id="uq0LrPP3PkV72" type="813" open="0">
            <listitem id="ut6hwToey9BJj" type="814" open="0"/>
            <listitem id="u1vtbrq1iIGiP" type="814" open="0"/>
            <listitem id="uU4Jy4R3Iuttf" type="814" open="0"/>
            <listitem id="uqOa1LGxFDKsx" type="814" open="0"/>
          </listitem>
          <listitem id="uYTuR9fOSZefY" type="813" open="0">
            <listitem id="ujn10CropSiJK" type="815" open="0"/>
            <listitem id="u94PimE8VWnfV" type="815" open="0"/>
            <listitem id="uOldQDUkPnA75" type="815" open="0"/>
            <listitem id="uIr5g7spjgizz" type="815" open="0"/>
            <listitem id="uNoj9taSsp3pB" type="814" open="0"/>
            <listitem id="uemsgsqQCuakH" type="814" open="0"/>
            <listitem id="uDB3MLPXhyIYa" type="814" open="0"/>
            <listitem id="u3aOpfQm9es18" type="814" open="0"/>
            <listitem id="uHvjwYDI5ZnVW" type="815" open="0"/>
            <listitem id="u7eZxe39VTHZL" type="815" open="0"/>
            <listitem id="uXwMy2nQtDCO4" type="815" open="0"/>
          </listitem>
          <listitem id="uhvdjXnwVrKsz" type="813" open="0">
            <listitem id="uaSjXNSDJfLQ4" type="815" open="0"/>
            <listitem id="ukfSxXofaCHS7" type="815" open="0"/>
            <listitem id="uYONqAooqdABm" type="815" open="0"/>
            <listitem id="uqOJ5kqJMLT2a" type="814" open="0"/>
            <listitem id="uMLBSuDraODUQ" type="814" open="0"/>
            <listitem id="uAZAh1kbg2ooz" type="814" open="0"/>
            <listitem id="uR3WqIpeZQahY" type="814" open="0"/>
            <listitem id="ukOvQNP5ZcbXE" type="815" open="0"/>
            <listitem id="uHZQRhKXVFhjA" type="815" open="0"/>
            <listitem id="u1bGcGq6OGdqe" type="815" open="0"/>
          </listitem>
          <listitem id="u2QhbtcOQZi67" type="813" open="0">
            <listitem id="u513DL1Jz4dxl" type="814" open="0"/>
            <listitem id="uHWMFrnGmngwQ" type="814" open="0"/>
            <listitem id="uheCtkELV9Oju" type="814" open="0"/>
          </listitem>
          <listitem id="ud7SAHRwSRjyq" type="813" open="0">
            <listitem id="udM8FSv9sFB7P" type="815" open="0"/>
            <listitem id="u0sBXYcp09B7b" type="815" open="0"/>
            <listitem id="uA39nZnJwXBmN" type="815" open="0"/>
            <listitem id="u1FoJRu7i3sYc" type="815" open="0"/>
            <listitem id="u1hng5bJJ52Hf" type="815" open="0"/>
            <listitem id="u02YJ2YfGJgh8" type="815" open="0"/>
            <listitem id="u5rfeCAOcPFcl" type="814" open="0"/>
            <listitem id="uiPiG9AezrAQR" type="814" open="0"/>
            <listitem id="ucClL1ICIfWZp" type="814" open="0"/>
            <listitem id="ug0Jf0ylhCXrk" type="815" open="0"/>
            <listitem id="urwN2FpjmuPoG" type="815" open="0"/>
            <listitem id="uv3eNLshQVnxV" type="815" open="0"/>
          </listitem>
          <listitem id="uubxTNT5BvTDN" type="813" open="0">
            <listitem id="ugJJ09BQPtans" type="815" open="0"/>
            <listitem id="uhChgwj4IW3Uy" type="815" open="0"/>
            <listitem id="u3wRzpf1nIV8d" type="815" open="0"/>
            <listitem id="uLTqmAFAv7DMl" type="814" open="0"/>
            <listitem id="uQj7rZmQNjduX" type="814" open="0"/>
            <listitem id="uDu9gHVUIJZpN" type="814" open="0"/>
            <listitem id="uf4YbtcEjhw6q" type="815" open="0"/>
            <listitem id="uyTRmh2SgVQuE" type="815" open="0"/>
            <listitem id="u3nLxayoyFG2P" type="815" open="0"/>
          </listitem>
          <listitem id="usCXsB30PGS1i" type="813" open="0">
            <listitem id="ubdnUW6kwGOdT" type="815" open="0"/>
            <listitem id="uStc8nzJOVvDp" type="815" open="0"/>
            <listitem id="ukGJN7souTuxZ" type="815" open="0"/>
            <listitem id="u1qv2vGcl2XVS" type="815" open="0"/>
            <listitem id="uM1JrRxiUv5uB" type="814" open="0"/>
            <listitem id="uWZnOmCnb4xYF" type="814" open="0"/>
            <listitem id="ugWBsQhMgnClX" type="814" open="0"/>
            <listitem id="usUA2FuPYQlq3" type="814" open="0"/>
            <listitem id="u7nykWQ0LX7IN" type="815" open="0"/>
            <listitem id="um13ZegqCgWBa" type="815" open="0"/>
            <listitem id="u6FtcJNXEOzBp" type="815" open="0"/>
            <listitem id="urCn7a4dfVx6d" type="815" open="0"/>
            <listitem id="uysTJd43sJJ0v" type="815" open="0"/>
          </listitem>
          <listitem id="u0vAaqT0VA4N5" type="813" open="0">
            <listitem id="uvFUIDuL30sXW" type="815" open="0"/>
            <listitem id="ufkOcipyycLXE" type="815" open="0"/>
            <listitem id="uoNiX8Gu9Fur0" type="815" open="0"/>
            <listitem id="u5YQqZM0U29bF" type="815" open="0"/>
            <listitem id="un3RtQyYtXrqE" type="814" open="0"/>
            <listitem id="uG3wd3tgVMQqB" type="814" open="0"/>
            <listitem id="uvNpLZgKPvG6g" type="814" open="0"/>
            <listitem id="uvNTQLW3CpBOo" type="814" open="0"/>
            <listitem id="uRm8ynib9pgm4" type="815" open="0"/>
            <listitem id="uRGmCbCVuT5Kr" type="815" open="0"/>
            <listitem id="uEaXiJNsu1iWF" type="815" open="0"/>
          </listitem>
          <listitem id="uFGbd2Oy1fUBu" type="813" open="0">
            <listitem id="uoSMTjU6dJ90R" type="815" open="0"/>
            <listitem id="uXR9hxbSuFpxD" type="815" open="0"/>
            <listitem id="uQotYnNIeX509" type="815" open="0"/>
            <listitem id="uH8sMNeOlP0YX" type="815" open="0"/>
            <listitem id="uaoLBNZHQEUc4" type="815" open="0"/>
            <listitem id="ug2D6e50zibgw" type="815" open="0"/>
            <listitem id="uaXBLmbKg6qFv" type="815" open="0"/>
            <listitem id="ulIRcBxebyAy6" type="815" open="0"/>
            <listitem id="uWrQCUXIypA4r" type="815" open="0"/>
            <listitem id="u8f7qKXuNy1pt" type="815" open="0"/>
            <listitem id="urbdgC4rd9VGW" type="815" open="0"/>
            <listitem id="uXAkDeyxcdmGT" type="815" open="0"/>
            <listitem id="uqplocyB1swtG" type="815" open="0"/>
            <listitem id="uov8RICqFJ1i2" type="815" open="0"/>
            <listitem id="ucaZpOor1mcWg" type="815" open="0"/>
            <listitem id="uwOLcMkm4YzSG" type="815" open="0"/>
            <listitem id="uNrPBWFuBmF8v" type="815" open="0"/>
            <listitem id="uTccJUCvRZPbn" type="815" open="0"/>
            <listitem id="u40Q8Ct1tm2go" type="815" open="0"/>
            <listitem id="uOyc0ICQLtThk" type="815" open="0"/>
            <listitem id="uxLJiNvvLztL8" type="815" open="0"/>
            <listitem id="uH2QBjPIdrL78" type="815" open="0"/>
            <listitem id="uiZNk4AsY9Aur" type="815" open="0"/>
            <listitem id="u3FBO4zXvlqc2" type="815" open="0"/>
            <listitem id="uSyhsb9gbL8BQ" type="815" open="0"/>
            <listitem id="uCD4HYQv9qcDP" type="814" open="0"/>
            <listitem id="ue3x85l02VCC2" type="814" open="0"/>
            <listitem id="uYCrMATEtf1Yl" type="814" open="0"/>
            <listitem id="uKNYI0r63hLNM" type="814" open="0"/>
            <listitem id="ucexMMQ5xWhcl" type="814" open="0"/>
            <listitem id="uRykE90vhiqxu" type="814" open="0"/>
            <listitem id="u5d1FVjRC1jFA" type="814" open="0"/>
            <listitem id="uITV71bnsNUis" type="814" open="0"/>
            <listitem id="uLjU52FraZD14" type="814" open="0"/>
            <listitem id="u6yOSe91kMx2B" type="814" open="0"/>
            <listitem id="uSjpyrGWyr0vX" type="814" open="0"/>
            <listitem id="uca4YEiqzTT6I" type="814" open="0"/>
            <listitem id="udZEE7khumjMZ" type="814" open="0"/>
            <listitem id="u9CiSgmNHtCGz" type="815" open="0"/>
            <listitem id="u2xtAQ4RLbK6g" type="815" open="0"/>
            <listitem id="ulvZzBEX2Z753" type="815" open="0"/>
            <listitem id="uEQkFyaDtrRNc" type="815" open="0"/>
            <listitem id="u01lwKFr7u72Q" type="815" open="0"/>
            <listitem id="ulPiooPlpiGc8" type="815" open="0"/>
            <listitem id="uAeR38TdONj6r" type="815" open="0"/>
            <listitem id="uceZ2IGFAGYPe" type="815" open="0"/>
          </listitem>
          <listitem id="usRfxirrOBrnP" type="813" open="0">
            <listitem id="uH6T99Q0mRDO8" type="815" open="0"/>
            <listitem id="uZMLS4y3d4Yjg" type="814" open="0"/>
            <listitem id="uDwskKvUrEt06" type="814" open="0"/>
            <listitem id="uWu5IYx7J0dI3" type="814" open="0"/>
            <listitem id="udxmNiZ9gShvw" type="814" open="0"/>
            <listitem id="ufHBfNAS7jrmz" type="814" open="0"/>
            <listitem id="ucMZJE1DJAyCd" type="814" open="0"/>
            <listitem id="uzdvx8FpBIBvY" type="814" open="0"/>
            <listitem id="u0Fkp4nWA3Omi" type="814" open="0"/>
          </listitem>
          <listitem id="uxKtak8jVDcjI" type="813" open="0">
            <listitem id="uMIdGWCoHnYrx" type="815" open="0"/>
            <listitem id="uxOLLVNY0byKh" type="815" open="0"/>
            <listitem id="uZ47PjMQpovOi" type="814" open="0"/>
            <listitem id="uSIVFkA5WOFZo" type="815" open="0"/>
          </listitem>
          <listitem id="u4gyFWDbb9P9V" type="813" open="0">
            <listitem id="uh9nDop24Np8e" type="815" open="0"/>
            <listitem id="uGEfOQtjbITFo" type="815" open="0"/>
            <listitem id="ukCOsz7mdkz8K" type="815" open="0"/>
            <listitem id="uN3f1i1RzHbiW" type="815" open="0"/>
            <listitem id="uCnY1i5AHfq2j" type="815" open="0"/>
            <listitem id="uVQf0zb53V5BO" type="815" open="0"/>
            <listitem id="uoV71sXs6auMz" type="814" open="0"/>
            <listitem id="ube1knJKalrY7" type="814" open="0"/>
            <listitem id="uNdifeXEbF0tS" type="815" open="0"/>
            <listitem id="uUxO7ibqSRz03" type="815" open="0"/>
          </listitem>
          <listitem id="uTmFIyxkngkDO" type="813" open="0">
            <listitem id="u3h1VXuvQChwv" type="815" open="0"/>
            <listitem id="uhQGWtRUuvnJ9" type="815" open="0"/>
            <listitem id="u1yQ8d8dc7LoZ" type="814" open="0"/>
            <listitem id="uX1JKoz1BbbxU" type="814" open="0"/>
            <listitem id="upkxG6oefMR27" type="814" open="0"/>
            <listitem id="uktAjnKkc4RWW" type="814" open="0"/>
            <listitem id="uMx5AZb3TeaKf" type="814" open="0"/>
            <listitem id="u1Aw3ZrrnjZM1" type="815" open="0"/>
          </listitem>
          <listitem id="uJ1fzpHjvhIND" type="813" open="0">
            <listitem id="u9Erjsm2AQdhY" type="815" open="0"/>
            <listitem id="uT7riFYJZmEs0" type="815" open="0"/>
            <listitem id="uqNfmS2WbJa3C" type="815" open="0"/>
            <listitem id="uIrEkFK4lmb2S" type="815" open="0"/>
            <listitem id="uTQSpFMwYwZfy" type="814" open="0"/>
            <listitem id="uX2XoupGaDakf" type="814" open="0"/>
            <listitem id="u1MTZHApG1sBQ" type="814" open="0"/>
            <listitem id="uI0rfdbWL44bw" type="815" open="0"/>
          </listitem>
          <listitem id="Datatypes" type="830" open="0">
            <listitem id="u9CUQj40wke6k" type="829" open="0"/>
            <listitem id="uRs0v9QAfE7td" type="829" open="0"/>
            <listitem id="ugWmBt0uWHYFW" type="829" open="0"/>
            <listitem id="us6kRDi88dqyu" type="829" open="0"/>
            <listitem id="uHWf8zoUhsnrH" type="829" open="0"/>
            <listitem id="uKpC2Xzd9clGk" type="829" open="0"/>
            <listitem id="ugOBJvbb8orVV" type="829" open="0"/>
            <listitem id="u8OC8MX3w96m4" type="829" open="0"/>
            <listitem id="uIEm0LO1PxELG" type="829" open="0"/>
          </listitem>
          <listitem id="uP4IQhFCXv0vB" type="813" open="0"/>
          <listitem id="ujvQZAVED7aLp" type="813" open="0"/>
          <listitem id="u8vOzWIeyGFt7" type="813" open="0"/>
          <listitem id="uAig6rKMvuIvh" type="818" open="0">
            <listitem id="u32ysVgSCbQOo" type="818" open="0">
              <listitem id="uTcCFF3lkmiih" type="813" open="0"/>
            </listitem>
          </listitem>
          <listitem id="u4oDSikeeXlqv" type="818" open="0">
            <listitem id="uvZs0S0d7eyjW" type="813" open="0"/>
          </listitem>
          <listitem id="uMqAUcBFt9APZ" type="813" open="0"/>
          <listitem id="uzHLc9ooc9znC" type="813" open="0"/>
          <listitem id="uArlsc7ZTSQfS" type="813" open="0"/>
          <listitem id="ucfXEnnZd4gT8" type="813" open="0"/>
        </listitem>
        <listitem id="Use_Case_View" type="802" open="1"/>
      </listitem>
    </listview>
    <codegeneration>
      <codegenerator language="Python">
        <sourcecode id="u1HI4MmuNFvbw" value="super().__init__(cycle_residue_name,iExogenousInfo)&#10;self.mNbLags=1&#10;self.mAlpha=None&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;"/>
        <sourcecode id="uWVbF4301LTke" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;CROSTON_ALPHA &quot;+str(self.mAlpha))&#10;&#10;logger.info(&quot;CROSTON_METHOD &quot;+str(self.mOptions.mCrostonOptions.mMethod))&#10;&#10;pass&#10;"/>
        <sourcecode id="uxLBu9CKzXOMc" value="self.mOutName=self.mCycleResidueName+'_CROSTON('+str(self.mOptions.mCrostonOptions.mAlpha)+')'&#10;&#10;self.mFormula=&quot;CROSTON&quot;&#10;"/>
        <sourcecode id="ud0JUHPhXru5R" value="if(croston_type==&quot;SBA&quot;):&#10;  return 1.0-(alpha/2.0)&#10;&#10;elif(croston_type==&quot;SBJ&quot;):&#10;  return(1.0-alpha/(2.0-alpha))&#10;&#10;return 1.0&#10;"/>
        <sourcecode id="uqp04gufZXOrg" value="method=self.mOptions.mCrostonOptions.mMethod&#10;if(self.mOptions.mCrostonOptions.mAlpha is not None):&#10;  self.mAlpha=self.mOptions.mCrostonOptions.mAlpha&#10;  return&#10;&#10;else:&#10;  lPerfs={&#10;}&#10;&#10;  lForecastColumnName='forecast'&#10;  for alpha in np.arange(0.05,1.0,0.05):&#10;    forecast_df=self.compute_forecast(df,alpha,method,1)&#10;    lPerf=tsperf.cPerf()&#10;&#10;    lDict=lPerf.computeCriterionValues(forecast_df[self.mCycleResidueName],&#10;    forecast_df[lForecastColumnName],[self.mOptions.mCrostonOptions.mAlphaCriterion],&quot;CROSTON_SEL_&quot;+'_Fit_'+str(alpha))lPerfs[alpha]=lDict[self.mOptions.mCrostonOptions.mAlphaCriterion]&#10;&#10;  self.mAlpha=min(lPerfs,key=lPerfs.get)&#10;  return&#10;&#10;"/>
        <sourcecode id="urUrrJUW9uY3A" value="alpha=self.mAlpha&#10;method=self.mOptions.mCrostonOptions.mMethod&#10;df=self.compute_forecast(df,alpha,method,horizon_index)&#10;return df&#10;"/>
        <sourcecode id="uJ6SSjUYLrHTk" value="if(np.std(x)&lt;1e-8):&#10;  return x.mean()+np.zeros_like(x)&#10;&#10;from statsmodels.tsa.api import SimpleExpSmoothing&#10;lSES=SimpleExpSmoothing(x).fit(smoothing_level=alpha,optimized=False)&#10;y=lSES.fittedvalues&#10;return y&#10;"/>
        <sourcecode id="uV9C41Q69tDob" value="lCounts_df=df[[self.mTime,self.mCycleResidueName]].copy()&#10;lCounts_df['index']=np.arange(lCounts_df.shape[0])&#10;df1=lCounts_df.reset_index()&#10;counts=lCounts_df[self.mCycleResidueName]-self.mOffset&#10;counts=counts[:-(horizon_index)]&#10;q=counts[abs(counts)&gt;1e-8]&#10;if(q.shape[0]==0):&#10;  df1['forecast']=self.mOffset&#10;  return df1&#10;&#10;assert(q.shape[0]&gt;0)&#10;demand_times=pd.Series(list(q.index),dtype=np.float64)+1&#10;a=demand_times-demand_times.shift(1).fillna(0.0)&#10;df2=pd.DataFrame(:&#10;  'demand_time':list(demand_times),'q':list(q),'a':list(a)&#10;)&#10;df2['q_est']=self.simple_ses(df2['q'].values,alpha)&#10;df2['a_est']=self.simple_ses(df2['a'].values,alpha)&#10;df2['forecast']=self.get_coeff(alpha,method)*df2['q_est']/df2['a_est']&#10;df2['index']=df2['demand_time']-1&#10;for h in range(horizon_index):&#10;  lCounts_df.loc[-(h+1),self.mCycleResidueName]=None&#10;&#10;df3=df1.merge(df2,how='left',on=('index','index'))&#10;df4=df3.fillna(method='ffill')&#10;i=0&#10;while(np.isnan(df4.loc[i,'forecast'])):&#10;  df4.loc[i,'forecast']=0.0&#10;  i=i+1&#10;&#10;df4['forecast']=df4['forecast']+self.mOffset&#10;return df4&#10;"/>
        <sourcecode id="uaWQ5JHyIjirm" value="self.set_name()&#10;&#10;series=self.mCycleResidueName&#10;&#10;self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;lAREstimFrame=self.mSplit.getEstimPart(self.mARFrame)&#10;self.mOffset=lAREstimFrame[self.mCycleResidueName].min()&#10;self.estimate_alpha(lAREstimFrame)&#10;self.mFeatureSelector=None&#10;&#10;self.mInputNamesAfterSelection=self.mInputNames&#10;&#10;lPredicted=self.croston(self.mARFrame)&#10;&#10;self.mARFrame[self.mOutName]=lPredicted['forecast']&#10;self.compute_ar_residue(self.mARFrame)&#10;"/>
        <sourcecode id="u6w994pjxnjuS" value="series=self.mCycleResidueName&#10;&#10;pred=self.croston(df,horizon_index)&#10;df[self.mOutName]=pred['forecast']&#10;&#10;self.compute_ar_residue(df)&#10;return df&#10;"/>
        <sourcecode id="uh4krWdd3Nkpg" value="super().__init__(cycle_residue_name,iExogenousInfo)&#10;self.mNbLags=P&#10;&#10;self.mNbExogenousLags=P&#10;&#10;self.mHiddenUnits=P&#10;&#10;sys.setrecursionlimit(1000000)&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;"/>
        <sourcecode id="uhY13R1uSWLYt" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;MODEL_TYPE PYTORCH&quot;)&#10;lSummary=[module for module in self.mModel.module.modules()][:1]&#10;logger.info(&quot;PYTORCH_MODEL_ARCHITECTURE &quot;+str(lSummary))&#10;"/>
        <sourcecode id="uXmH1oq0Nwg6i" value="assert(0)&#10;&#10;"/>
        <sourcecode id="uJzEVElSTbfEE" value="from sklearn.preprocessing import StandardScaler&#10;self.mStandardScaler_Input=StandardScaler()&#10;self.mStandardScaler_Target=StandardScaler()&#10;lARInputs=self.mStandardScaler_Input.fit_transform(iARInputs)&#10;lARTarget=self.mStandardScaler_Target.fit_transform(iARTarget.reshape(-1,1))&#10;return(lARInputs,lARTarget)&#10;"/>
        <sourcecode id="uh90yaGa1QSl1" value="lDict={&#10;}&#10;&#10;return lDict&#10;"/>
        <sourcecode id="uTsflD07v80j1" value="if(self.mOptions.mKeras_Options is None):&#10;  return self.get_default_keras_options()&#10;&#10;return self.mOptions.mKeras_Options&#10;"/>
        <sourcecode id="uznNO4Rtnn7g1" value="lTimer=tsutil.cTimer((&quot;TRAINING_KERAS_MODEL&quot;,self.mOutName))&#10;lOptions=self.get_keras_options()&#10;import tensorflow as tf&#10;lStopCallback=tf.keras.callbacks.EarlyStopping(monitor='loss',patience=3,verbose=0,mode='auto')&#10;lHistory=self.mModel.fit(iARInputs,iARTarget,&#10;epochs=lOptions.get(&quot;epochs&quot;,20),batch_size=None,verbose=0,callbacks=[])"/>
        <sourcecode id="uMAV6W4NxW7IA" value="lTimer=tsutil.cTimer((&quot;PREDICTING_KERAS_MODEL&quot;,self.mOutName))&#10;lARInputs=self.mStandardScaler_Input.transform(iARInputs)&#10;lARInputs=self.reshape_inputs(lARInputs)&#10;lPredicted=self.mModel.predict(lARInputs)&#10;&#10;lPredicted=np.reshape(lPredicted,(-1,1))&#10;lPredicted=self.mStandardScaler_Target.inverse_transform(lPredicted)&#10;return lPredicted&#10;"/>
        <sourcecode id="uzTKu1HXVlcN6" value="make_pytorch_reproducible(self.mOptions.mSeed)&#10;series=self.mCycleResidueName&#10;&#10;self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;lAREstimFrame=self.mSplit.getEstimPart(self.mARFrame)&#10;lARInputs=lAREstimFrame[self.mInputNames].values&#10;lARTarget=lAREstimFrame[series].values&#10;(lARInputs,lARTarget)=self.fit_inputs_and_targets_scalers(lARInputs,lARTarget)&#10;self.build_RNN_Architecture(lARInputs,lARTarget)&#10;&#10;assert(lARInputs.shape[1]&gt;0)&#10;&#10;assert(lARTarget.shape[0]&gt;0)&#10;&#10;lARInputs=self.reshape_inputs(lARInputs)&#10;self.fit_pytorch_model(lARInputs,lARTarget)&#10;lFullARInputs=self.mARFrame[self.mInputNames].values&#10;&#10;lPredicted=self.predict_pytorch_model(lFullARInputs)&#10;self.mARFrame[self.mOutName]=lPredicted&#10;self.compute_ar_residue(self.mARFrame)&#10;"/>
        <sourcecode id="uZqduv9OGrKpA" value="series=self.mCycleResidueName&#10;&#10;if(self.mExogenousInfo is not None):&#10;  df=self.mExogenousInfo.transformDataset(df)&#10;&#10;&#10;lag_df=self.generateLagsForForecast(df)&#10;&#10;inputs=lag_df[self.mInputNames].values&#10;lPredicted=self.predict_keras_model(inputs)&#10;df[self.mOutName]=lPredicted&#10;&#10;self.compute_ar_residue(df)&#10;return df&#10;&#10;"/>
        <sourcecode id="uzwTl5lh3zyK0" value="super().__init__(cycle_residue_name,iExogenousInfo)&#10;self.mNbLags=P&#10;&#10;self.mNbExogenousLags=P&#10;&#10;sys.setrecursionlimit(1000000)&#10;&#10;self.set_name()&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;"/>
        <sourcecode id="uQBOmFR8x2pVg" value="assert(0)&#10;&#10;"/>
        <sourcecode id="u5EPgRjxi6we7" value="from sklearn.preprocessing import StandardScaler&#10;self.mStandardScaler_Input=StandardScaler()&#10;self.mStandardScaler_Target=StandardScaler()&#10;lARInputs=self.mStandardScaler_Input.fit_transform(iARInputs)&#10;lARTarget=self.mStandardScaler_Target.fit_transform(iARTarget.reshape(iARTarget.shape[0],1))&#10;lARTarget=lARTarget.reshape((lARTarget.shape[0],1))&#10;return(lARInputs,lARTarget)&#10;"/>
        <sourcecode id="uecBc2C7OWi1r" value="lDict={&#10;}&#10;&#10;return lDict&#10;"/>
        <sourcecode id="ulCER3i32p3CY" value="if(self.mOptions.mPytorch_Options is None):&#10;  return self.get_default_pytorch_options()&#10;&#10;return self.mOptions.mPytorch_Options&#10;"/>
        <sourcecode id="u7vzda8iZA1qL" value="lTimer=None&#10;if(self.mOptions.mDebug):&#10;  lTimer=tsutil.cTimer((&quot;TRAINING_PYTORCH_MODEL&quot;,self.mOutName))&#10;&#10;lOptions=self.get_pytorch_options()&#10;lARInputs=iARInputs.astype(np.float32)&#10;lARTarget=iARTarget.astype(np.float32)&#10;lHistory=self.mModel.fit(lARInputs,lARTarget)&#10;"/>
        <sourcecode id="uyoL8avbeCjIh" value="lTimer=None&#10;if(self.mOptions.mDebug):&#10;  lTimer=tsutil.cTimer((&quot;PREDICTING_PYTORCH_MODEL&quot;,self.mOutName))&#10;&#10;lARInputs=self.mStandardScaler_Input.transform(iARInputs)&#10;lARInputs=self.reshape_inputs(lARInputs)&#10;lARInputs=lARInputs.astype(np.float32)&#10;lPredicted=self.mModel.predict(lARInputs)&#10;&#10;lPredicted=np.reshape(lPredicted,(-1,1))&#10;lPredicted=self.mStandardScaler_Target.inverse_transform(lPredicted)&#10;return lPredicted&#10;"/>
        <sourcecode id="uyIJJyOTuKkm6" value="series=self.mCycleResidueName&#10;&#10;if(self.mExogenousInfo is not None):&#10;  df=self.mExogenousInfo.transformDataset(df)&#10;&#10;&#10;lag_df=self.generateLagsForForecast(df)&#10;&#10;inputs=lag_df[self.mInputNames].values&#10;lPredicted=self.predict_pytorch_model(inputs)&#10;df[self.mOutName]=lPredicted&#10;&#10;self.compute_ar_residue(df)&#10;return df&#10;&#10;"/>
        <sourcecode id="uP1DLxZ3qxyho" value="super().__init__(cycle_residue_name,P,iExogenousInfo)&#10;"/>
        <sourcecode id="uJNfWelEHWHqb" value="return iInputs&#10;&#10;"/>
        <sourcecode id="u7gleJhpimUaG" value="lName=&quot;MLP&quot;if(self.mExogenousInfo is None)else&quot;MLPX&quot;&#10;self.mFormula=lName+&quot;(&quot;+str(self.mNbLags)+&quot;)&quot;&#10;&#10;self.mOutName=self.mCycleResidueName+'_'+lName+'('+str(self.mNbLags)+&quot;)&quot;&#10;&#10;self.mModel=self.build_RNN_Architecture_template(iARInputs,iARTarget)&#10;&#10;"/>
        <sourcecode id="uX1VVpwtcsnEt" value="lOptions=self.get_keras_options()&#10;import tensorflow as tf&#10;lNbLags=iARInputs.shape[1]&#10;lModel=tf.keras.Sequential(name=&quot;PyAF_&quot;+self.__class__.__name__)&#10;lModel.add(tf.keras.layers.Dense(self.mHiddenUnits,input_shape=(lNbLags,)))&#10;lModel.add(tf.keras.layers.Dropout(0.1))&#10;lModel.add(tf.keras.layers.Dense(1))&#10;optim=tf.keras.optimizers.Adam(learning_rate=0.1)&#10;lModel.compile(loss=lOptions.get(&quot;criterion&quot;,&quot;mse&quot;),optimizer=optim)&#10;return lModel&#10;&#10;"/>
        <sourcecode id="uKAnPZuI3K8d2" value="super().__init__(cycle_residue_name,P,iExogenousInfo)&#10;self.mHiddenUnits=P&#10;&#10;"/>
        <sourcecode id="uJcvFSfku8QiF" value="return iInputs&#10;&#10;"/>
        <sourcecode id="unlTnMN7wWERQ" value="from torch import nn&#10;model=nn.Sequential(&#10;nn.Linear(iNbInputs,iHidden),nn.Dropout(),nn.Linear(iHidden,1))return model.float()&#10;"/>
        <sourcecode id="uEUwI9qmexzrX" value="from torch import nn&#10;lNbLags=iARInputs.shape[1]&#10;lOptions=self.get_pytorch_options()&#10;from skorch import NeuralNetRegressor&#10;from skorch.callbacks import EarlyStopping&#10;self.mModel=NeuralNetRegressor(self.create_model(lNbLags,self.mHiddenUnits),&#10;criterion=lOptions.get(&quot;criterion&quot;,nn.MSELoss),max_epochs=lOptions.get(&quot;epochs&quot;,20),callbacks=[EarlyStopping(patience=3)],device='cpu',verbose=0)"/>
        <sourcecode id="uQDG2XBIORq4n" value="lName=&quot;MLP&quot;if(self.mExogenousInfo is None)else&quot;MLPX&quot;&#10;self.mFormula=lName+&quot;(&quot;+str(self.mNbLags)+&quot;)&quot;&#10;&#10;self.mOutName=self.mCycleResidueName+'_'+lName+'('+str(self.mNbLags)+&quot;)&quot;&#10;&#10;"/>
        <sourcecode id="uP2Prb8Qpuoii" value="super().__init__(cycle_residue_name,P,iExogenousInfo)&#10;"/>
        <sourcecode id="u1PFBzSVOJNFO" value="lNewShape=(iInputs.shape[0],1,iInputs.shape[1])&#10;lInputs=np.reshape(iInputs,lNewShape)&#10;return lInputs&#10;&#10;"/>
        <sourcecode id="u3ZV4V26BVG2i" value="lName=&quot;LSTM&quot;if(self.mExogenousInfo is None)else&quot;LSTMX&quot;&#10;self.mFormula=lName+&quot;(&quot;+str(self.mNbLags)+&quot;)&quot;&#10;&#10;self.mOutName=self.mCycleResidueName+'_'+lName+'('+str(self.mNbLags)+&quot;)&quot;&#10;&#10;self.mModel=self.build_RNN_Architecture_template(iARInputs,iARTarget)&#10;&#10;"/>
        <sourcecode id="uttdZL9Emsb2O" value="lOptions=self.get_keras_options()&#10;lNbLags=iARInputs.shape[1]&#10;import tensorflow as tf&#10;lModel=tf.keras.Sequential(name=&quot;PyAF_&quot;+self.__class__.__name__)&#10;lModel.add(tf.keras.layers.LSTM(self.mHiddenUnits,input_shape=(1,lNbLags)))&#10;lModel.add(tf.keras.layers.Dropout(0.1))&#10;lModel.add(tf.keras.layers.Dense(1))&#10;optim=tf.keras.optimizers.Adam(learning_rate=0.1)&#10;lModel.compile(loss=lOptions.get(&quot;criterion&quot;,&quot;mse&quot;),optimizer=optim)&#10;return lModel&#10;"/>
        <sourcecode id="uL41yTHBNnpw4" value="super().__init__(cycle_residue_name,P,iExogenousInfo)&#10;self.mHiddenUnits=P&#10;&#10;"/>
        <sourcecode id="uyN7ccbp3xxar" value="return iInputs.reshape(iInputs.shape[0],iInputs.shape[1])&#10;&#10;"/>
        <sourcecode id="usQQlSgjCfm1k" value="from torch import nn&#10;lLSTM=nn.LSTM(iNbInputs,iHidden)&#10;lLSTMWithOneOutput=cLSTMWithOneOutput(lLSTM)&#10;model=nn.Sequential(&#10;lLSTMWithOneOutput,nn.Dropout(p=0.1),nn.Linear(iHidden,1))return model.float()&#10;"/>
        <sourcecode id="ugZjkESWTgzSF" value="lTimer=None&#10;if(self.mOptions.mDebug):&#10;  lTimer=tsutil.cTimer((&quot;TRAINING_PYTORCH_MODEL&quot;,self.mOutName))&#10;&#10;lOptions=self.get_pytorch_options()&#10;lARInputs=iARInputs.astype(np.float32)&#10;lARTarget=iARTarget.astype(np.float32)&#10;lMaxSize=1024&#10;lHistory=self.mModel.fit(lARInputs[-lMaxSize:,:],lARTarget[-lMaxSize:])&#10;"/>
        <sourcecode id="uglk3NQcPyy8y" value="from torch import nn&#10;lNbLags=iARInputs.shape[1]&#10;lOptions=self.get_pytorch_options()&#10;from skorch import NeuralNetRegressor&#10;from skorch.callbacks import EarlyStopping&#10;self.mModel=NeuralNetRegressor(self.create_model(lNbLags,self.mHiddenUnits),&#10;criterion=lOptions.get(&quot;criterion&quot;,nn.MSELoss),max_epochs=lOptions.get(&quot;epochs&quot;,10),callbacks=[EarlyStopping(patience=3)],device='cpu',verbose=0)"/>
        <sourcecode id="u8syzK28vEpl2" value="lName=&quot;LSTM&quot;if(self.mExogenousInfo is None)else&quot;LSTMX&quot;&#10;self.mFormula=lName+&quot;(&quot;+str(self.mNbLags)+&quot;)&quot;&#10;&#10;self.mOutName=self.mCycleResidueName+'_'+lName+'('+str(self.mNbLags)+&quot;)&quot;&#10;"/>
        <sourcecode id="urvKSTuYp1dtL" value="super().__init__()&#10;self.mLSTM=iLSTM&#10;"/>
        <sourcecode id="uvf2HRI8UQxFx" value="return self.mLSTM(X)[0]&#10;"/>
        <sourcecode id="utkUsDXaS9o6L" value="self.mOriginalSignal=None&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;self.mScaling=None&#10;&#10;self.mDebug=False&#10;&#10;pass&#10;"/>
        <sourcecode id="uitpQqkCTivjD" value="return True&#10;&#10;"/>
        <sourcecode id="uWhl5X60MPXZF" value="type2=sig.dtype&#10;if(type2.kind=='O'):&#10;  raise tsutil.PyAF_Error('Invalid Signal Column Type '+sig.dtype)&#10;&#10;&#10;"/>
        <sourcecode id="uqQSVEGV81vAH" value="if(self.mScaling is not None):&#10;  self.mMinInputValue=np.min(sig)&#10;&#10;  self.mMaxInputValue=np.max(sig)&#10;&#10;  self.mInputValueRange=self.mMaxInputValue-self.mMinInputValue&#10;&#10;&#10;else:&#10;  pass&#10;&#10;"/>
        <sourcecode id="utSg7W6HyGaZF" value="return(x-self.mMinInputValue)/self.mInputValueRange&#10;&#10;"/>
        <sourcecode id="uyMa6lYPg36gr" value="if(self.mScaling is not None):&#10;  sig1=None&#10;  if(np.fabs(self.mInputValueRange)&lt;1e-10):&#10;    sig1=sig*0.0&#10;&#10;  else:&#10;    sig1=self.scale_value(sig)&#10;&#10;  return sig1&#10;&#10;&#10;else:&#10;  return sig&#10;&#10;&#10;"/>
        <sourcecode id="urbzh4KxtWiOn" value="y=self.mMinInputValue+x*self.mInputValueRange&#10;&#10;return y&#10;"/>
        <sourcecode id="uq0bT0muWCfu7" value="if(self.mScaling is not None):&#10;  sig=self.rescale_value(sig1)&#10;&#10;  return sig&#10;&#10;&#10;else:&#10;  return sig1&#10;&#10;&#10;"/>
        <sourcecode id="uLDJxNQ7EDXc3" value="self.checkSignalType(sig)&#10;self.fit_scaling_params(sig.values)&#10;&#10;sig1=self.scale_signal(sig.values)&#10;&#10;self.specific_fit(sig1)&#10;&#10;pass&#10;"/>
        <sourcecode id="upuSbTVBmcj6M" value="self.checkSignalType(sig)&#10;sig1=self.scale_signal(sig.values)&#10;&#10;sig2=self.specific_apply(sig1)&#10;&#10;if(self.mDebug):&#10;  self.check_not_nan(sig2,&quot;transform_apply&quot;)&#10;&#10;&#10;return sig2&#10;&#10;"/>
        <sourcecode id="uFytguC6ERyk6" value="sig2=self.specific_invert(sig1.values)&#10;&#10;rescaled_sig=self.rescale_signal(sig2)&#10;&#10;return rescaled_sig&#10;&#10;"/>
        <sourcecode id="uiMS1DDfRS23c" value="df[&quot;scaled_&quot;+self.mOriginalSignal]=self.scale_signal(df[self.mOriginalSignal])&#10;df[self.get_name(self.mOriginalSignal)]=self.apply(df[self.mOriginalSignal])&#10;return df&#10;&#10;"/>
        <sourcecode id="udmWCyVJARXae" value="import copy&#10;&#10;tr1=copy.deepcopy(self)&#10;&#10;testTransform(tr1)&#10;&#10;pass&#10;"/>
        <sourcecode id="uuBxt2evxRvPJ" value="sig=pd.Series(index=None)&#10;&#10;sig['before_apply']=sig_before_apply&#10;&#10;sig['after_apply']=sig_after_apply&#10;&#10;print(&quot;dump_apply_invert_head&quot;,sig.head())&#10;&#10;print(&quot;dump_apply_invert_tail&quot;,sig.tail())&#10;&#10;"/>
        <sourcecode id="usQfdklOgbaoE" value="if(np.isnan(sig).any()):&#10;  print(&quot;TRANSFORMATION_RESULT_WITH_NAN_IN_SIGNAL&quot;,sig)&#10;&#10;  raise tsutil.Internal_PyAF_Error(&quot;Invalid transformation for column '&quot;+name+&quot;'&quot;)&#10;&#10;&#10;pass&#10;"/>
        <sourcecode id="ugJJ09BQPtans" value="cAbstractSignalTransform.__init__(self)&#10;&#10;self.mFormula=&quot;NoTransf&quot;&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Low&#10;&#10;self.mScaling=True&#10;&#10;pass&#10;"/>
        <sourcecode id="u3wRzpf1nIV8d" value="return&quot;_&quot;+str(iSig)&#10;&#10;"/>
        <sourcecode id="uyTRmh2SgVQuE" value="pass&#10;"/>
        <sourcecode id="uf4YbtcEjhw6q" value="return sig&#10;&#10;"/>
        <sourcecode id="u3nLxayoyFG2P" value="return sig&#10;&#10;"/>
        <sourcecode id="uhChgwj4IW3Uy" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;SIGNAL_TRANSFORMATION_MODEL_VALUES &quot;+self.mFormula+&quot; &quot;+str(None))&#10;&#10;"/>
        <sourcecode id="ulhSzaDib6ls0" value="cAbstractSignalTransform.__init__(self)&#10;&#10;self.mFormula=&quot;Integration&quot;&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Medium&#10;&#10;self.mScaling=True&#10;&#10;pass&#10;"/>
        <sourcecode id="ucZY8QHnJZd2A" value="return&quot;CumSum_&quot;+str(iSig)&#10;&#10;"/>
        <sourcecode id="u7GQeLpZ2q8nw" value="pass&#10;"/>
        <sourcecode id="uSnPt1dPPJsxF" value="return sig.cumsum(axis=0)&#10;"/>
        <sourcecode id="uvYeiTTO7J6Sh" value="sig_diff=np.diff(sig)&#10;sig_orig=np.append([sig[0]],sig_diff)&#10;&#10;return sig_orig&#10;&#10;"/>
        <sourcecode id="uKzg4nawVIgMi" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;SIGNAL_TRANSFORMATION_MODEL_VALUES &quot;+self.mFormula+&quot; &quot;+str(None))&#10;&#10;"/>
        <sourcecode id="ubdnUW6kwGOdT" value="cAbstractSignalTransform.__init__(self)&#10;&#10;self.mQuantiles=iQuantiles&#10;&#10;self.mFormula=&quot;Quantization&quot;&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;self.mScaling=True&#10;&#10;pass&#10;"/>
        <sourcecode id="ukGJN7souTuxZ" value="return&quot;Quantized_&quot;+str(self.mQuantiles)+&quot;_&quot;+str(iSig)&#10;&#10;"/>
        <sourcecode id="u1qv2vGcl2XVS" value="N=sig.shape[0]&#10;&#10;if(N&lt;(5*self.mQuantiles)):&#10;  return False&#10;&#10;&#10;return True&#10;&#10;"/>
        <sourcecode id="urCn7a4dfVx6d" value="Q=self.mQuantiles&#10;&#10;q=pd.Series(range(0,Q)).apply(lambda x:np.quantile(sig,x/Q))&#10;self.mCurve=q.to_dict()&#10;(self.mMin,self.mMax)=(min(self.mCurve.keys()),max(self.mCurve.keys()))&#10;pass&#10;"/>
        <sourcecode id="um13ZegqCgWBa" value="curve=self.mCurve&#10;&#10;return min(curve.keys(),key=lambda y:abs(float(curve[y])-x))&#10;"/>
        <sourcecode id="u6FtcJNXEOzBp" value="lSignal_Q=np.array([self.signal2quant(x)for x in sig])&#10;&#10;return lSignal_Q&#10;&#10;"/>
        <sourcecode id="u7nykWQ0LX7IN" value="curve=self.mCurve&#10;&#10;key=int(x)&#10;&#10;if(key&gt;=self.mMax):&#10;  key=self.mMax&#10;&#10;&#10;if(key&lt;=self.mMin):&#10;  key=self.mMin&#10;&#10;&#10;val=curve[key]&#10;return val&#10;&#10;"/>
        <sourcecode id="uysTJd43sJJ0v" value="lSignal=np.array([self.quant2signal(x)for x in sig])&#10;return lSignal&#10;&#10;"/>
        <sourcecode id="uStc8nzJOVvDp" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;QUANTIZE_TRANSFORMATION_MIN_MAX_CURVE &quot;+self.mFormula+&quot; &quot;+str((self.mMin,self.mMax))+&quot; &quot;+str(self.mCurve))&#10;&#10;"/>
        <sourcecode id="ujn10CropSiJK" value="cAbstractSignalTransform.__init__(self)&#10;&#10;self.mFormula=&quot;BoxCox&quot;&#10;&#10;self.mLambda=iLambda&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;self.mScaling=True&#10;&#10;pass&#10;"/>
        <sourcecode id="uOldQDUkPnA75" value="return&quot;Box_Cox_&quot;+str(self.mLambda)+&quot;_&quot;+str(iSig)&#10;&#10;"/>
        <sourcecode id="u7eZxe39VTHZL" value="self.mFormula=&quot;BoxCox(Lambda=&quot;+str(self.mLambda)+&quot;)&quot;&#10;&#10;pass&#10;"/>
        <sourcecode id="uHvjwYDI5ZnVW" value="lEps=1e-3&#10;assert(sig.min()&gt;-lEps)&#10;log_sig=np.log(sig.clip(lEps,None))&#10;if(abs(self.mLambda)&lt;=0.001):&#10;  return log_sig&#10;&#10;&#10;lLimit=5.0/abs(self.mLambda)&#10;log_sig=log_sig.clip(-lLimit,lLimit)&#10;sig1=(np.exp(log_sig*self.mLambda)-1)/self.mLambda&#10;return sig1&#10;&#10;"/>
        <sourcecode id="uIr5g7spjgizz" value="x=y&#10;&#10;lEps=1e-5&#10;x0=self.mLambda*x+1&#10;x1=np.log(x0.clip(lEps,None))/self.mLambda&#10;&#10;return np.exp(x1).clip(0,1)&#10;&#10;"/>
        <sourcecode id="uXwMy2nQtDCO4" value="if(abs(self.mLambda)&lt;=0.001):&#10;  sig1=sig.clip(-1.e2,1.e2)&#10;  sig_orig=np.exp(sig1).clip(0,1)&#10;&#10;  return sig_orig&#10;&#10;&#10;sig_pos=self.invert_value(sig)&#10;return sig_pos&#10;&#10;"/>
        <sourcecode id="u94PimE8VWnfV" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;BOX_COX_TRANSFORMATION_LAMBDA &quot;+self.mFormula+&quot; &quot;+str(self.mLambda))&#10;&#10;"/>
        <sourcecode id="uaSjXNSDJfLQ4" value="cAbstractSignalTransform.__init__(self)&#10;&#10;self.mFirstValue=None&#10;&#10;self.mFormula=&quot;Difference&quot;&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Medium&#10;&#10;self.mScaling=True&#10;&#10;pass&#10;"/>
        <sourcecode id="uYONqAooqdABm" value="return&quot;Diff_&quot;+str(iSig)&#10;&#10;"/>
        <sourcecode id="uHZQRhKXVFhjA" value="self.mFirstValue=sig[0]&#10;&#10;pass&#10;"/>
        <sourcecode id="ukOvQNP5ZcbXE" value="sig_diff=np.diff(sig)&#10;lResult=np.append([sig[0]-self.mFirstValue],sig_diff)&#10;&#10;return lResult&#10;"/>
        <sourcecode id="u1bGcGq6OGdqe" value="sig_cumsum=sig.cumsum()&#10;&#10;sig_orig=sig_cumsum+self.mFirstValue&#10;&#10;return sig_orig&#10;&#10;"/>
        <sourcecode id="ukfSxXofaCHS7" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;DIFFERENCING_TRANSFORMATION &quot;+self.mFormula+&quot; &quot;+str(self.mFirstValue))&#10;&#10;"/>
        <sourcecode id="uvFUIDuL30sXW" value="cAbstractSignalTransform.__init__(self)&#10;&#10;self.mFirstValue=None&#10;&#10;self.mFormula=&quot;RelativeDifference&quot;&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Medium&#10;&#10;self.mScaling=True&#10;&#10;pass&#10;"/>
        <sourcecode id="u5YQqZM0U29bF" value="return&quot;RelDiff_&quot;+str(iSig)&#10;&#10;"/>
        <sourcecode id="uRGmCbCVuT5Kr" value="self.mFirstValue=sig[0]&#10;&#10;pass&#10;"/>
        <sourcecode id="uRm8ynib9pgm4" value="lEps=1e-2&#10;sig_diff=np.append([sig[0]-self.mFirstValue],np.diff(sig))&#10;&#10;sig_shifted=np.append([self.mFirstValue],sig[:-1])&#10;rate=np.divide(sig_diff,sig_shifted,out=np.zeros_like(sig_diff),where=sig_shifted!=0)&#10;rate[0]=0.0&#10;&#10;rate=rate.clip(-1.0e+2,+1.0e+2)&#10;return rate&#10;&#10;"/>
        <sourcecode id="ufkOcipyycLXE" value="lLogRate=np.log(rate)&#10;lCumSum=lLogRate.cumsum()&#10;lCumSum=lCumSum.clip(-10,+10)&#10;lResult=np.exp(lCumSum)&#10;return lResult&#10;"/>
        <sourcecode id="uEaXiJNsu1iWF" value="rate=sig+1&#10;&#10;lEps=1e-5&#10;rate=rate.clip(lEps,+10)&#10;rate_cum=self.cumprod_no_overflow(rate)&#10;&#10;sig_orig=self.mFirstValue*rate_cum&#10;&#10;return sig_orig&#10;&#10;"/>
        <sourcecode id="uoNiX8Gu9Fur0" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;REALTIVE_DIFFERENCING_TRANSFORMATION &quot;+self.mFormula+&quot; &quot;+str(self.mFirstValue))&#10;&#10;"/>
        <sourcecode id="udM8FSv9sFB7P" value="cAbstractSignalTransform.__init__(self)&#10;&#10;self.mFormula=&quot;Logit&quot;&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Medium&#10;&#10;self.mScaling=True&#10;&#10;pass&#10;"/>
        <sourcecode id="uA39nZnJwXBmN" value="return&quot;Logit_&quot;+str(iSig)&#10;&#10;"/>
        <sourcecode id="u1hng5bJJ52Hf" value="return True&#10;&#10;"/>
        <sourcecode id="urwN2FpjmuPoG" value="pass&#10;"/>
        <sourcecode id="u02YJ2YfGJgh8" value="eps=1.0e-2&#10;&#10;x1=np.clip(x,eps,1-eps)&#10;y=np.log(x1)-np.log(1-x1)&#10;&#10;return y&#10;&#10;"/>
        <sourcecode id="u1FoJRu7i3sYc" value="y1=np.clip(y,-5,5)&#10;x=np.exp(y1)&#10;&#10;p=x/(1+x)&#10;&#10;return p&#10;&#10;"/>
        <sourcecode id="ug0Jf0ylhCXrk" value="sig1=self.logit(sig)&#10;return sig1&#10;&#10;"/>
        <sourcecode id="uv3eNLshQVnxV" value="sig1=self.inv_logit(sig)&#10;return sig1&#10;&#10;"/>
        <sourcecode id="u0sBXYcp09B7b" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;LOGIT_TRANSFORMATION &quot;+self.mFormula)&#10;&#10;"/>
        <sourcecode id="uMIdGWCoHnYrx" value="self.mSignalFrame=None&#10;self.mTransformList={&#10;}&#10;&#10;"/>
        <sourcecode id="uSIVFkA5WOFZo" value="lName=transf.get_name(&quot;&quot;)&#10;&#10;lIsApplicable=transf.is_applicable(df[iSignal])&#10;&#10;if(lIsApplicable):&#10;  self.mTransformList=self.mTransformList+[transf]&#10;&#10;&#10;"/>
        <sourcecode id="uxOLLVNY0byKh" value="self.mTransformList=[]&#10;&#10;if(self.mOptions.mActiveTransformations['None']):&#10;  self.validateTransformation(cSignalTransform_None(),df,iTime,iSignal)&#10;&#10;&#10;if(self.mOptions.mActiveTransformations['Difference']):&#10;  self.validateTransformation(cSignalTransform_Differencing(),df,iTime,iSignal)&#10;&#10;&#10;if(self.mOptions.mActiveTransformations['RelativeDifference']):&#10;  self.validateTransformation(cSignalTransform_RelativeDifferencing(),df,iTime,iSignal)&#10;&#10;&#10;if(self.mOptions.mActiveTransformations['Integration']):&#10;  self.validateTransformation(cSignalTransform_Accumulate(),df,iTime,iSignal)&#10;&#10;&#10;if(self.mOptions.mActiveTransformations['BoxCox']):&#10;  for i in self.mOptions.mBoxCoxOrders:&#10;    self.validateTransformation(cSignalTransform_BoxCox(i),df,iTime,iSignal)&#10;&#10;&#10;&#10;if(self.mOptions.mActiveTransformations['Quantization']):&#10;  for q in self.mOptions.mQuantiles:&#10;    self.validateTransformation(cSignalTransform_Quantize(q),df,iTime,iSignal)&#10;&#10;&#10;&#10;if(self.mOptions.mActiveTransformations['Logit']):&#10;  self.validateTransformation(cSignalTransform_Logit(),df,iTime,iSignal)&#10;&#10;&#10;if(self.mOptions.mActiveTransformations['Fisher']):&#10;  self.validateTransformation(cSignalTransform_Fisher(),df,iTime,iSignal)&#10;&#10;&#10;if(self.mOptions.mActiveTransformations['Anscombe']):&#10;  self.validateTransformation(cSignalTransform_Anscombe(),df,iTime,iSignal)&#10;"/>
        <sourcecode id="uCdbvcJBAVvZF" value="self.mSigDecBySplitAndTransform={&#10;}&#10;&#10;&#10;self.mOptions=tsopts.cSignalDecomposition_Options()&#10;&#10;self.mExogenousData=None&#10;&#10;pass&#10;"/>
        <sourcecode id="uuACekITyA07J" value="raise tsutil.PyAF_Error(&quot;PYAF_ERROR_NON_INTEGER_HORIZON &quot;+str(iHorizon))&#10;&#10;"/>
        <sourcecode id="ubEZx9UOVqGoe" value="self.mTimeInfo=tsti.cTimeInfo()&#10;self.mCycleFrame=None&#10;self.mARFrame=None&#10;self.mCycleResidueName=cycle_residue_name&#10;self.mCycle=None&#10;self.mTrend=None&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;self.mFormula=None&#10;&#10;self.mTargetName=self.mCycleResidueName&#10;&#10;self.mInputNames=[]&#10;&#10;self.mExogenousInfo=iExogenousInfo&#10;&#10;self.mLagsForSeries={&#10;cycle_residue_name:[]}&#10;&#10;"/>
        <sourcecode id="uzVcOYgt6gESQ" value="target=df[self.mCycleResidueName].values&#10;lSignal=df[self.mSignal].values&#10;lTrend=df[self.mTrend.mOutName].values&#10;lCycle=df[self.mCycle.mOutName].values&#10;lAR=df[self.mOutName].values&#10;if(self.mDecompositionType in['T+S+R']):&#10;  df[self.mOutName+'_residue']=lSignal-lTrend-lCycle-lAR&#10;&#10;if(self.mDecompositionType in['TS+R']):&#10;  df[self.mOutName+'_residue']=lSignal-lTrend*lCycle-lAR&#10;&#10;else:&#10;  df[self.mOutName+'_residue']=lSignal-(lTrend*lCycle*lAR)&#10;&#10;"/>
        <sourcecode id="uzUL5inTKXjoh" value="tsplot.decomp_plot(self.mARFrame,self.mTimeInfo.mNormalizedTimeColumn,&#10;self.mCycleResidueName,self.mOutName,self.mOutName+'_residue',horizon=self.mTimeInfo.mHorizon)&#10;"/>
        <sourcecode id="uC2pG7oXaXH6Y" value="name=series+'_Lag'+str(p)&#10;&#10;assert(name not in self.mInputNames)&#10;self.mInputNames.append(name)&#10;&#10;self.mLagsForSeries[series]=self.mLagsForSeries.get(series,[])&#10;self.mLagsForSeries[series].append(p)&#10;"/>
        <sourcecode id="umeq1fUhFugGM" value="pass&#10;"/>
        <sourcecode id="uTz03XZqrNOMC" value="self.mARFitPerf=tsperf.cPerf()&#10;&#10;self.mARForecastPerf=tsperf.cPerf()&#10;&#10;(lFrameFit,lFrameForecast,lFrameTest)=self.mSplit.cutFrame(self.mARFrame)&#10;&#10;self.mARFitPerf.computeCriterionValues(&#10;lFrameFit[self.mCycleResidueName],lFrameFit[self.mOutName],[self.mTimeInfo.mOptions.mModelSelection_Criterion],self.mOutName)self.mARForecastPerf.computeCriterionValues(&#10;lFrameForecast[self.mCycleResidueName],lFrameForecast[self.mOutName],[self.mTimeInfo.mOptions.mModelSelection_Criterion],self.mOutName)"/>
        <sourcecode id="uoJV1ghZWOJLD" value="N=series.shape[0]&#10;&#10;new_values=np.append([idefault]*p,series[0:N-p])&#10;return new_values&#10;"/>
        <sourcecode id="ugndGcN5jGJNO" value="return self.mDefaultValues[series]&#10;&#10;"/>
        <sourcecode id="uV6nQYUanEDhg" value="lDict={&#10;}&#10;&#10;series=self.mCycleResidueName&#10;lSeries=df[self.mCycleResidueName]&#10;lSeries=lSeries.values.clip(-1e+10,+1e10)&#10;for p in self.mLagsForSeries[self.mCycleResidueName]:&#10;  name=series+'_Lag'+str(p)&#10;&#10;  lShiftedSeries=self.shift_series(lSeries,p,self.mDefaultValues[series])&#10;&#10;  lDict[name]=lShiftedSeries&#10;&#10;if(self.mExogenousInfo is not None):&#10;  for ex in self.mExogenousInfo.mEncodedExogenous:&#10;    if(self.mLagsForSeries.get(ex)):&#10;      for p in self.mLagsForSeries[ex]:&#10;        name=ex+'_Lag'+str(p)&#10;&#10;        lShiftedSeries=self.shift_series(df[ex],p,self.mDefaultValues[ex])&#10;&#10;        lDict[name]=lShiftedSeries&#10;&#10;&#10;&#10;&#10;cols=lDict.keys()&#10;lArray=np.concatenate([lDict[k].reshape(-1,1)for k in lDict.keys()],axis=1,dtype=lSeries.dtype)&#10;lag_df=pd.DataFrame(data=lArray,columns=cols,index=df.index,dtype=lSeries.dtype)&#10;return lag_df&#10;&#10;"/>
        <sourcecode id="u3h1VXuvQChwv" value="super().__init__(cycle_residue_name,None)&#10;self.mOutName=self.mCycleResidueName+'_NoAR'&#10;self.mNbLags=0&#10;&#10;self.mFormula=&quot;NoAR&quot;&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Low&#10;&#10;self.mConstantValue=0.0&#10;"/>
        <sourcecode id="uhQGWtRUuvnJ9" value="series=self.mCycleResidueName&#10;&#10;self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;self.mConstantValue=0.0&#10;if(self.mDecompositionType in['TSR']):&#10;  self.mConstantValue=1.0&#10;&#10;self.mARFrame[self.mOutName]=self.mConstantValue&#10;&#10;self.mARFrame[self.mCycle.mOutName]=self.mConstantValue&#10;&#10;self.mARFrame[self.mTrend.mOutName]=self.mConstantValue&#10;&#10;self.compute_ar_residue(self.mARFrame)&#10;assert(self.mARFrame.shape[0]&gt;0)&#10;"/>
        <sourcecode id="u1Aw3ZrrnjZM1" value="df[self.mOutName]=self.mConstantValue&#10;&#10;self.compute_ar_residue(df)&#10;assert(df.shape[0]&gt;0)&#10;return df&#10;&#10;"/>
        <sourcecode id="uNxqFdwhwwil2" value="self.mTimeInfo=tsti.cTimeInfo()&#10;self.mCycleFrame=None&#10;self.mARFrame=None&#10;self.mARList={&#10;}&#10;&#10;self.mExogenousInfo=None&#10;&#10;"/>
        <sourcecode id="uxE6mo1sJlEQ2" value="for trend in self.mTrendList:&#10;  for cycle in self.mCycleList[trend]:&#10;    cycle_residue=cycle.getCycleResidueName()&#10;&#10;    for autoreg in self.mARList[cycle_residue]:&#10;      autoreg.plot()&#10;&#10;&#10;&#10;&#10;"/>
        <sourcecode id="uo6MASQSPhs7c" value="lFirst=iSeries[0]&#10;&#10;for lValue in iSeries[1:]:&#10;  if(lValue!=lFirst):&#10;    return True&#10;&#10;&#10;&#10;return False&#10;&#10;"/>
        <sourcecode id="u6JehlY8psVHS" value="N=series.shape[0]&#10;&#10;new_values=np.append([series[0]]*p,series[0:N-p])&#10;return new_values&#10;"/>
        <sourcecode id="uCO4j0qSzBB6u" value="(pmin,pmax)=pMinMax&#10;lSeries=df[series]&#10;&#10;self.mDefaultValues[series]=lSeries.values[0]&#10;&#10;lDict={&#10;}&#10;&#10;lags=[]&#10;for p in range(pmin,pmax+1):&#10;  name=series+'_Lag'+str(p)&#10;  lShiftedSeries=self.shift_series(lSeries.values,p)&#10;  lShiftedEstim=self.mSplit.getEstimPart(lShiftedSeries)&#10;&#10;  lAcceptable=self.is_not_constant(lShiftedEstim)&#10;&#10;  if(lAcceptable):&#10;    lDict[name]=lShiftedSeries&#10;    lags.append((series,p))&#10;&#10;&#10;lag_df=pd.DataFrame(lDict,index=df.index,dtype=lSeries.dtype)&#10;return(lag_df,lags)&#10;"/>
        <sourcecode id="ufcZBm04NbPFK" value="P=self.get_nb_lags()&#10;&#10;lMaxFeatures=self.mOptions.mMaxFeatureForAutoreg&#10;&#10;lExogCount=len(self.mExogenousInfo.mEncodedExogenous)&#10;&#10;lNbVars=P*lExogCount&#10;&#10;if(lNbVars&lt;=lMaxFeatures):&#10;  return self.mExogenousInfo.mEncodedExogenous&#10;&#10;from sklearn.feature_selection import SelectKBest&#10;from sklearn.feature_selection import f_regression&#10;lPreselectionFeatureSelector=SelectKBest(f_regression,k=max(1,lMaxFeatures//P))&#10;df_Estim=self.mSplit.getEstimPart(df)&#10;lARInputs=df_Estim[self.mExogenousInfo.mEncodedExogenous].values&#10;lARTarget=df_Estim[cycle_residue].values&#10;lPreselectionFeatureSelector.fit(lARInputs,lARTarget)&#10;lSupport=lPreselectionFeatureSelector.get_support(indices=True)&#10;&#10;lPreselected=[self.mExogenousInfo.mEncodedExogenous[k]for k in lSupport]&#10;&#10;return lPreselected&#10;"/>
        <sourcecode id="ugLPP1V4uPPvG" value="P=self.get_nb_lags()&#10;&#10;lag_df,lags=self.generateLagsForTraining(df,cycle_residue,(1,P))&#10;&#10;lag_dfs=[lag_df]&#10;for autoreg in self.mARList[cycle_residue]:&#10;  for lag in lags:&#10;    (name,p)=lag&#10;    autoreg.register_lag(name,p)&#10;&#10;&#10;lUseExog=False&#10;for autoreg in self.mARList[cycle_residue]:&#10;  if(autoreg.mExogenousInfo is not None):&#10;    lUseExog=True&#10;&#10;&#10;if(lUseExog):&#10;  P1=P&#10;&#10;  autoreg.mNbExogenousLags=P1&#10;&#10;  lEncodedExogenous=self.preselect_exog_vars(df,cycle_residue)&#10;  for ex in lEncodedExogenous:&#10;    (lag_df,lags_ex)=self.generateLagsForTraining(df,ex,(1,P1))&#10;&#10;    lag_dfs=lag_dfs+[lag_df]&#10;    for autoreg in self.mARList[cycle_residue]:&#10;      if(autoreg.mExogenousInfo is not None):&#10;        for lag in lags_ex:&#10;          (name,p)=lag&#10;          autoreg.register_lag(name,p)&#10;&#10;&#10;&#10;&#10;&#10;self.mARFrame=pd.concat([self.mARFrame]+lag_dfs,axis=1)&#10;"/>
        <sourcecode id="uvTz4eTD0YzFj" value="logger=tsutil.get_pyaf_logger()&#10;&#10;self.mARFrame=pd.DataFrame(index=self.mCycleFrame.index)&#10;&#10;self.mTimeInfo.addVars(self.mARFrame)&#10;&#10;self.mCycleFrame[cycle_residue]=self.mCycleFrame[cycle_residue]&#10;self.mARFrame[cycle_residue]=self.mCycleFrame[cycle_residue]&#10;self.mDefaultValues={&#10;}&#10;&#10;&#10;self.addLagsForTraining(self.mCycleFrame,cycle_residue)&#10;&#10;lCleanListOfArModels=[]&#10;&#10;for autoreg in self.mARList[cycle_residue]:&#10;  self.mARFrame[autoreg.mTrend.mOutName]=autoreg.mCycle.mTrendFrame[autoreg.mTrend.mOutName]&#10;  self.mARFrame[autoreg.mCycle.mOutName]=self.mCycleFrame[autoreg.mCycle.mOutName]&#10;  if((autoreg.mFormula==&quot;NoAR&quot;)or(len(autoreg.mInputNames)&gt;0)):&#10;    lCleanListOfArModels.append(autoreg)&#10;&#10;&#10;  else:&#10;    if(self.mOptions.mDebugAR):&#10;      logger.info(&quot;SKIPPING_AR_MODEL_NO_VALID_INPUTS &quot;+autoreg.mOutName)&#10;&#10;&#10;&#10;&#10;if(len(lCleanListOfArModels)==0):&#10;  lZeroAR=cZeroAR(cycle_residue)&#10;  cycle=self.mARList[cycle_residue][0].mCycle&#10;  lZeroAR.mCycle=cycle&#10;  lZeroAR.mTrend=cycle.mTrend&#10;  lCleanListOfArModels=[lZeroAR]&#10;&#10;self.mARList[cycle_residue]=lCleanListOfArModels&#10;&#10;for autoreg in self.mARList[cycle_residue]:&#10;  autoreg.mOptions=self.mOptions&#10;&#10;  autoreg.mCycleFrame=self.mCycleFrame&#10;&#10;  autoreg.mARFrame=self.mARFrame&#10;  autoreg.mTimeInfo=self.mTimeInfo&#10;&#10;  autoreg.mSplit=self.mSplit&#10;&#10;  autoreg.mDefaultValues=self.mDefaultValues&#10;&#10;  autoreg.mDecompositionType=self.mDecompositionType&#10;  lTimer=None&#10;  if(self.mOptions.mDebugAR):&#10;    lTimer=tsutil.cTimer((&quot;TRAINING_AR_MODEL&quot;,autoreg.mFormula,autoreg.mCycleResidueName))&#10;&#10;  autoreg.fit()&#10;&#10;  if(self.mOptions.mDebugAR):&#10;    autoreg.computePerf()&#10;&#10;&#10;&#10;"/>
        <sourcecode id="us23X8cdJWWQn" value="if(np.isnan(sig[:-1]).any()):&#10;  logger=tsutil.get_pyaf_logger()&#10;&#10;  logger.error(&quot;CYCLE_RESIDUE_WITH_NAN_IN_SIGNAL&quot;+str(sig))&#10;&#10;  raise tsutil.Internal_PyAF_Error(&quot;INVALID_COLUMN _FOR_CYCLE_RESIDUE ['&quot;+name+&quot;'&quot;)&#10;&#10;&#10;pass&#10;"/>
        <sourcecode id="u0WDWEUADAK7G" value="lLags=self.mCycleFrame.shape[0]//4&#10;&#10;if(lLags&gt;=self.mOptions.mMaxAROrder):&#10;  lLags=self.mOptions.mMaxAROrder&#10;&#10;&#10;return lLags&#10;"/>
        <sourcecode id="usphBUia6EtDo" value="if(self.mOptions.mActiveAutoRegressions[model_type_str]):&#10;  lNewModel=model_class(cycle_residue,iLags)&#10;&#10;  self.mARList[cycle_residue]=self.mARList[cycle_residue]+[lNewModel]&#10;&#10;&#10;if(iAddExogenous and(self.mExogenousInfo is not None)and self.mOptions.mActiveAutoRegressions[model_type_str+'X']):&#10;  lNewModelX=model_class(cycle_residue,iLags,self.mExogenousInfo)&#10;&#10;  self.mARList[cycle_residue]=self.mARList[cycle_residue]+[lNewModelX]&#10;&#10;&#10;"/>
        <sourcecode id="uT0Ug1qNE3jGM" value="from.import Scikit_Models as tsscikit&#10;lTimer=None&#10;if(self.mOptions.mDebugAR):&#10;  lTimer=tsutil.cTimer((&quot;TRAINING_AR_MODELS&quot;,:&#10;    &quot;Signal&quot;:self.mTimeInfo.mSignal&#10;  ))&#10;&#10;logger=tsutil.get_pyaf_logger()&#10;&#10;self.mSkippedARList=[]&#10;lNeedExogenous=False&#10;&#10;for trend in self.mTrendList:&#10;  for cycle in self.mCycleList[trend]:&#10;    cycle_residue=cycle.getCycleResidueName()&#10;&#10;    if(self.mOptions.mDebugAR):&#10;      self.check_not_nan(self.mCycleFrame[cycle_residue],cycle_residue)&#10;&#10;    self.mARList[cycle_residue]=[]&#10;&#10;    if(self.mOptions.mActiveAutoRegressions['NoAR']):&#10;      self.mARList[cycle_residue]=[cZeroAR(cycle_residue)]&#10;&#10;&#10;    lLags=self.get_nb_lags()&#10;    lThreshold=0.001&#10;    lEstimResidue=self.mSplit.getEstimPart(self.mCycleFrame[cycle_residue])&#10;    lCycleRange=lEstimResidue.max()-lEstimResidue.min()&#10;    lKeep=(lEstimResidue.shape[0]&gt;12)and(lCycleRange&gt;=lThreshold)&#10;    if(not lKeep):&#10;      self.mSkippedARList=self.mSkippedARList+[cycle_residue]&#10;&#10;    if(lKeep):&#10;      self.add_model_if_activated(cycle_residue,'AR',tsscikit.cAutoRegressiveModel,lLags,True)&#10;      self.add_model_if_activated(cycle_residue,'SVR',tsscikit.cSVR_Model,lLags,True)&#10;      if(self.mOptions.mActiveAutoRegressions['LSTM']or self.mOptions.mActiveAutoRegressions['LSTMX']):&#10;        lLSTMClass=self.mOptions.getPytorchOrKerasClass('LSTM')&#10;        if(lLSTMClass is not None):&#10;          self.add_model_if_activated(cycle_residue,'LSTM',lLSTMClass,lLags,True)&#10;&#10;&#10;      if(self.mOptions.mActiveAutoRegressions['MLP']or self.mOptions.mActiveAutoRegressions['MLPX']):&#10;        lMLPClass=self.mOptions.getPytorchOrKerasClass('MLP')&#10;        if(lMLPClass is not None):&#10;        self.add_model_if_activated(cycle_residue,'MLP',lMLPClass,lLags,True)&#10;      if(self.mOptions.mActiveAutoRegressions['XGB']or self.mOptions.mActiveAutoRegressions['XGBX']):&#10;        if(self.mOptions.canBuildXGBoostModel('XGB')):&#10;          self.add_model_if_activated(cycle_residue,'XGB',tsscikit.cXGBoost_Model,lLags,True)&#10;&#10;&#10;      if(self.mOptions.mActiveAutoRegressions['LGB']or self.mOptions.mActiveAutoRegressions['LGBX']):&#10;        if(self.mOptions.canBuildLightGBMModel('LGB')):&#10;          self.add_model_if_activated(cycle_residue,'LGB',tsscikit.cLightGBM_Model,lLags,True)&#10;&#10;&#10;      if(self.mOptions.mActiveAutoRegressions['CROSTON']):&#10;        from.import Intermittent_Models as interm&#10;        lIsSignalIntermittent=interm.is_signal_intermittent(self.mCycleFrame[cycle_residue],self.mOptions)&#10;        if(lIsSignalIntermittent):&#10;          self.add_model_if_activated(cycle_residue,'CROSTON',interm.cCroston_Model,lLags,False)&#10;&#10;&#10;&#10;    if(len(self.mARList[cycle_residue])==0):&#10;      self.mARList[cycle_residue]=[cZeroAR(cycle_residue)]&#10;&#10;&#10;    for lAR in self.mARList[cycle_residue]:&#10;      lAR.mCycle=cycle&#10;      lAR.mTrend=cycle.mTrend&#10;      if(lAR.mExogenousInfo is not None):&#10;        lNeedExogenous=True&#10;&#10;&#10;&#10;&#10;if(len(self.mSkippedARList)&gt;0):&#10;  lTenFirst=sorted(self.mSkippedARList[:10])&#10;  lSkipInfo=(self.mDecompositionType,len(self.mSkippedARList),10,lTenFirst)&#10;  if(self.mOptions.mDebugAR):&#10;    logger.info(&quot;SKIPPING_AR_MODELS_WITH_LOW_VARIANCE_FOR_CYCLE_RESIDUES &quot;+str(lSkipInfo))&#10;&#10;&#10;&#10;if(lNeedExogenous):&#10;  if(self.mOptions.mDebugAR):&#10;    logger.info(&quot;AR_MODEL_ADD_EXOGENOUS &quot;+str(self.mCycleFrame.shape[0])+&#10;    &quot; &quot;+str(len(self.mExogenousInfo.mEncodedExogenous)))&#10;&#10;  self.mCycleFrame=self.mExogenousInfo.transformDataset(self.mCycleFrame)&#10;&#10;&#10;for cycle_residue in self.mARList.keys():&#10;  self.estimate_ar_models_for_cycle(cycle_residue)&#10;&#10;  for autoreg in self.mARList[cycle_residue]:&#10;    autoreg.mARFrame=pd.DataFrame(index=self.mCycleFrame.index)&#10;&#10;&#10;  del autoreg.mARFrame&#10;&#10;del self.mARFrame&#10;&#10;gc.collect()"/>
        <sourcecode id="ua5B6cgfG0mCr" value="self.mTimeInfo=tsti.cTimeInfo()&#10;self.mTrendFrame=None&#10;self.mCycleFrame=None&#10;self.mTrend=trend&#10;&#10;self.mTrend_residue_name=self.mTrend.mOutName+'_residue'&#10;self.mFormula=None&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;"/>
        <sourcecode id="uLUNqk2IRJ2hY" value="return self.getCycleName()+&quot;_residue&quot;&#10;&#10;"/>
        <sourcecode id="uZL1fU0NPGckr" value="tsplot.decomp_plot(self.mCycleFrame,self.mTimeInfo.mNormalizedTimeColumn,&#10;self.mTrend_residue_name,self.getCycleName(),self.getCycleResidueName(),horizon=self.mTimeInfo.mHorizon)&#10;"/>
        <sourcecode id="uzMoE7EF4HSQX" value="if(np.isnan(sig[:-1]).any()or np.isinf(sig[:-1]).any()):&#10;  logger=tsutil.get_pyaf_logger()&#10;&#10;  logger.error(&quot;CYCLE_RESIDUE_WITH_NAN_IN_SIGNAL&quot;+str(sig))&#10;&#10;  raise tsutil.Internal_PyAF_Error(&quot;CYCLE_COLUMN _FOR_TREND_RESIDUE ['&quot;+name+&quot;'&quot;)&#10;&#10;&#10;if(sig[:-1].max()&gt;1e5):&#10;  self.dump_values()&#10;  raise tsutil.Internal_PyAF_Error(&quot;Invalid cycle_residue_too_large '&quot;+str(name)+&quot;'&quot;)&#10;&#10;&#10;pass&#10;pass&#10;"/>
        <sourcecode id="upcVodfUaUvYc" value="lSignal=df[self.mSignal]&#10;lTrend=df[self.mTrend.mOutName]&#10;lCycle=df[self.getCycleName()]&#10;lOutName=self.getCycleName()&#10;if(self.mDecompositionType in['T+S+R']):&#10;  df[self.getCycleResidueName()]=lSignal-lTrend-lCycle&#10;&#10;elif(self.mDecompositionType in['TS+R']):&#10;  df[self.getCycleResidueName()]=lSignal-lTrend*lCycle&#10;&#10;else:&#10;  lTrendCycle=lTrend*lCycle&#10;  lTrendCycle=lTrendCycle.apply(lambda x:x if(abs(x)&gt;1e-2)else 1e-2)&#10;  df[self.getCycleResidueName()]=lSignal/lTrendCycle&#10;&#10;"/>
        <sourcecode id="ukU6Ni56wMecc" value="lCycleFrameEstim=self.mSplit.getEstimPart(iCycleFrame)&#10;&#10;lGroupBy=lCycleFrameEstim.groupby(by=[iCycleName],sort=False)[self.mTrend_residue_name]&#10;lEncodedValueDict=None&#10;if(self.mOptions.mCycle_Encoding_Scheme==&quot;Target_Mean&quot;):&#10;  lEncodedValueDict=lGroupBy.mean().to_dict()&#10;&#10;&#10;else:&#10;  lEncodedValueDict=lGroupBy.median().to_dict()&#10;&#10;&#10;for x in lEncodedValueDict.keys():&#10;  lEncodedValueDict[x]=np.float64(lEncodedValueDict[x])&#10;&#10;return lEncodedValueDict&#10;"/>
        <sourcecode id="u6SarybF6EFot" value="lCycleFrameEstim=self.mSplit.getEstimPart(self.mCycleFrame)&#10;&#10;if(self.mOptions.mCycle_Encoding_Scheme==&quot;Target_Mean&quot;):&#10;  return np.float64(lCycleFrameEstim[self.mTrend_residue_name].mean())&#10;&#10;&#10;return np.float64(lCycleFrameEstim[self.mTrend_residue_name].median())&#10;&#10;"/>
        <sourcecode id="uHl97yKUOrZA4" value="if(self.mOptions.mDebug):&#10;  self.check_not_nan(self.mCycleFrame[self.getCycleResidueName()],self.getCycleResidueName())&#10;&#10;self.mCycleFitPerf=tsperf.cPerf()&#10;&#10;self.mCycleForecastPerf=tsperf.cPerf()&#10;&#10;(lFrameFit,lFrameForecast,lFrameTest)=self.mSplit.cutFrame(self.mCycleFrame)&#10;&#10;self.mCycleFitPerf.computeCriterionValues(&#10;lFrameFit[self.mTrend_residue_name],lFrameFit[self.getCycleName()],[self.mOptions.mCycle_Criterion],self.getCycleName())self.mCycleForecastPerf.computeCriterionValues(&#10;lFrameForecast[self.mTrend_residue_name],lFrameForecast[self.getCycleName()],[self.mOptions.mCycle_Criterion],self.getCycleName())self.dumpCyclePerf()&#10;"/>
        <sourcecode id="uaxDsX9Nj2tJX" value="if(self.mOptions.mDebugCycles):&#10;  logger=tsutil.get_pyaf_logger()&#10;&#10;  lDict={&#10;&#10;  &quot;Fit&quot;:self.mCycleFitPerf.getCriterionValue(self.mOptions.mCycle_Criterion),&quot;Forecast&quot;:self.mCycleForecastPerf.getCriterionValue(self.mOptions.mCycle_Criterion),}&#10;&#10;  logger.info(&quot;CYCLE_PERF_DETAIL &quot;+self.mOptions.mCycle_Criterion+&quot; &quot;+self.mOutName+&quot; &quot;+str(lDict))&#10;&#10;"/>
        <sourcecode id="u9Erjsm2AQdhY" value="super().__init__(trend)&#10;&#10;self.mFormula=&quot;NoCycle&quot;&#10;self.mComplexity=tscomplex.eModelComplexity.Low&#10;&#10;self.mConstantValue=0.0&#10;"/>
        <sourcecode id="uIrEkFK4lmb2S" value="return self.mTrend_residue_name+&quot;_zeroCycle[&quot;+str(self.mConstantValue)+&quot;]&quot;&#10;&#10;"/>
        <sourcecode id="uT7riFYJZmEs0" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;ZERO_CYCLE_MODEL_VALUES &quot;+self.getCycleName()+&quot; &quot;+str(self.mConstantValue)+&quot; {}&quot;)&#10;&#10;"/>
        <sourcecode id="uqNfmS2WbJa3C" value="self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;self.mTimeInfo.addVars(self.mCycleFrame)&#10;&#10;self.mConstantValue=0.0&#10;if(self.mDecompositionType in['TS+R','TSR']):&#10;  self.mConstantValue=1.0&#10;&#10;self.mCycleFrame[self.mTrend.mOutName]=self.mTrendFrame[self.mTrend.mOutName]&#10;self.mCycleFrame[self.mTrend_residue_name]=self.mTrendFrame[self.mTrend_residue_name]&#10;self.mCycleFrame[self.getCycleName()]=self.mConstantValue&#10;self.mOutName=self.getCycleName()&#10;self.compute_cycle_residue(self.mCycleFrame)&#10;"/>
        <sourcecode id="uI0rfdbWL44bw" value="df[self.getCycleName()]=self.mConstantValue&#10;&#10;self.compute_cycle_residue(df)&#10;return df&#10;&#10;"/>
        <sourcecode id="uN3ILfbNnLG02" value="super().__init__(trend)&#10;&#10;self.mDatePart=date_part&#10;&#10;self.mEncodedValueDict={&#10;}&#10;&#10;self.mFormula=&quot;Seasonal_&quot;+self.mDatePart.name&#10;&#10;"/>
        <sourcecode id="ufichRs13oCkO" value="return self.mTrend_residue_name+&quot;_Seasonal_&quot;+self.mDatePart.name&#10;&#10;"/>
        <sourcecode id="u423Kdrh3M2pM" value="logger=tsutil.get_pyaf_logger()&#10;&#10;lDict=dict(sorted([(k,round(v,6))for(k,v)in self.mEncodedValueDict.items()]))&#10;logger.info(&quot;SEASONAL_MODEL_VALUES &quot;+self.getCycleName()+&quot; &quot;+str(round(self.mDefaultValue,6))+&quot; &quot;+str(lDict))&#10;&#10;"/>
        <sourcecode id="u2ACq4Ov8hpNK" value="lTimeDelta=iTimeMax-iTimeMin&#10;&#10;lDays=lTimeDelta/np.timedelta64(1,'D')&#10;&#10;lSeconds=lTimeDelta/np.timedelta64(1,'s')&#10;&#10;lThresholds={&#10;&#10;dtfunc.eDatePart.Hour:(1*10,None),dtfunc.eDatePart.Minute:(None,3600*10),dtfunc.eDatePart.Second:(None,360*10),dtfunc.eDatePart.DayOfMonth:(30*10,None),dtfunc.eDatePart.DayOfWeek:(7*10,None),dtfunc.eDatePart.MonthOfYear:(360*10,None),dtfunc.eDatePart.WeekOfYear:(360*10,None),dtfunc.eDatePart.WeekOfYear:(7*10,None),dtfunc.eDatePart.DayOfYear:(360*10,None),dtfunc.eDatePart.HourOfWeek:(7*10,None),dtfunc.eDatePart.TwoHourOfWeek:(7*10,None),dtfunc.eDatePart.ThreeHourOfWeek:(7*10,None),dtfunc.eDatePart.FourHourOfWeek:(7*10,None),dtfunc.eDatePart.SixHourOfWeek:(7*10,None),dtfunc.eDatePart.EightHourOfWeek:(7*10,None),dtfunc.eDatePart.TwelveHourOfWeek:(7*10,None),dtfunc.eDatePart.WeekOfMonth:(30*10,None),dtfunc.eDatePart.DayOfNthWeekOfMonth:(30*10,None)}&#10;&#10;lThreshold=lThresholds.get(self.mDatePart)&#10;if(lThreshold[0]is not None):&#10;  return(lDays&gt;=lThreshold[0])&#10;&#10;&#10;elif(lThreshold[1]is not None):&#10;  return(lSeconds&gt;=lThreshold[1])&#10;&#10;&#10;return False&#10;&#10;"/>
        <sourcecode id="uAx3CSB1LsRz3" value="lHelper=dtfunc.cDateTime_Helper()&#10;return lHelper.apply_date_time_computer(self.mDatePart,iTimeValues)&#10;&#10;"/>
        <sourcecode id="uZ6scia9UK12U" value="assert(self.mTimeInfo.isPhysicalTime())&#10;&#10;lHor=self.mTimeInfo.mHorizon&#10;&#10;self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;self.mTimeInfo.addVars(self.mCycleFrame)&#10;&#10;lName=self.getCycleName()&#10;&#10;self.mCycleFrame[self.mTrend_residue_name]=self.mTrendFrame[self.mTrend_residue_name]&#10;self.mCycleFrame[self.mTrend.mOutName]=self.mTrendFrame[self.mTrend.mOutName]&#10;self.mCycleFrame[lName]=self.compute_date_parts(self.mTrendFrame[self.mTime])&#10;self.mDefaultValue=self.compute_target_means_default_value()&#10;self.mEncodedValueDict=self.compute_target_means_by_cycle_value(self.mCycleFrame,self.getCycleName())&#10;self.mCycleFrame[lName+'_enc']=self.mCycleFrame[lName].map(self.mEncodedValueDict).fillna(self.mDefaultValue)&#10;self.mCycleFrame[lName+'_enc'].fillna(self.mDefaultValue,inplace=True)&#10;&#10;self.mCycleFrame[lName+'_NotEncoded']=self.mCycleFrame[lName]&#10;&#10;self.mCycleFrame[lName]=self.mCycleFrame[lName+'_enc']&#10;&#10;self.mOutName=self.getCycleName()&#10;self.mComplexity=tscomplex.eModelComplexity.Low&#10;&#10;if(len(self.mEncodedValueDict.keys())&gt;31):&#10;  self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;&#10;self.compute_cycle_residue(self.mCycleFrame)&#10;"/>
        <sourcecode id="uCG6hwIRq9MBX" value="lDateParts=self.compute_date_parts(df[self.mTime])&#10;df[self.getCycleName()]=lDateParts.map(self.mEncodedValueDict).fillna(self.mDefaultValue)&#10;self.compute_cycle_residue(df)&#10;return df&#10;&#10;"/>
        <sourcecode id="uutTIxfuoMONt" value="super().__init__(trend)&#10;&#10;self.mCycleFrame=None&#10;self.mCyclePerfByLength={&#10;}&#10;&#10;self.mBestCycleValueDict={&#10;}&#10;&#10;self.mBestCycleLength=None&#10;self.mCriterion=criterion&#10;self.mFormula=&quot;BestCycle&quot;&#10;"/>
        <sourcecode id="ul3E5GSshC3yr" value="return self.mTrend_residue_name+&quot;_Cycle_&quot;+str(self.mBestCycleLength)&#10;"/>
        <sourcecode id="u9r0e2yzpDGWX" value="logger=tsutil.get_pyaf_logger()&#10;&#10;lDict={&#10;}&#10;if(self.mBestCycleLength is None)else self.mBestCycleValueDict[self.mBestCycleLength]&#10;lDict=dict(sorted([(k,round(v,6))for(k,v)in lDict.items()]))&#10;logger.info(&quot;BEST_CYCLE_LENGTH_VALUES &quot;+self.getCycleName()+&quot; &quot;+str(self.mBestCycleLength)+&quot; &quot;+str(round(self.mDefaultValue,6))+&quot; &quot;+str(lDict))&#10;&#10;"/>
        <sourcecode id="uWCWqQNwfWpcA" value="self.mBestCycleLength=None&#10;&#10;lData=self.mCyclePerfByLength.items()&#10;if(len(lData)==0):&#10;  return&#10;&#10;lPerf=tsperf.cPerf()&#10;&#10;lSortingMethod_By_MAPE=lambda x:(x[1][0],x[0])&#10;lData=sorted(lData,key=lSortingMethod_By_MAPE)&#10;assert(len(lData)&gt;0)&#10;lBestCriterion=lData[0][1]&#10;lData_smallest=[x for x in lData if lPerf.is_close_criterion_value(self.mOptions.mCycle_Criterion,&#10;x[1][0],iTolerance=0.05,iRefValue=lBestCriterion[0])]lSortingMethod_By_Length=lambda x:(x[1][1],x[0])&#10;lData_smallest=sorted(lData_smallest,key=lSortingMethod_By_Length)&#10;assert(len(lData_smallest)&gt;0)&#10;self.mBestCycleLength=lData_smallest[0][0]&#10;pass&#10;"/>
        <sourcecode id="ukH47pDxQUwC2" value="if(self.mOptions.mCycleLengths is None):&#10;  lAbsMax=366&#10;  N=min(signal_length//6,lAbsMax)&#10;  lCycleLengths0=[x for x in range(3,60)]&#10;  lCycleLengths1=[5,7,12,24,30,60]&#10;  lCycleLengths2=[x*k for x in lCycleLengths1 for k in range(2,N//2)if((x*k)&lt;=N)]&#10;  lCycleLengths3=lCycleLengths0+lCycleLengths1+lCycleLengths2&#10;  lCycleLengths4=list(set(lCycleLengths3))&#10;  return[x for x in lCycleLengths4 if(x&lt;signal_length//6)]&#10;&#10;return[x for x in self.mOptions.mCycleLengths if(x&lt;signal_length//6)]&#10;"/>
        <sourcecode id="unxsgAwSvnXN6" value="self.mTimeInfo.addVars(self.mCycleFrame)&#10;&#10;self.mCycleFrame[self.mTrend_residue_name]=self.mTrendFrame[self.mTrend_residue_name]&#10;self.mCycleFrame[self.mTrend.mOutName]=self.mTrendFrame[self.mTrend.mOutName]&#10;self.mDefaultValue=self.compute_target_means_default_value()&#10;&#10;self.mCyclePerfByLength={&#10;}&#10;&#10;lEstimResidue=self.mSplit.getEstimPart(self.mTrendFrame[self.mTrend_residue_name])&#10;lCycleLengths=self.get_tested_cycles(lEstimResidue.shape[0])&#10;lTimer=None&#10;if(self.mOptions.mDebugCycles):&#10;  lTimer=tsutil.cTimer((&quot;SELECTING_BEST_CYCLE_FOR_MODEL&quot;,self.mTrend_residue_name,len(lCycleLengths),lCycleLengths))&#10;&#10;lCycleFrame=pd.DataFrame(index=self.mTrendFrame.index)&#10;&#10;lCycleFrame[self.mTrend_residue_name]=self.mTrendFrame[self.mTrend_residue_name]&#10;for lLength in lCycleLengths:&#10;  if(lLength&gt;1):&#10;    name_length=self.mTrend_residue_name+'_Cycle'&#10;&#10;    lCycleFrame[name_length]=self.mCycleFrame[self.mTimeInfo.mRowNumberColumn]%lLength&#10;    lEncodedValueDict=self.compute_target_means_by_cycle_value(lCycleFrame,name_length)&#10;    lCycleFrame[name_length+'_enc']=lCycleFrame[name_length].map(lEncodedValueDict).fillna(self.mDefaultValue)&#10;    self.mBestCycleValueDict[lLength]=lEncodedValueDict&#10;&#10;    lPerf=tsperf.cPerf()&#10;&#10;    lValidFrame=self.mSplit.getValidPart(lCycleFrame)&#10;&#10;    lCritValues=lPerf.computeCriterionValues(lValidFrame[self.mTrend_residue_name],&#10;    lValidFrame[name_length+&quot;_enc&quot;],[self.mCriterion],&quot;Validation&quot;)lCritValue=lCritValues[self.mCriterion]&#10;    if(lCritValue is None):&#10;      print(&quot;CYCFLE_CRITERION_VALUES&quot;,lCritValues)&#10;&#10;    if(lPerf.is_acceptable_criterion_value(self.mOptions.mCycle_Criterion,iRefValue=lCritValue)):&#10;      self.mCyclePerfByLength[lLength]=(round(lCritValue,3),len(lEncodedValueDict))&#10;      if(self.mOptions.mDebugCycles):&#10;        logger=tsutil.get_pyaf_logger()&#10;&#10;        logger.debug(&quot;CYCLE_INTERNAL_CRITERION &quot;+name_length+&quot; &quot;+str(lLength)+\&#10;        &quot; &quot;+self.mCriterion+&quot; &quot;+str(lCritValue))&#10;&#10;&#10;&#10;pass&#10;"/>
        <sourcecode id="utC8FlK14OLwj" value="self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;self.generate_cycles()&#10;&#10;self.computeBestCycle()&#10;&#10;self.mOutName=self.getCycleName()&#10;self.mFormula=&quot;Cycle_None&quot;&#10;if(self.mBestCycleLength is not None):&#10;  self.mFormula=&quot;Cycle_&quot;+str(self.mBestCycleLength)&#10;&#10;&#10;self.transformDataset(self.mCycleFrame)&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Low&#10;&#10;if(self.mBestCycleLength is not None):&#10;  lDict=self.mBestCycleValueDict[self.mBestCycleLength]&#10;&#10;  if(len(lDict.keys())&gt;31):&#10;    self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;&#10;&#10;"/>
        <sourcecode id="u3Dfl8wSu3sNL" value="if(self.mBestCycleLength is not None):&#10;  lValueCol=df[self.mTimeInfo.mRowNumberColumn].mod(self.mBestCycleLength)&#10;&#10;  df['cycle_internal']=lValueCol&#10;&#10;  lDict=self.mBestCycleValueDict[self.mBestCycleLength]&#10;&#10;  df[self.getCycleName()]=lValueCol.map(lDict).fillna(self.mDefaultValue)&#10;&#10;else:&#10;  df[self.getCycleName()]=np.zeros_like(df[self.mTimeInfo.mRowNumberColumn])&#10;&#10;  if(self.mDecompositionType in['TS+R','TSR']):&#10;    df[self.getCycleName()]=1.0&#10;&#10;&#10;self.compute_cycle_residue(df)&#10;if(self.mOptions.mDebug):&#10;  self.check_not_nan(df[self.getCycleName()].values,self.getCycleName())&#10;&#10;&#10;return df&#10;&#10;"/>
        <sourcecode id="uUU6qdkJIwfeD" value="self.mTimeInfo=tsti.cTimeInfo()&#10;self.mTrendFrame=None&#10;self.mCycleFrame=None&#10;self.mCycleList={&#10;}&#10;&#10;"/>
        <sourcecode id="uuyGMrtIL4AHa" value="if(resolution&gt;=self.mTimeInfo.mResolution):&#10;  lSeasonal=cSeasonalPeriodic(trend,seas_type)&#10;&#10;  if(self.mOptions.mActivePeriodics[lSeasonal.mFormula]):&#10;    if(lSeasonal.hasEnoughData(self.mTimeInfo.mTimeMin,self.mTimeInfo.mTimeMax)):&#10;      self.mCycleList[trend]=self.mCycleList[trend]+[lSeasonal]&#10;&#10;&#10;    else:&#10;      if(self.mOptions.mDebugCycles):&#10;        lTimeDelta=self.mTimeInfo.mTimeMax-self.mTimeInfo.mTimeMin&#10;        lDays=lTimeDelta/np.timedelta64(1,'D')&#10;&#10;        logger=tsutil.get_pyaf_logger()&#10;&#10;        logger.debug(&quot;NOT_ENOUGH_DATA_TO_ANAYLSE_SEASONAL_PATTERN &quot;+str((trend.__class__.__name__,seas_type,resolution,lDays)))&#10;&#10;&#10;&#10;&#10;pass&#10;"/>
        <sourcecode id="uEWbPubGKnQgZ" value="for trend in self.mTrendList:&#10;  self.mCycleList[trend]=[]&#10;&#10;  lTrend_residue_name=trend.mOutName+'_residue'&#10;  if(self.mOptions.mActivePeriodics['NoCycle']):&#10;    self.mCycleList[trend]=[cZeroCycle(trend)]&#10;&#10;&#10;  lThreshold=0.001&#10;  lEstimResidue=self.mSplit.getEstimPart(self.mTrendFrame[lTrend_residue_name])&#10;  lTrendRange=lEstimResidue.max()-lEstimResidue.min()&#10;  lKeep=(lEstimResidue.shape[0]&gt;=12)and(lTrendRange&gt;=lThreshold)&#10;  if(lKeep and self.mOptions.mActivePeriodics['BestCycle']):&#10;    self.mCycleList[trend]=self.mCycleList[trend]+[&#10;    cBestCycleForTrend(trend,self.mOptions.mCycle_Criterion)]&#10;&#10;  if(lKeep and self.mTimeInfo.isPhysicalTime()):&#10;    self.addSeasonal(trend,dtfunc.eDatePart.MonthOfYear,dtfunc.eTimeResolution.MONTH)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.WeekOfYear,dtfunc.eTimeResolution.DAY)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.DayOfMonth,dtfunc.eTimeResolution.DAY)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.DayOfWeek,dtfunc.eTimeResolution.DAY)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.DayOfYear,dtfunc.eTimeResolution.DAY)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.Hour,dtfunc.eTimeResolution.HOUR)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.Minute,dtfunc.eTimeResolution.MINUTE)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.Second,dtfunc.eTimeResolution.SECOND)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.HourOfWeek,dtfunc.eTimeResolution.HOUR)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.TwoHourOfWeek,dtfunc.eTimeResolution.HOUR)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.ThreeHourOfWeek,dtfunc.eTimeResolution.HOUR)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.FourHourOfWeek,dtfunc.eTimeResolution.HOUR)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.SixHourOfWeek,dtfunc.eTimeResolution.HOUR)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.EightHourOfWeek,dtfunc.eTimeResolution.HOUR)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.TwelveHourOfWeek,dtfunc.eTimeResolution.HOUR)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.WeekOfMonth,dtfunc.eTimeResolution.DAY)&#10;&#10;    self.addSeasonal(trend,dtfunc.eDatePart.DayOfNthWeekOfMonth,dtfunc.eTimeResolution.DAY)&#10;&#10;&#10;&#10;for trend in self.mTrendList:&#10;  if(len(self.mCycleList[trend])==0):&#10;    self.mCycleList[trend]=[cZeroCycle(trend)]&#10;&#10;&#10;  for cycle in self.mCycleList[trend]:&#10;    cycle.mTrendFrame=self.mTrendFrame&#10;&#10;    cycle.mCycleFrame=pd.DataFrame(index=self.mTrendFrame.index)&#10;    cycle.mTimeInfo=self.mTimeInfo&#10;&#10;    cycle.mSplit=self.mSplit&#10;&#10;    cycle.mOptions=self.mOptions&#10;&#10;    cycle.mDecompositionType=self.mDecompositionType&#10;&#10;&#10;"/>
        <sourcecode id="u4QVQZnX4qYYq" value="for trend in self.mTrendList:&#10;  for cycle in self.mCycleList[trend]:&#10;    cycle.plot()&#10;&#10;&#10;"/>
        <sourcecode id="u0y9VpUP6gKDr" value="self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;self.mCycleFrame=pd.DataFrame(index=self.mTrendFrame.index)&#10;&#10;self.mTimeInfo.addVars(self.mCycleFrame)&#10;&#10;for trend in self.mTrendList:&#10;  lTrend_residue_name=trend.mOutName+'_residue'&#10;  self.mCycleFrame[lTrend_residue_name]=self.mTrendFrame[lTrend_residue_name]&#10;  for cycle in self.mCycleList[trend]:&#10;    cycle.fit()&#10;&#10;    cycle.computePerf()&#10;&#10;    self.mCycleFrame[cycle.getCycleName()]=cycle.mCycleFrame[cycle.getCycleName()]&#10;    self.mCycleFrame[cycle.getCycleResidueName()]=cycle.mCycleFrame[cycle.getCycleResidueName()]&#10;    if(self.mOptions.mDebug):&#10;      cycle.check_not_nan(self.mCycleFrame[cycle.getCycleResidueName()].values,&#10;      cycle.getCycleResidueName())&#10;&#10;  self.mCycleFrame=self.mCycleFrame.copy()&#10;&#10;pass&#10;"/>
        <sourcecode id="usYLyon0iv4DR" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.debug(&quot;CYCLE_TRAINING_FILTER_SEASONALS_START&quot;)&#10;for trend in self.mTrendList:&#10;  lPerfs={&#10;}&#10;&#10;  lTrend_residue_name=trend.mOutName+'_residue'&#10;  lCycleList=[]&#10;  lSeasonals={&#10;}&#10;&#10;  for cycle in self.mCycleList[trend]:&#10;    if(isinstance(cycle,cSeasonalPeriodic)):&#10;      if(cycle.mCycleForecastPerf.is_acceptable_criterion_value(self.mOptions.mCycle_Criterion)):&#10;        lCritValue=cycle.mCycleForecastPerf.getCriterionValue(self.mOptions.mCycle_Criterion)&#10;        lCategories=len(cycle.mEncodedValueDict.keys())&#10;        lPerfs[cycle.mOutName]=(round(lCritValue,3),lCategories)&#10;        lSeasonals[cycle.mOutName]=cycle&#10;&#10;&#10;    else:&#10;      lCycleList=lCycleList+[cycle]&#10;&#10;&#10;  if(len(lSeasonals)==0):&#10;    return&#10;&#10;  lData=lPerfs.items()&#10;  lSortingMethod_By_MAPE=lambda x:(x[1][0],x[0])&#10;  lData=sorted(lData,key=lSortingMethod_By_MAPE)&#10;  assert(len(lData)&gt;0)&#10;  lBestPerf=lSeasonals[lData[0][0]].mCycleForecastPerf&#10;  lBestCriterion=lData[0][1]&#10;  lData_smallest=[x for x in lData if lBestPerf.is_close_criterion_value(self.mOptions.mCycle_Criterion,&#10;  x[1][0],iTolerance=0.05)]lSortingMethod_By_Length=lambda x:(x[1][1],x[0])&#10;  lData_smallest=sorted(lData_smallest,key=lSortingMethod_By_Length)&#10;  assert(len(lData_smallest)&gt;0)&#10;  lBestSeasonal=lSeasonals[lData_smallest[0][0]]&#10;  lBestCriterion=lData_smallest[0][1]&#10;  lCycleList=lCycleList+[lBestSeasonal]&#10;  self.mCycleList[trend]=lCycleList&#10;  if(self.mOptions.mDebugCycles):&#10;    logger.info(&quot;CYCLE_TRAINING_FILTER_SEASONALS_DATA &quot;+trend.mOutName+&quot; &quot;+str(lData_smallest))&#10;    logger.info(&quot;CYCLE_TRAINING_FILTER_SEASONALS_BEST &quot;+trend.mOutName+&quot; &quot;+lBestSeasonal.mOutName+&quot; &quot;+str(lBestCriterion))&#10;&#10;  logger.debug(&quot;CYCLE_TRAINING_FILTER_SEASONALS_END&quot;)&#10;&#10;pass&#10;"/>
        <sourcecode id="uYx1uQ403wIuX" value="lTimer=None&#10;if(self.mOptions.mDebugProfile):&#10;  lTimer=tsutil.cTimer((&quot;TRAINING_CYCLES&quot;,:&#10;    &quot;Signal&quot;:self.mTimeInfo.mSignal&#10;  ))&#10;&#10;self.defineCycles()&#10;&#10;self.estimateCycles()&#10;if(self.mOptions.mFilterSeasonals):&#10;  self.filterSeasonals()&#10;&#10;for trend in self.mTrendList:&#10;  for cycle in self.mCycleList[trend]:&#10;    del cycle.mCycleFrame&#10;&#10;&#10;gc.collect()"/>
        <sourcecode id="uNmf8UlZPbU7M" value="pass&#10;"/>
        <sourcecode id="uDgm1uFJdr4y1" value="if(iFullFrame is None):&#10;  return iOneSignalFrame&#10;&#10;lTime=iFullFrame.columns[0]&#10;lOneSignalCommonColumns=[col for col in iOneSignalFrame.columns if col in iFullFrame.columns]&#10;lOneSignalCommonColumns=[col for col in lOneSignalCommonColumns if col not in[lTime,iTimeInfo.mTime]]&#10;lOneSignalFrame=iOneSignalFrame.drop(lOneSignalCommonColumns,axis=1)&#10;lForecastFrame=iFullFrame.merge(lOneSignalFrame,how='left',left_on=lTime,right_on=iTimeInfo.mTime)&#10;&#10;return lForecastFrame&#10;"/>
        <sourcecode id="uAz1ZI2Ia596i" value="lOptions=iDecomsposition.mOptions&#10;lHorizons={&#10;}&#10;&#10;for sig in iDecomsposition.mSignals:&#10;  if(dict==type(iHorizons)):&#10;    lHorizons[sig]=iHorizons[sig]&#10;&#10;  else:&#10;    lHorizons[sig]=int(iHorizons)&#10;&#10;&#10;lInputDS=sample_signal_if_needed(iInputDS,lOptions)&#10;lForecastFrame=None&#10;args=[]&#10;&#10;for lSignal in iDecomsposition.mSignals:&#10;  args=args+[(lSignal,iDecomsposition,iInputDS,lHorizons[lSignal])]&#10;&#10;NCores=min(len(args),iDecomsposition.mOptions.mNbCores)&#10;if(iDecomsposition.mOptions.mParallelMode and NCores&gt;1):&#10;  from multiprocessing import Pool&#10;  pool=Pool(NCores)&#10;  for res in pool.imap(forecast_one_signal,args):&#10;    (lTimeInfo,lForecastFrame_i)=res&#10;    lForecastFrame=self.merge_frames(lForecastFrame,lForecastFrame_i,lTimeInfo)&#10;    del lForecastFrame_i&#10;&#10;  pool.close()&#10;  pool.join()&#10;&#10;else:&#10;  for arg in args:&#10;    res=forecast_one_signal(arg)&#10;    (lTimeInfo,lForecastFrame_i)=res&#10;    lForecastFrame=self.merge_frames(lForecastFrame,lForecastFrame_i,lTimeInfo)&#10;    del lForecastFrame_i&#10;&#10;&#10;return lForecastFrame&#10;"/>
        <sourcecode id="ut4JQCYu8lPBk" value="pass&#10;"/>
        <sourcecode id="uxfTB8DBKYIUr" value="return min(curve.keys(),key=lambda y:abs(float(curve[y])-x))&#10;"/>
        <sourcecode id="uq1bJzwI18rCn" value="return series.apply(lambda x:iSignal.quantile(x/Q))&#10;"/>
        <sourcecode id="uVRi4MMQyvn2G" value="q=pd.Series(range(0,Q)).apply(lambda x:iSignal.quantile(x/Q))&#10;curve=q.to_dict()&#10;lSignal_Q=iSignal.apply(lambda x:self.signal2quant(x,curve))+1&#10;s=self.quant2signal(lSignal_Q,iSignal,Q)&#10;return iSignal"/>
        <sourcecode id="u5E2Ks3lGS4yq" value="self.mSignalFrame=None&#10;self.mTime=None&#10;self.mSignal=None&#10;self.mTimeInfo=tsti.cTimeInfo()&#10;&#10;self.mTransformation=tstransf.cSignalTransform_None()&#10;&#10;"/>
        <sourcecode id="ucuMSIrExYph2" value="assert(iInputDS.shape[0]&gt;0)&#10;assert(iInputDS.shape[1]&gt;0)&#10;assert(iTime in iInputDS.columns)&#10;assert(iSignal in iInputDS.columns)&#10;self.mTime=iTime&#10;self.mOriginalSignal=iSignal&#10;&#10;self.mDecompositionType=iDecomspositionType&#10;self.mTransformation=iTransformation&#10;&#10;self.mTransformation.mOriginalSignal=iSignal&#10;&#10;self.mTransformation.mOptions=self.mOptions&#10;&#10;self.mSignal=iTransformation.get_name(iSignal)&#10;self.mHorizon=iHorizon&#10;&#10;self.mSplit=tscut.cCuttingInfo()&#10;self.mSplit.mTime=self.mTime&#10;&#10;self.mSplit.mSignal=self.mSignal&#10;&#10;self.mSplit.mOriginalSignal=self.mOriginalSignal&#10;&#10;self.mSplit.mHorizon=self.mHorizon&#10;&#10;self.mSplit.mOptions=self.mOptions&#10;&#10;self.mTimeInfo=tsti.cTimeInfo()&#10;&#10;self.mTimeInfo.mTime=self.mTime&#10;&#10;self.mTimeInfo.mSignal=self.mSignal&#10;&#10;self.mTimeInfo.mOriginalSignal=self.mOriginalSignal&#10;&#10;self.mTimeInfo.mHorizon=self.mHorizon&#10;&#10;self.mTimeInfo.mOptions=self.mOptions&#10;&#10;self.mTimeInfo.mSplit=self.mSplit&#10;&#10;self.mExogenousInfo=None&#10;&#10;if(iExogenousData is not None):&#10;  self.mExogenousInfo=tsexog.cExogenousInfo()&#10;&#10;  self.mExogenousInfo.mExogenousData=iExogenousData&#10;&#10;  self.mExogenousInfo.mTimeInfo=self.mTimeInfo&#10;&#10;  self.mExogenousInfo.mOptions=self.mOptions&#10;&#10;&#10;"/>
        <sourcecode id="uW6iB0e4cCsgP" value="self.mPerfsByModel={&#10;}&#10;&#10;for model in iModels.keys():&#10;  iModels[model].updatePerfs()&#10;&#10;&#10;for(name,model)in iModels.items():&#10;  lComplexity=model.getComplexity_as_ordering_string()&#10;&#10;  (lFitPerf,lForecastPerf,lTestPerf)=model.get_aggregated_criterion_values_for_model_selection()&#10;&#10;  lSplit=model.mTimeInfo.mOptions.mCustomSplit&#10;  self.mPerfsByModel[(self.mSignal,self.mDecompositionType,lSplit,model.mOutName)]=[(self.mSignal,self.mDecompositionType,model),lComplexity,lFitPerf,lForecastPerf,lTestPerf]&#10;&#10;  gc.collect()&#10;&#10;return iModels&#10;&#10;"/>
        <sourcecode id="u6Ci8puPDoLz1" value="lTimer=tsutil.cTimer((&quot;TRAINING&quot;,:&#10;  &quot;Signal&quot;:iSignal,&#10;  &quot;Horizon&quot;:iHorizon,&quot;Transformation&quot;:iTransformation.get_name(iSignal),&quot;DecompositionType&quot;:iDecomspositionType&#10;))lInputDS=iInputDS[[iTime,iSignal]].copy()&#10;lInputDS=sample_signal_if_needed(lInputDS,self.mOptions)&#10;self.setParams(lInputDS,iTime,iSignal,iHorizon,iTransformation,iDecomspositionType,self.mExogenousData)&#10;&#10;lMissingImputer=tsmiss.cMissingDataImputer()&#10;lMissingImputer.mOptions=self.mOptions&#10;self.mSignalFrame=lMissingImputer.apply(lInputDS,iTime,iSignal).copy()&#10;assert(self.mSignalFrame.shape[0]&gt;0)&#10;self.mSplit.mSignalFrame=self.mSignalFrame&#10;&#10;self.mSplit.estimate()&#10;&#10;self.mTimeInfo.mSignalFrame=self.mSignalFrame&#10;&#10;self.mTimeInfo.estimate()&#10;&#10;self.mSignalFrame['row_number']=np.arange(0,self.mSignalFrame.shape[0])&#10;&#10;lSignal=self.mSignalFrame[self.mOriginalSignal]&#10;self.mTransformation.fit(lSignal)&#10;&#10;self.mSignalFrame[self.mSignal]=self.mTransformation.apply(lSignal)&#10;&#10;if(self.mExogenousInfo is not None):&#10;  lTimer2=None&#10;  if(self.mOptions.mDebugProfile):&#10;    lTimer2=tsutil.cTimer((&quot;TRAINING_EXOGENOUS_DATA&quot;,:&#10;      &quot;Signal&quot;:iSignal&#10;    ))&#10;&#10;  self.mExogenousInfo.fit()&#10;&#10;&#10;lTrendEstimator=tstr.cTrendEstimator()&#10;lTrendEstimator.mSignalFrame=self.mSignalFrame&#10;lTrendEstimator.mTimeInfo=self.mTimeInfo&#10;lTrendEstimator.mSplit=self.mSplit&#10;lTrendEstimator.mOptions=self.mOptions&#10;&#10;lTrendEstimator.mDecompositionType=iDecomspositionType&#10;lTrendEstimator.estimateTrend()&#10;&#10;lCycleEstimator=tscy.cCycleEstimator()&#10;&#10;lCycleEstimator.mTrendFrame=lTrendEstimator.mTrendFrame&#10;&#10;lCycleEstimator.mTrendList=lTrendEstimator.mTrendList&#10;&#10;del lTrendEstimator&#10;&#10;gc.collect()&#10;lCycleEstimator.mTimeInfo=self.mTimeInfo&#10;lCycleEstimator.mSplit=self.mSplit&#10;lCycleEstimator.mDecompositionType=iDecomspositionType&#10;lCycleEstimator.mOptions=self.mOptions&#10;&#10;lCycleEstimator.estimateAllCycles()&#10;&#10;lAREstimator=tsar.cAutoRegressiveEstimator()&#10;&#10;lAREstimator.mCycleFrame=lCycleEstimator.mCycleFrame&#10;&#10;lAREstimator.mTrendList=lCycleEstimator.mTrendList&#10;&#10;lAREstimator.mCycleList=lCycleEstimator.mCycleList&#10;&#10;del lCycleEstimator&#10;&#10;gc.collect()&#10;lAREstimator.mTimeInfo=self.mTimeInfo&#10;lAREstimator.mSplit=self.mSplit&#10;lAREstimator.mDecompositionType=iDecomspositionType&#10;lAREstimator.mExogenousInfo=self.mExogenousInfo&#10;&#10;lAREstimator.mOptions=self.mOptions&#10;&#10;lAREstimator.estimate()&#10;&#10;lModels={&#10;}&#10;&#10;&#10;for trend in lAREstimator.mTrendList:&#10;  for cycle in lAREstimator.mCycleList[trend]:&#10;    cycle_residue=cycle.getCycleResidueName()&#10;&#10;    for autoreg in lAREstimator.mARList[cycle_residue]:&#10;      lModel=tsmodel.cTimeSeriesModel(self.mTransformation,self.mDecompositionType,&#10;      trend,cycle,autoreg)&#10;      lModels[lModel.mOutName]=lModel&#10;&#10;&#10;&#10;&#10;del lAREstimator&#10;&#10;gc.collect()&#10;self.updatePerfsForAllModels(lModels)&#10;&#10;gc.collect()&#10;"/>
        <sourcecode id="uH6T99Q0mRDO8" value="self.mName=name&#10;&#10;self.mInputDS=None&#10;&#10;self.mTime=None&#10;&#10;self.mSignal=None&#10;&#10;self.mHorizon=None&#10;&#10;self.mTransformation=None&#10;&#10;self.mSigDec=None&#10;&#10;self.mSplit=None&#10;self.mResult=None&#10;&#10;"/>
        <sourcecode id="uZFpuAwHhFL1m" value="self.mSigDecBySplitAndTransform={&#10;}&#10;&#10;&#10;self.mOptions=tsopts.cSignalDecomposition_Options()&#10;&#10;self.mExogenousData=None&#10;&#10;self.mTransformList={&#10;}&#10;&#10;pass&#10;"/>
        <sourcecode id="uYxyszxOGwEtH" value="lSplits=[None]&#10;if(self.mOptions.mCrossValidationOptions.mMethod is not None):&#10;  lFolds=self.mOptions.mCrossValidationOptions.mNbFolds&#10;  lRatio=1.0/lFolds&#10;  lSplits=[(k*lRatio,lRatio,0.0)for k in range(lFolds//2,lFolds)]&#10;&#10;return lSplits&#10;"/>
        <sourcecode id="uoDA1ROaTRznh" value="gc.collect()&#10;self.train_all_transformations(iInputDS,iSplits,iTime,iSignals,iHorizon)&#10;&#10;gc.collect()&#10;self.finalize_training()&#10;gc.collect()&#10;"/>
        <sourcecode id="uArMQP1Sv6kgk" value="args=[]&#10;&#10;for(lSignal,sigdecs)in self.mSigDecBySplitAndTransform.items():&#10;  args=args+[(lSignal,sigdecs,self.mOptions)]&#10;&#10;self.mPerfsByModel={&#10;}&#10;&#10;self.mTrPerfDetails={&#10;}&#10;&#10;self.mModelShortList={&#10;}&#10;&#10;self.mBestModels={&#10;}&#10;&#10;NCores=min(len(args),self.mOptions.mNbCores)&#10;lTimer=tsutil.cTimer((&quot;FINALIZE_TRAINING&quot;,&#10;:&#10;  &quot;Signals&quot;:[lSignal for(lSignal,sigdecs)in self.mSigDecBySplitAndTransform.items()],&quot;Transformations&quot;:[(lSignal,sorted(list(lSigDecs.keys())))for(lSignal,lSigDecs)in self.mSigDecBySplitAndTransform.items()],&quot;Cores&quot;:NCores&#10;))if(self.mOptions.mParallelMode and NCores&gt;1):&#10;  from multiprocessing import Pool&#10;  pool=Pool(NCores)&#10;  for res in pool.imap(run_finalize_training,args):&#10;    (lSignal,lPerfsByModel,lBestModel,lPerfDetails,lModelShortList)=res&#10;    assert(self.mPerfsByModel.get(lSignal)is None)&#10;    self.mPerfsByModel[lSignal]=lPerfsByModel&#10;&#10;    self.mBestModels[lSignal]=lBestModel&#10;    self.mTrPerfDetails[lSignal]=lPerfDetails&#10;    self.mModelShortList[lSignal]=lModelShortList&#10;&#10;  pool.close()&#10;  pool.join()&#10;&#10;else:&#10;  for arg in args:&#10;    res=run_finalize_training(arg)&#10;    (lSignal,lPerfsByModel,lBestModel,lPerfDetails,lModelShortList)=res&#10;    assert(self.mPerfsByModel.get(lSignal)is None)&#10;    self.mPerfsByModel[lSignal]=lPerfsByModel&#10;&#10;    self.mBestModels[lSignal]=lBestModel&#10;    self.mTrPerfDetails[lSignal]=lPerfDetails&#10;    self.mModelShortList[lSignal]=lModelShortList&#10;&#10;&#10;"/>
        <sourcecode id="u5HZUchzwnypK" value="lTransformationEstimator=tstransf.cTransformationEstimator()&#10;lTransformationEstimator.mOptions=self.mOptions&#10;lTransformationEstimator.defineTransformations(iInputDS,iTime,iSignal)&#10;self.mTransformList[(iSignal,iSplit)]=lTransformationEstimator.mTransformList&#10;"/>
        <sourcecode id="u9UHnO7ypi9yR" value="args=[]&#10;&#10;for lSignal in iSignals:&#10;  self.mSigDecBySplitAndTransform[lSignal]={&#10;}&#10;&#10;&#10;lActiveDecompositionTypes=[decomp_type for(decomp_type,active_status)in self.mOptions.mActiveDecompositionTypes.items()if(active_status is True)]&#10;for lSplit in iSplits:&#10;  for lSignal in iSignals:&#10;    self.defineTransformations(iInputDS,lSplit,iTimes[lSignal],lSignal)&#10;&#10;    for transform1 in self.mTransformList[(lSignal,lSplit)]:&#10;      for decomp_type in lActiveDecompositionTypes:&#10;        arg=cTraining_Arg(transform1.get_name(&quot;&quot;))&#10;&#10;        arg.mName=(lSignal,str(lSplit),transform1.get_name(&quot;&quot;),decomp_type)&#10;        arg.mDecompositionType=decomp_type&#10;        arg.mSigDec=cSignalDecompositionOneTransform()&#10;&#10;        arg.mSigDec.mOptions=copy.copy(self.mOptions)&#10;&#10;        arg.mSigDec.mOptions.mCustomSplit=lSplit&#10;        arg.mSplit=lSplit&#10;        arg.mSigDec.mExogenousData=self.mExogenousData[lSignal]&#10;&#10;        arg.mInputDS=iInputDS&#10;&#10;        arg.mTime=iTimes[lSignal]&#10;&#10;        arg.mSignal=lSignal&#10;&#10;        arg.mHorizon=iHorizons[lSignal]&#10;&#10;        arg.mTransformation=transform1&#10;&#10;        arg.mOptions=self.mOptions&#10;&#10;        arg.mExogenousData=self.mExogenousData[lSignal]&#10;&#10;        arg.mResult=None&#10;&#10;        args.append(arg)&#10;&#10;&#10;&#10;&#10;&#10;NCores=min(len(args),self.mOptions.mNbCores)&#10;lTimer=tsutil.cTimer((&quot;SIGNAL_TRAINING&quot;,:&#10;  &quot;Signals&quot;:iSignals,&#10;  &quot;Transformations&quot;:[arg.mName for arg in args],&quot;Cores&quot;:NCores&#10;))if(self.mOptions.mParallelMode and NCores&gt;1):&#10;  from multiprocessing import Pool&#10;  pool=Pool(NCores)&#10;  for res in pool.imap(run_transform_thread,args):&#10;    lSignal=res.mName[0]&#10;    self.mSigDecBySplitAndTransform[lSignal][res.mName]=res.mSigDec&#10;&#10;&#10;  pool.close()&#10;  pool.join()&#10;&#10;else:&#10;  for arg in args:&#10;    res=run_transform_thread(arg)&#10;    lSignal=res.mName[0]&#10;    self.mSigDecBySplitAndTransform[lSignal][res.mName]=res.mSigDec&#10;&#10;&#10;&#10;"/>
        <sourcecode id="uW9wNO8aKBIc7" value="lSigDecByTransform={&#10;}&#10;&#10;for(lSignal,sigdecs)in self.mSigDecBySplitAndTransform.items():&#10;  lBestTransformationName=self.mBestModels[lSignal].mTransformation.get_name(&quot;&quot;)&#10;  for(name,sigdec)in self.mSigDecBySplitAndTransform[lSignal].items():&#10;    if(name==lBestTransformationName):&#10;      for modelname in sigdec.mPerfsByModel.keys():&#10;        sigdec.mPerfsByModel[modelname][0]=modelname&#10;        lSigDecByTransform[lSignal][name]=sigdec&#10;&#10;&#10;&#10;&#10;del self.mSigDecBySplitAndTransform&#10;self.mSigDecBySplitAndTransform=lSigDecByTransform"/>
        <sourcecode id="uZpMOcg2UEsDJ" value="self.mSignalFrame=None&#10;self.mTimeInfo=tsti.cTimeInfo()&#10;self.mTrendFrame=None&#10;self.mTrendPerf=tsperf.cPerf()&#10;&#10;self.mOutName=None&#10;self.mFormula=None&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;"/>
        <sourcecode id="u3wIkWjm2FuXr" value="if(np.isnan(sig[:-1]).any()or np.isinf(sig[:-1]).any()):&#10;  logger=tsutil.get_pyaf_logger()&#10;&#10;  logger.error(&quot;TREND_RESIDUE_WITH_NAN_IN_SIGNAL&quot;+str(sig))&#10;&#10;  raise tsutil.Internal_PyAF_Error(&quot;INVALID_COLUMN _FOR_TREND_RESIDUE ['&quot;+name+&quot;'&quot;)&#10;&#10;&#10;pass&#10;"/>
        <sourcecode id="u1P45xww8kwuZ" value="if(self.mOptions.mDebug):&#10;  self.check_not_nan(self.mTrendFrame[self.mOutName+'_residue'],self.mOutName+'_residue')&#10;&#10;self.mTrendFitPerf=tsperf.cPerf()&#10;&#10;self.mTrendForecastPerf=tsperf.cPerf()&#10;&#10;(lFrameFit,lFrameForecast,lFrameTest)=self.mSplit.cutFrame(self.mTrendFrame)&#10;&#10;self.mTrendFitPerf.computeCriterionValues(lFrameFit[self.mSignal],&#10;lFrameFit[self.mOutName],[self.mTimeInfo.mOptions.mModelSelection_Criterion],self.mOutName)self.mTrendForecastPerf.computeCriterionValues(lFrameForecast[self.mSignal],&#10;lFrameForecast[self.mOutName],[self.mTimeInfo.mOptions.mModelSelection_Criterion],self.mOutName)"/>
        <sourcecode id="uWo0o7fQ0DSno" value="target=df[self.mSignal]&#10;lTrend=df[self.mOutName]&#10;if(self.mDecompositionType in['T+S+R']):&#10;  df[self.mOutName+'_residue']=target-lTrend&#10;&#10;else:&#10;  lTrendWithNoZero=lTrend.apply(lambda x:x if(abs(x)&gt;1e-2)else 1e-2)&#10;  df[self.mOutName+'_residue']=target/lTrendWithNoZero&#10;&#10;"/>
        <sourcecode id="u1ozqqFJxYO3R" value="self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;self.mOutName=self.mSignal+&quot;_&quot;+self.mOutName&#10;&#10;self.mTrendFrame=pd.DataFrame(index=self.mTimeInfo.mSignalFrame.index)&#10;self.mTimeInfo.addVars(self.mTrendFrame)&#10;&#10;"/>
        <sourcecode id="uB25uTDQSfO5L" value="self.fit_specific()&#10;self.mTrendFrame[self.mOutName]=self.compute(self.mTrendFrame)&#10;self.compute_trend_residue(self.mTrendFrame)&#10;"/>
        <sourcecode id="uTB1uSTUM138h" value="df[self.mOutName]=self.compute(df)&#10;self.compute_trend_residue(df)&#10;return df&#10;&#10;"/>
        <sourcecode id="uZfsgUiUADNg6" value="assert(0)&#10;"/>
        <sourcecode id="uwoxvtrSdoE38" value="cAbstractTrend.__init__(self)&#10;&#10;self.mMean=0.0&#10;self.mOutName=&quot;ConstantTrend&quot;&#10;self.mFormula=self.mOutName&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Low&#10;&#10;"/>
        <sourcecode id="u0hlIdKwTrF20" value="self.mMean=self.mSplit.getEstimPart(self.mTrendFrame)[self.mSignal].mean()&#10;"/>
        <sourcecode id="uHXYkRtRB6kOv" value="Y_pred=self.mMean*np.ones_like(df[self.mSignal])&#10;&#10;return Y_pred&#10;"/>
        <sourcecode id="uXg3FMRHMngcO" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;CONSTANT_TREND &quot;+self.mOutName+&quot; &quot;+str(round(self.mMean,6)))&#10;&#10;"/>
        <sourcecode id="udXfxrUBilw66" value="cAbstractTrend.__init__(self)&#10;&#10;self.mDefaultValue=None&#10;self.mOutName=&quot;Lag1Trend&quot;&#10;self.mFormula=self.mOutName&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Low&#10;&#10;"/>
        <sourcecode id="ugz4DYCCscjR1" value="df.loc[df.index[0],series]=self.mDefaultValue&#10;&#10;"/>
        <sourcecode id="uqmmljl4c9Gf6" value="lEstim=self.mSplit.getEstimPart(self.mTrendFrame)&#10;&#10;self.mDefaultValue=lEstim[self.mSignal].iloc[0]&#10;"/>
        <sourcecode id="uOCoPK42mulaO" value="Y_pred=df[self.mSignal].shift(1)&#10;Y_pred.loc[df.index[0]]=self.mDefaultValue&#10;&#10;return Y_pred&#10;"/>
        <sourcecode id="u9ocozO6X6qEe" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;LAG1_TREND &quot;+self.mFormula+&quot; &quot;+str(round(self.mDefaultValue,6)))&#10;&#10;"/>
        <sourcecode id="ucJfJenWxCw6W" value="cAbstractTrend.__init__(self)&#10;&#10;self.mOutName=&quot;MovingAverage&quot;&#10;&#10;self.mWindow=iWindow&#10;&#10;self.mFormula=self.mOutName&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Medium&#10;&#10;"/>
        <sourcecode id="uLOsuiRDes5tK" value="self.mOutName=self.mOutName+&quot;(&quot;+str(self.mWindow)+&quot;)&quot;&#10;&#10;self.mFormula=self.mOutName&#10;&#10;self.mMean=self.mSplit.getEstimPart(self.mTrendFrame)[self.mSignal].mean()&#10;"/>
        <sourcecode id="uzyGBZhuybO8o" value="Y_pred=df[self.mSignal].shift(1).rolling(self.mWindow).mean().fillna(method='bfill')&#10;&#10;Y_pred.fillna(mean,inplace=True)&#10;return Y_pred&#10;"/>
        <sourcecode id="uUQcN5fscdmTt" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;MOVING_AVERAGE_TREND &quot;+self.mFormula+&quot; &quot;+str(self.mWindow))&#10;&#10;"/>
        <sourcecode id="utdyzzKqmqXTB" value="cAbstractTrend.__init__(self)&#10;&#10;self.mOutName=&quot;MovingMedian&quot;&#10;&#10;self.mWindow=iWindow&#10;&#10;self.mFormula=self.mOutName&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.High&#10;&#10;"/>
        <sourcecode id="u9PLSQmjcZ63c" value="self.mOutName=self.mOutName+&quot;(&quot;+str(self.mWindow)+&quot;)&quot;&#10;&#10;self.mFormula=self.mOutName&#10;&#10;self.mMean=self.mSplit.getEstimPart(self.mTrendFrame)[self.mSignal].mean()&#10;"/>
        <sourcecode id="u3EvnL7CIAmbu" value="Y_pred=df[self.mSignal].shift(1).rolling(self.mWindow).median().fillna(method='bfill')&#10;&#10;Y_pred.fillna(mean,inplace=True)&#10;return Y_pred&#10;"/>
        <sourcecode id="uocNp84Y2gUk8" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;MOVING_MEDIAN_TREND &quot;+self.mFormula+&quot; &quot;+str(self.mWindow))&#10;&#10;"/>
        <sourcecode id="u9dENnSbakBur" value="cAbstractTrend.__init__(self)&#10;&#10;self.mTrendRidge=linear_model.Ridge(solver='cholesky',alpha=0.0)&#10;self.mOutName=&quot;LinearTrend&quot;&#10;self.mFormula=self.mOutName&#10;&#10;self.mComplexity=tscomplex.eModelComplexity.Low&#10;&#10;"/>
        <sourcecode id="uX6pq5phofWAs" value="lTrendEstimFrame=self.mSplit.getEstimPart(self.mTrendFrame)&#10;&#10;est_target=lTrendEstimFrame[self.mSignal].values&#10;est_inputs=lTrendEstimFrame[[self.mTimeInfo.mNormalizedTimeColumn]].values&#10;self.mTrendRidge.fit(est_inputs,est_target)&#10;"/>
        <sourcecode id="uYZ7SVPLh4Zv2" value="inputs=df[[self.mTimeInfo.mNormalizedTimeColumn]].values&#10;Y_pred=self.mTrendRidge.predict(inputs)&#10;return Y_pred&#10;"/>
        <sourcecode id="uoRtj1J1CDvuA" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;LINEAR_RIDGE_TREND &quot;+self.mFormula+&quot; &quot;+str((self.mTrendRidge.intercept_.round(6),self.mTrendRidge.coef_.round(6))))&#10;&#10;"/>
        <sourcecode id="udhdtuEWV0lNL" value="cAbstractTrend.__init__(self)&#10;&#10;self.mTrendRidge=linear_model.Ridge(solver='cholesky',alpha=0.0)&#10;self.mOutName=&quot;PolyTrend&quot;&#10;self.mFormula=self.mOutName&#10;self.mComplexity=tscomplex.eModelComplexity.Medium&#10;&#10;"/>
        <sourcecode id="uiYpOWD9lhqpz" value="self.mTrendFrame[self.mTimeInfo.mNormalizedTimeColumn+&quot;_^2&quot;]=self.mTrendFrame[self.mTimeInfo.mNormalizedTimeColumn]**2&#10;&#10;self.mTrendFrame[self.mTimeInfo.mNormalizedTimeColumn+&quot;_^3&quot;]=self.mTrendFrame[self.mTimeInfo.mNormalizedTimeColumn]**3&#10;&#10;lTrendEstimFrame=self.mSplit.getEstimPart(self.mTrendFrame)&#10;&#10;est_target=lTrendEstimFrame[self.mSignal].values&#10;est_inputs=lTrendEstimFrame[&#10;[self.mTimeInfo.mNormalizedTimeColumn,self.mTimeInfo.mNormalizedTimeColumn+&quot;_^2&quot;,self.mTimeInfo.mNormalizedTimeColumn+&quot;_^3&quot;]].values self.mTrendRidge.fit(est_inputs,est_target)&#10;"/>
        <sourcecode id="u4MaEJWYiSDmM" value="df[self.mTimeInfo.mNormalizedTimeColumn+&quot;_^2&quot;]=df[self.mTimeInfo.mNormalizedTimeColumn]**2&#10;&#10;df[self.mTimeInfo.mNormalizedTimeColumn+&quot;_^3&quot;]=df[self.mTimeInfo.mNormalizedTimeColumn]**3&#10;&#10;inputs=df[&#10;[self.mTimeInfo.mNormalizedTimeColumn,self.mTimeInfo.mNormalizedTimeColumn+&quot;_^2&quot;,self.mTimeInfo.mNormalizedTimeColumn+&quot;_^3&quot;]].values Y_pred=self.mTrendRidge.predict(inputs)&#10;return Y_pred&#10;"/>
        <sourcecode id="uh1R285NrRbG1" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;POLYNOMIAL_RIDGE_TREND &quot;+self.mFormula+&quot; &quot;+str((self.mTrendRidge.intercept_.round(6),self.mTrendRidge.coef_.round(6))))&#10;&#10;"/>
        <sourcecode id="uh9nDop24Np8e" value="self.mSignalFrame=None&#10;self.mTimeInfo=tsti.cTimeInfo()&#10;self.mTrendFrame=None&#10;"/>
        <sourcecode id="uNdifeXEbF0tS" value="N=df.shape[0]&#10;&#10;if(N&lt;(12*i)):&#10;  return False&#10;&#10;&#10;return True&#10;&#10;"/>
        <sourcecode id="uN3f1i1RzHbiW" value="self.mTrendList=[]&#10;&#10;if(self.mOptions.mActiveTrends['ConstantTrend']):&#10;  self.mTrendList=[cConstantTrend()]&#10;&#10;&#10;if(self.mOptions.mActiveTrends['Lag1Trend']):&#10;  self.mTrendList=self.mTrendList+[cLag1Trend()]&#10;&#10;&#10;N=self.mSignalFrame.shape[0]&#10;&#10;if(N&gt;1 and self.mOptions.mActiveTrends['LinearTrend']):&#10;  self.mTrendList=self.mTrendList+[cLinearTrend()]&#10;&#10;if(N&gt;2 and self.mOptions.mActiveTrends['PolyTrend']):&#10;  self.mTrendList=self.mTrendList+[cPolyTrend()]&#10;&#10;if(N&gt;2 and self.mOptions.mActiveTrends['MovingAverage']):&#10;  for i in self.mOptions.mMovingAverageLengths:&#10;    if(self.needMovingTrend(self.mSignalFrame,i)):&#10;      self.mTrendList=self.mTrendList+[cMovingAverageTrend(i)]&#10;&#10;&#10;&#10;if(N&gt;2 and self.mOptions.mActiveTrends['MovingMedian']):&#10;  for i in self.mOptions.mMovingMedianLengths:&#10;    if(self.needMovingTrend(self.mSignalFrame,i)):&#10;      self.mTrendList=self.mTrendList+[cMovingMedianTrend(i)]&#10;&#10;&#10;&#10;if(len(self.mTrendList)==0):&#10;  self.mTrendList=[cConstantTrend()]&#10;&#10;&#10;"/>
        <sourcecode id="uUxO7ibqSRz03" value="for trend in self.mTrendList:&#10;  tsplot.decomp_plot(self.mTrendFrame,self.mTimeInfo.mNormalizedTimeColumn,self.mSignal,trend.mOutName,trend.mOutName+'_residue',horizon=self.mTimeInfo.mHorizon)&#10;&#10;&#10;"/>
        <sourcecode id="uGEfOQtjbITFo" value="for trend in self.mTrendList:&#10;  trend.addTrendInputVariables()&#10;&#10;pass&#10;"/>
        <sourcecode id="ukCOsz7mdkz8K" value="if(np.isnan(sig).any()):&#10;  raise tsutil.Internal_PyAF_Error(&quot;Invalid residue_is_nan '&quot;+&#10;  str((name,trend.mDecompositionType,sig.min(),sig.max(),sig.mean(),sig.std()))+&quot;'&quot;)&#10;&#10;if(sig.max()&gt;1.e5):&#10;  raise tsutil.Internal_PyAF_Error(&quot;Invalid residue_too_large '&quot;+&#10;  str((name,trend.mDecompositionType,sig.min(),sig.max(),sig.mean(),sig.std()))+&quot;'&quot;)&#10;&#10;pass&#10;"/>
        <sourcecode id="uVQf0zb53V5BO" value="lTimer=None&#10;if(self.mOptions.mDebugProfile):&#10;  lTimer=tsutil.cTimer((&quot;TRAINING_TRENDS&quot;,:&#10;    &quot;Signal&quot;:self.mTimeInfo.mSignal&#10;  ))&#10;&#10;self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;self.mTrendFrame=pd.DataFrame(index=self.mSignalFrame.index)&#10;self.mTimeInfo.addVars(self.mTrendFrame)&#10;&#10;for trend in self.mTrendList:&#10;  trend.mOptions=self.mOptions&#10;  trend.mDecompositionType=self.mDecompositionType&#10;  trend.mTrendFrame=self.mTrendFrame.copy()&#10;  trend.fit()&#10;&#10;  if(trend.mOptions.mDebugPerformance):&#10;    trend.computePerf()&#10;&#10;&#10;  self.mTrendFrame[trend.mOutName]=trend.mTrendFrame[trend.mOutName]&#10;  self.mTrendFrame[trend.mOutName+&quot;_residue&quot;]=trend.mTrendFrame[trend.mOutName+&quot;_residue&quot;]&#10;  if(self.mOptions.mDebug):&#10;    self.check_residue(trend,self.mTrendFrame[trend.mOutName+&quot;_residue&quot;].values[:-1],&#10;    trend.mOutName+&quot;_residue&quot;)&#10;&#10;&#10;pass&#10;"/>
        <sourcecode id="uCnY1i5AHfq2j" value="self.defineTrends()&#10;&#10;for trend in self.mTrendList:&#10;  trend.mSignalFrame=self.mSignalFrame&#10;&#10;  trend.mTimeInfo=self.mTimeInfo&#10;&#10;  trend.mSplit=self.mSplit&#10;&#10;self.addTrendInputVariables()&#10;&#10;self.estimateTrends()&#10;for trend in self.mTrendList:&#10;  del trend.mTrendFrame&#10;&#10;gc.collect()"/>
        <sourcecode id="uoSMTjU6dJ90R" value="self.mTransformation=transf&#10;&#10;self.mDecompositionType=iDecompType&#10;&#10;self.mTrend=trend&#10;&#10;self.mCycle=cycle&#10;&#10;self.mAR=autoreg&#10;&#10;self.mFitPerformances={&#10;}&#10;&#10;self.mForecastPerformances={&#10;}&#10;&#10;self.mTestPerformances={&#10;}&#10;&#10;self.mOutName=self.mAR.mOutName&#10;&#10;self.mOriginalSignal=self.mTransformation.mOriginalSignal&#10;&#10;self.mTimeInfo=self.mTrend.mTimeInfo&#10;&#10;self.mTime=self.mTimeInfo.mTime&#10;&#10;self.mSignal=self.mTimeInfo.mSignal&#10;&#10;self.mTrainingVersionInfo=self.getVersions()&#10;&#10;"/>
        <sourcecode id="ucaZpOor1mcWg" value="lModelCategory=(self.mTransformation.__class__.__name__,&#10;self.mTrend.__class__.__name__,self.mCycle.__class__.__name__,self.mAR.__class__.__name__)lModelCategory=self.mTransformation.mFormula+&quot;_&quot;+self.mTrend.mFormula+&quot;_&quot;+self.mCycle.mFormula+&quot;_&quot;+self.mAR.mFormula&#10;return str(lModelCategory)&#10;"/>
        <sourcecode id="u40Q8Ct1tm2go" value="lModelTypeComplexity={&#10;&#10;&quot;T+S+R&quot;:tscomplex.eModelComplexity.Low,&quot;TS+R&quot;:tscomplex.eModelComplexity.High,&quot;TSR&quot;:tscomplex.eModelComplexity.High,}&#10;&#10;lComplexity={&#10;'Decomposition':lModelTypeComplexity.get(self.mDecompositionType).value,&#10;'Transformation':self.mTransformation.mComplexity.value,'Trend':self.mTrend.mComplexity.value,'Cycle':self.mCycle.mComplexity.value,'AR':self.mAR.mComplexity.value}&#10;return lComplexity&#10;&#10;"/>
        <sourcecode id="uTccJUCvRZPbn" value="lComplexity=self.getComplexity()&#10;lValues=[str(v)for(k,v)in lComplexity.items()]&#10;lStr=&quot;&quot;.join(sorted(lValues))&#10;return lStr&#10;&#10;"/>
        <sourcecode id="uAeR38TdONj6r" value="lTimer=tsutil.cTimer((&quot;UPDATE_BEST_MODEL_PERFS&quot;,:&#10;  &quot;Signal&quot;:self.mOriginalSignal,&quot;Model&quot;:self.mOutName&#10;))&#10;self.updatePerfs(compute_all_indicators=True)&#10;"/>
        <sourcecode id="uceZ2IGFAGYPe" value="lPredictionIntervalsEstimator=predint.cPredictionIntervalsEstimator()&#10;&#10;lPredictionIntervalsEstimator.mModel=self&#10;&#10;lPredictionIntervalsEstimator.mComputeAllPerfs=compute_all_indicators&#10;lPredictionIntervalsEstimator.computePerformances()&#10;&#10;lForecastColumn=str(self.mOriginalSignal)+&quot;_Forecast&quot;&#10;&#10;self.mFitPerfs=lPredictionIntervalsEstimator.mFitPerformances&#10;self.mForecastPerfs=lPredictionIntervalsEstimator.mForecastPerformances&#10;self.mTestPerfs=lPredictionIntervalsEstimator.mTestPerformances&#10;"/>
        <sourcecode id="uwOLcMkm4YzSG" value="output={&#10;&quot;Fit&quot;::&#10;}&#10;  ,&quot;Forecast&quot;::&#10;&#10;  ,&quot;Test&quot;::&#10;&#10;&#10;&#10;lForecastColumn=str(self.mOriginalSignal)+&quot;_Forecast&quot;&#10;&#10;lCriterion=self.mTimeInfo.mOptions.mModelSelection_Criterion&#10;for h in[1,self.mTimeInfo.mHorizon]:&#10;  lHorizonName=lForecastColumn+&quot;_&quot;+str(h)&#10;&#10;  output[&quot;Fit&quot;][h]=self.mFitPerfs[lHorizonName]&#10;  output[&quot;Forecast&quot;][h]=self.mForecastPerfs[lHorizonName]&#10;  output[&quot;Test&quot;][h]=self.mTestPerfs[lHorizonName]&#10;&#10;return output&#10;"/>
        <sourcecode id="uH8sMNeOlP0YX" value="lAggregated=criteria[0]&#10;return lAggregated&#10;"/>
        <sourcecode id="uov8RICqFJ1i2" value="lCriterion=self.mTimeInfo.mOptions.mModelSelection_Criterion&#10;lForecastColumn=str(self.mOriginalSignal)+&quot;_Forecast&quot;&#10;&#10;(lFitCritData,lForecastCritData,lTestCritData)=([],[],[])&#10;for h in range(self.mTimeInfo.mHorizon):&#10;  lHorizonName=lForecastColumn+&quot;_&quot;+str(h+1)&#10;&#10;  lFitCritData.append(self.mFitPerfs[lHorizonName].get(lCriterion))&#10;  lForecastCritData.append(self.mForecastPerfs[lHorizonName].get(lCriterion))&#10;  lTestCritData.append(self.mTestPerfs[lHorizonName].get(lCriterion))&#10;&#10;lAggFitCrit=self.aggregate_criteria(lFitCritData)&#10;lAggForecastCrit=self.aggregate_criteria(lForecastCritData)&#10;lAggTestCrit=self.aggregate_criteria(lTestCritData)&#10;return(lAggFitCrit,lAggForecastCrit,lAggTestCrit)&#10;"/>
        <sourcecode id="ulIRcBxebyAy6" value="if(self.mTimeInfo.mOptions.mAddPredictionIntervals):&#10;  lTimer=tsutil.cTimer((&quot;COMPUTE_PREDICTION_INTERVALS&quot;,:&#10;    &quot;Signal&quot;:self.mOriginalSignal&#10;  ))&#10;  self.mPredictionIntervalsEstimator=predint.cPredictionIntervalsEstimator()&#10;&#10;  self.mPredictionIntervalsEstimator.mModel=self&#10;&#10;  self.mPredictionIntervalsEstimator.mComputeAllPerfs=True&#10;&#10;  self.mPredictionIntervalsEstimator.computePerformances()&#10;&#10;&#10;"/>
        <sourcecode id="uxLJiNvvLztL8" value="if(self.mDecompositionType in['TS+R']):&#10;  return self.mTrend.mFormula+&quot; * &quot;+self.mCycle.mFormula+&quot; + &quot;+self.mAR.mFormula&#10;&#10;if(self.mDecompositionType in['TSR']):&#10;  return self.mTrend.mFormula+&quot; * &quot;+self.mCycle.mFormula+&quot; * &quot;+self.mAR.mFormula&#10;&#10;return self.mTrend.mFormula+&quot; + &quot;+self.mCycle.mFormula+&quot; + &quot;+self.mAR.mFormula&#10;"/>
        <sourcecode id="uEQkFyaDtrRNc" value="logger=tsutil.get_pyaf_logger()&#10;&#10;lSignal=self.mTrend.mSignalFrame[self.mOriginalSignal]&#10;&#10;lStr1=&quot;SignalVariable='&quot;+self.mOriginalSignal+&quot;'&quot;&#10;&#10;lStr1+=&quot; Length=&quot;+str(lSignal.shape[0])+&quot; &quot;&#10;&#10;lStr1+=&quot; Min=&quot;+to_str(np.min(lSignal))+&quot; Max=&quot;+to_str(np.max(lSignal))+&quot; &quot;&#10;&#10;lStr1+=&quot; Mean=&quot;+to_str(np.mean(lSignal))+&quot; StdDev=&quot;+to_str(np.std(lSignal))&#10;&#10;lSignal=self.mTrend.mSignalFrame[self.mSignal]&#10;&#10;lStr2=&quot;TransformedSignalVariable='&quot;+self.mSignal+&quot;'&quot;&#10;&#10;lStr2+=&quot; Min=&quot;+to_str(np.min(lSignal))+&quot; Max=&quot;+to_str(np.max(lSignal))+&quot; &quot;&#10;&#10;lStr2+=&quot; Mean=&quot;+to_str(np.mean(lSignal))+&quot; StdDev=&quot;+to_str(np.std(lSignal))&#10;&#10;logger.info(&quot;SIGNAL_DETAIL_ORIG &quot;+lStr1)&#10;&#10;logger.info(&quot;SIGNAL_DETAIL_TRANSFORMED &quot;+lStr2)&#10;&#10;if(self.mAR.mExogenousInfo):&#10;  logger.info(&quot;EXOGENOUS_DATA &quot;+str(self.mAR.mExogenousInfo.mExogenousVariables))&#10;&#10;&#10;return(lStr1,lStr2)&#10;&#10;"/>
        <sourcecode id="u9CiSgmNHtCGz" value="logger=tsutil.get_pyaf_logger()&#10;&#10;lForecastColumn=str(self.mOriginalSignal)+&quot;_Forecast&quot;&#10;&#10;lCriterion=self.mTimeInfo.mOptions.mModelSelection_Criterion&#10;for h in[1,self.mTimeInfo.mHorizon]:&#10;  lHorizonName=lForecastColumn+&quot;_&quot;+str(h)&#10;&#10;  lDict_Fit_H=self.mFitPerfs[lHorizonName].to_dict_summary(lCriterion)&#10;  logger.info(&quot;MODEL_PERFS Fit STEP=&quot;+str(h)+&quot; &quot;+str(lDict_Fit_H))&#10;&#10;  lDict_Forecast_H=self.mForecastPerfs[lHorizonName].to_dict_summary(lCriterion)&#10;  logger.info(&quot;MODEL_PERFS Forecast STEP=&quot;+str(h)+&quot; &quot;+str(lDict_Forecast_H))&#10;&#10;  lDict_Test_H=self.mTestPerfs[lHorizonName].to_dict_summary(lCriterion)&#10;  logger.info(&quot;MODEL_PERFS Test STEP=&quot;+str(h)+&quot; &quot;+str(lDict_Test_H))&#10;&#10;&#10;"/>
        <sourcecode id="u8f7qKXuNy1pt" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;DECOMPOSITION_TYPE '&quot;+self.mDecompositionType+&quot;'&quot;)&#10;&#10;logger.info(&quot;BEST_TRANSOFORMATION_TYPE '&quot;+self.mTransformation.get_name(&quot;&quot;)+&quot;'&quot;)&#10;&#10;logger.info(&quot;BEST_DECOMPOSITION  '&quot;+self.mOutName+&quot;' [&quot;+self.getFormula()+&quot;]&quot;)&#10;&#10;logger.info(&quot;TREND_DETAIL '&quot;+self.mTrend.mOutName+&quot;' [&quot;+self.mTrend.mFormula+&quot;]&quot;)&#10;&#10;logger.info(&quot;CYCLE_DETAIL '&quot;+self.mCycle.mOutName+&quot;' [&quot;+self.mCycle.mFormula+&quot;]&quot;)&#10;&#10;logger.info(&quot;AUTOREG_DETAIL '&quot;+self.mAR.mOutName+&quot;' [&quot;+self.mAR.mFormula+&quot;]&quot;)&#10;&#10;"/>
        <sourcecode id="uWrQCUXIypA4r" value="logger=tsutil.get_pyaf_logger()&#10;&#10;lComplexityStr=self.getComplexity_as_ordering_string()&#10;logger.info(&quot;MODEL_COMPLEXITY &quot;+str(self.getComplexity())+&quot; [&quot;+lComplexityStr+&quot;]&quot;)&#10;&#10;logger.info(&quot;SIGNAL_TRANSFORMATION_DETAIL_START&quot;)&#10;&#10;self.mTransformation.dump_values()&#10;&#10;logger.info(&quot;SIGNAL_TRANSFORMATION_DETAIL_END&quot;)&#10;&#10;logger.info(&quot;TREND_DETAIL_START&quot;)&#10;&#10;self.mTrend.dump_values()&#10;&#10;logger.info(&quot;TREND_DETAIL_END&quot;)&#10;&#10;logger.info(&quot;CYCLE_MODEL_DETAIL_START&quot;)&#10;&#10;self.mCycle.dump_values()&#10;&#10;logger.info(&quot;CYCLE_MODEL_DETAIL_END&quot;)&#10;&#10;logger.info(&quot;AR_MODEL_DETAIL_START&quot;)&#10;&#10;self.mAR.dumpCoefficients()&#10;&#10;logger.info(&quot;AR_MODEL_DETAIL_END&quot;)&#10;&#10;"/>
        <sourcecode id="uH2QBjPIdrL78" value="logger=tsutil.get_pyaf_logger()&#10;&#10;logger.info(&quot;TIME_DETAIL &quot;+self.mTrend.mTimeInfo.info())&#10;&#10;self.signal_info()&#10;self.decomposition_info()&#10;self.perf_info()&#10;self.decomposition_detail_info()&#10;"/>
        <sourcecode id="uaXBLmbKg6qFv" value="if(self.mDecompositionType in['TS+R']):&#10;  return iTrendValue*iCycleValue+iARValue&#10;&#10;if(self.mDecompositionType in['TSR']):&#10;  lTrendValue=iTrendValue.clip(-100,100)&#10;  lCycleValue=iCycleValue.clip(-100,100)&#10;  lARValue=iARValue.clip(-100,100)&#10;  return lTrendValue*lCycleValue*lARValue&#10;&#10;return iTrendValue+iCycleValue+iARValue&#10;"/>
        <sourcecode id="uqplocyB1swtG" value="assert(self.mTime in df.columns)&#10;assert(self.mOriginalSignal in df.columns)&#10;lPrefix=self.mSignal+&quot;_&quot;&#10;&#10;df1=df&#10;&#10;df1=self.mTransformation.transformDataset(df1)&#10;&#10;df1=self.mTimeInfo.transformDataset(df1)&#10;&#10;df1=self.mTrend.transformDataset(df1)&#10;&#10;df1=self.mCycle.transformDataset(df1)&#10;&#10;df1=self.mAR.transformDataset(df1,horizon_index)&#10;&#10;df2=df1&#10;&#10;lTrendColumn=df2[self.mTrend.mOutName]&#10;lCycleColumn=df2[self.mCycle.mOutName]&#10;lARColumn=df2[self.mAR.mOutName]&#10;lSignal=df2[self.mSignal]&#10;if(not perf_mode):&#10;  df2[self.mOriginalSignal+'_Transformed']=lSignal&#10;&#10;  df2[lPrefix+'Trend']=lTrendColumn&#10;&#10;  df2[lPrefix+'Trend_residue']=df2[self.mCycle.mTrend_residue_name]&#10;  df2[lPrefix+'Cycle']=lCycleColumn&#10;&#10;  df2[lPrefix+'Cycle_residue']=df2[self.mCycle.getCycleResidueName()]&#10;&#10;  df2[lPrefix+'AR']=lARColumn&#10;&#10;  df2[lPrefix+'AR_residue']=df2[self.mAR.mOutName+'_residue']&#10;&#10;&#10;lPrefix2=str(self.mOriginalSignal)+&quot;_&quot;&#10;&#10;df2[lPrefix+'TransformedForecast']=self.compute_model_forecast(lTrendColumn,lCycleColumn,lARColumn)&#10;df2[lPrefix2+'Forecast']=self.mTransformation.invert(df2[lPrefix+'TransformedForecast'])&#10;&#10;if(not perf_mode):&#10;  df2[lPrefix+'TransformedResidue']=lSignal-df2[lPrefix+'TransformedForecast']&#10;  lOriginalSignal=df2[self.mOriginalSignal]&#10;  df2[lPrefix2+'Residue']=lOriginalSignal-df2[lPrefix2+'Forecast']&#10;&#10;df2.reset_index(drop=True,inplace=True)&#10;&#10;return df2&#10;&#10;"/>
        <sourcecode id="urbdgC4rd9VGW" value="N0=df.shape[0]&#10;&#10;df1=self.forecastOneStepAhead(df,1)&#10;lForecastColumnName=str(self.mOriginalSignal)+&quot;_Forecast&quot;&#10;&#10;for h in range(0,iHorizon-1):&#10;  N=df1.shape[0]&#10;&#10;  lPos=df1.index[N-1]&#10;&#10;  lSignal=df1.loc[lPos,lForecastColumnName]&#10;&#10;  df1.loc[lPos,self.mOriginalSignal]=lSignal&#10;&#10;  df1=df1[[self.mTime,self.mOriginalSignal,self.mTimeInfo.mRowNumberColumn,self.mTimeInfo.mNormalizedTimeColumn]]&#10;&#10;  df1=self.forecastOneStepAhead(df1,h+2)&#10;&#10;assert((N0+iHorizon)==df1.shape[0])&#10;N1=df1.shape[0]&#10;&#10;lPrefix=self.mSignal+&quot;_&quot;&#10;&#10;lFieldsToErase=[self.mOriginalSignal,self.mSignal,self.mOriginalSignal+&quot;_Transformed&quot;,&#10;self.mTrend.mOutName+'_residue',lPrefix+'Trend_residue',self.mCycle.mOutName+'_residue',lPrefix+'Cycle_residue',self.mAR.mOutName+'_residue',lPrefix+'AR_residue',lPrefix+'TransformedResidue',str(self.mOriginalSignal)+'_Residue']df1.loc[N1-iHorizon:N1,lFieldsToErase]=np.nan&#10;return df1&#10;"/>
        <sourcecode id="uXAkDeyxcdmGT" value="df1=self.forecast_all_horizons(df,iHorizon)&#10;if(self.mTimeInfo.mOptions.mAddPredictionIntervals):&#10;  df1=self.addPredictionIntervals(df,df1,iHorizon)&#10;&#10;  self.addForecastQuantiles(df,df1,iHorizon)&#10;&#10;&#10;if(self.mTimeInfo.mOptions.mForecastRectifier is not None):&#10;  df1=self.applyForecastRectifier(df1)&#10;&#10;return df1&#10;"/>
        <sourcecode id="uaoLBNZHQEUc4" value="df1=df&#10;&#10;if(self.mTimeInfo.mOptions.mForecastRectifier==&quot;relu&quot;):&#10;  lForecastColumnName=str(self.mOriginalSignal)+&quot;_Forecast&quot;&#10;&#10;  df1[lForecastColumnName]=df1[lForecastColumnName].apply(lambda x:max(x,0))&#10;&#10;return df1&#10;"/>
        <sourcecode id="uQotYnNIeX509" value="lSignalColumn=self.mOriginalSignal&#10;&#10;N=iInputDS.shape[0]&#10;&#10;lForecastColumn=str(lSignalColumn)+&quot;_Forecast&quot;&#10;&#10;lLowerBoundName=lForecastColumn+'_Lower_Bound'&#10;lUpperBoundName=lForecastColumn+'_Upper_Bound'&#10;&#10;iForecastFrame[lLowerBoundName]=np.nan&#10;&#10;iForecastFrame[lUpperBoundName]=np.nan&#10;&#10;lConfidence=1.96&#10;&#10;lHorizon=min(iHorizon,self.mTimeInfo.mHorizon)&#10;&#10;lWidths=[lConfidence*self.mPredictionIntervalsEstimator.mForecastPerformances[lForecastColumn+&quot;_&quot;+str(h+1)].mL2&#10;for h in range(0,self.mTimeInfo.mHorizon)]lWidths=(lWidths+[np.nan]*iHorizon)[:iHorizon]&#10;lForcastValues=iForecastFrame.loc[N:N+iHorizon,lForecastColumn]&#10;iForecastFrame.loc[N:N+iHorizon,lLowerBoundName]=lForcastValues-lWidths&#10;iForecastFrame.loc[N:N+iHorizon,lUpperBoundName]=lForcastValues+lWidths&#10;return iForecastFrame&#10;&#10;"/>
        <sourcecode id="uXR9hxbSuFpxD" value="lSignalColumn=self.mOriginalSignal&#10;&#10;N=iInputDS.shape[0]&#10;&#10;lForecastColumn=str(lSignalColumn)+&quot;_Forecast&quot;&#10;&#10;lQuantileName=lForecastColumn+&quot;_Quantile_&quot;&#10;lHorizon=min(iHorizon,self.mTimeInfo.mHorizon)&#10;&#10;lPerfs=[self.mPredictionIntervalsEstimator.mForecastPerformances[lForecastColumn+&quot;_&quot;+str(h+1)]&#10;for h in range(0,self.mTimeInfo.mHorizon)]lForcastValues=iForecastFrame.loc[N:N+iHorizon,lForecastColumn]&#10;lQuantiles=self.mPredictionIntervalsEstimator.mForecastPerformances[lForecastColumn+&quot;_1&quot;].mErrorQuantiles.keys()&#10;lQuantiles=sorted(lQuantiles)&#10;for q in lQuantiles:&#10;  iForecastFrame[lQuantileName+str(q)]=np.nan&#10;  lQuants=[lPerf.mErrorQuantiles[q]for lPerf in lPerfs]&#10;  lQuants=(lQuants+[np.nan]*iHorizon)[:iHorizon]&#10;  iForecastFrame.loc[N:N+iHorizon,lQuantileName+str(q)]=lForcastValues.values+np.array(lQuants)&#10;&#10;return iForecastFrame&#10;&#10;"/>
        <sourcecode id="u2xtAQ4RLbK6g" value="lPrefix=self.mSignal+&quot;_&quot;&#10;&#10;lTime=self.mTimeInfo.mNormalizedTimeColumn&#10;&#10;tsplot.decomp_plot(df,&#10;lTime,lPrefix+'Signal',lPrefix+'Forecast',lPrefix+'Residue',horizon=self.mTimeInfo.mHorizon,title=self.mOriginalSignal+&quot; Forecasts&quot;)&#10;"/>
        <sourcecode id="ulPiooPlpiGc8" value="dict1={&#10;}&#10;&#10;&#10;d1={&#10;&quot;Time&quot;:self.mTimeInfo.to_dict(),&#10;&quot;Signal&quot;:self.mOriginalSignal,&quot;Training_Signal_Length&quot;:self.mTimeInfo.mSignalFrame.shape[0]}&#10;&#10;dict1[&quot;Dataset&quot;]=d1&#10;&#10;lTransformation=self.mTransformation.mFormula&#10;&#10;d2={&#10;&quot;Best_Decomposition&quot;:self.mOutName,&#10;&quot;Signal_Decomposition_Type&quot;:self.mDecompositionType,&quot;Signal_Transoformation&quot;:lTransformation,&quot;Trend&quot;:self.mTrend.mFormula,&quot;Cycle&quot;:self.mCycle.mFormula,&quot;AR_Model&quot;:self.mAR.mFormula,}&#10;&#10;dict1[&quot;Model&quot;]=d2&#10;&#10;dict1[&quot;Complexity&quot;]=self.getComplexity()&#10;lCriterion=self.mTimeInfo.mOptions.mModelSelection_Criterion&#10;dict1[&quot;Model_Selection_Criterion&quot;]=lCriterion&#10;lPerfs={&#10;}&#10;&#10;lForecastColumn=str(self.mOriginalSignal)+&quot;_Forecast&quot;&#10;&#10;for h in[1,self.mTimeInfo.mHorizon]:&#10;  lHorizonName=lForecastColumn+&quot;_&quot;+str(h)&#10;&#10;  lPerfs[h]=self.mForecastPerfs[lHorizonName].to_dict()&#10;&#10;dict1[&quot;Model_Performance&quot;]=lPerfs&#10;&#10;if(iWithOptions):&#10;  dict1[&quot;Options&quot;]=self.mTimeInfo.mOptions.__dict__&#10;&#10;return dict1&#10;&#10;"/>
        <sourcecode id="uOyc0ICQLtThk" value="lInput=self.mTrend.mSignalFrame&#10;&#10;lOutput=self.forecast(lInput,self.mTimeInfo.mHorizon)&#10;&#10;return lOutput&#10;"/>
        <sourcecode id="ulvZzBEX2Z753" value="df=iOutputDF&#10;if(df is None):&#10;  df=self.getForecastDatasetForPlots()&#10;&#10;&#10;lTime=self.mTimeInfo.mTime&#10;&#10;lPrefix=self.mSignal+&quot;_&quot;&#10;&#10;lPrefix2=str(self.mOriginalSignal)+&quot;_&quot;&#10;&#10;if(name is not None):&#10;  tsplot.decomp_plot(df,lTime,self.mSignal,lPrefix+'Trend',lPrefix+'Trend_residue',name=name+&quot;_Trend&quot;,format=format,horizon=self.mTimeInfo.mHorizon,title=&quot;Trend\n&quot;+self.mTrend.mOutName)&#10;&#10;  tsplot.decomp_plot(df,lTime,lPrefix+'Trend_residue',lPrefix+'Cycle',lPrefix+'Cycle_residue',name=name+&quot;_Cycle&quot;,format=format,horizon=self.mTimeInfo.mHorizon,title=&quot;Cycle\n&quot;+self.mCycle.mOutName)&#10;&#10;  tsplot.decomp_plot(df,lTime,lPrefix+'Cycle_residue',lPrefix+'AR',lPrefix+'AR_residue',name=name+&quot;_AR&quot;,format=format,horizon=self.mTimeInfo.mHorizon,title=&quot;AR\n&quot;+self.mAR.mOutName)&#10;&#10;  tsplot.decomp_plot(df,lTime,self.mSignal,lPrefix+'TransformedForecast',lPrefix+'TransformedResidue',name=name+&quot;_TransformedForecast&quot;,format=format,horizon=self.mTimeInfo.mHorizon,title=&quot;Transformed Signal Forecast\n&quot;+self.getFormula())&#10;&#10;  tsplot.decomp_plot(df,lTime,self.mOriginalSignal,lPrefix2+'Forecast',lPrefix2+'Residue',name=name+&quot;_Forecast&quot;,format=format,horizon=self.mTimeInfo.mHorizon,title=&quot;Signal Forecast\n&quot;+self.mOutName)&#10;&#10;&#10;else:&#10;  tsplot.decomp_plot(df,lTime,self.mSignal,lPrefix+'Trend',lPrefix+'Trend_residue',horizon=self.mTimeInfo.mHorizon,title=&quot;Trend\n&quot;+self.mTrend.mOutName)&#10;&#10;  tsplot.decomp_plot(df,lTime,lPrefix+'Trend_residue',lPrefix+'Cycle',lPrefix+'Cycle_residue',horizon=self.mTimeInfo.mHorizon,title=&quot;Cycle\n&quot;+self.mCycle.mOutName)&#10;&#10;  tsplot.decomp_plot(df,lTime,lPrefix+'Cycle_residue',lPrefix+'AR',lPrefix+'AR_residue',horizon=self.mTimeInfo.mHorizon,title=&quot;AR\n&quot;+self.mAR.mOutName)&#10;&#10;  tsplot.decomp_plot(df,lTime,self.mSignal,lPrefix+'TransformedForecast',lPrefix+'TransformedResidue',horizon=self.mTimeInfo.mHorizon,title=&quot;Transformed Signal Forecast\n&quot;+self.getFormula())&#10;&#10;  tsplot.decomp_plot(df,lTime,self.mOriginalSignal,lPrefix2+'Forecast',lPrefix2+'Residue',horizon=self.mTimeInfo.mHorizon,title=&quot;Signal Forecast\n&quot;+self.mOutName)&#10;&#10;&#10;"/>
        <sourcecode id="uNrPBWFuBmF8v" value="lTitle=iPrefix+&quot;\nModel = &quot;+self.mOutName+&quot;\n&quot;&#10;lCriterion=self.mTimeInfo.mOptions.mModelSelection_Criterion&#10;lForecastColumn=str(self.mOriginalSignal)+&quot;_Forecast&quot;&#10;&#10;for h in[1,self.mTimeInfo.mHorizon]:&#10;  lHorizonName=lForecastColumn+&quot;_&quot;+str(h)&#10;&#10;  lPerf=self.mForecastPerfs[lHorizonName]&#10;  lTitle=lTitle+&quot;MAPE_&quot;+str(h)+&quot; = &quot;+str(lPerf.mMAPE)+&quot; &quot;&#10;  if(lCriterion!=&quot;MAPE&quot;):&#10;    lTitle=lTitle+lCriterion+&quot;_&quot;+str(h)+&quot; = &quot;+str(lPerf.getCriterionValue(lCriterion))+&quot; &quot;&#10;&#10;&#10;return lTitle&#10;"/>
        <sourcecode id="u01lwKFr7u72Q" value="lOutput=self.getForecastDatasetForPlots()&#10;&#10;self.plotResidues(name=name,format=format,iOutputDF=lOutput)&#10;&#10;lPrefix=str(self.mOriginalSignal)+&quot;_&quot;&#10;&#10;lForecastColumn=lPrefix+'Forecast'&#10;&#10;lTime=self.mTimeInfo.mTime&#10;&#10;lOutput.set_index(lTime,inplace=True,drop=False)&#10;&#10;lTitle=self.get_title_details_for_plots(&quot;Prediction Intervals&quot;)&#10;tsplot.prediction_interval_plot(lOutput,&#10;lTime,self.mOriginalSignal,lForecastColumn,lForecastColumn+'_Lower_Bound',lForecastColumn+'_Upper_Bound',name=name,format=format,horizon=self.mTimeInfo.mHorizon,title=lTitle)&#10;if(self.mTimeInfo.mOptions.mAddPredictionIntervals):&#10;  lQuantiles=self.mPredictionIntervalsEstimator.mForecastPerformances[lForecastColumn+&quot;_1&quot;].mErrorQuantiles.keys()&#10;  lQuantiles=sorted(lQuantiles)&#10;  tsplot.quantiles_plot(lOutput,&#10;  lTime,self.mOriginalSignal,lForecastColumn,lQuantiles,name=name,format=format,horizon=self.mTimeInfo.mHorizon,title=&quot;Forecast_Quantiles\n&quot;+self.mOutName)&#10;&#10;"/>
        <sourcecode id="uiZNk4AsY9Aur" value="lDict={&#10;}&#10;&#10;&#10;df=self.getForecastDatasetForPlots()&#10;&#10;lTime=self.mTime&#10;&#10;lSignalColumn=self.mOriginalSignal&#10;&#10;lPrefix=self.mSignal+&quot;_&quot;&#10;&#10;lPrefix2=str(self.mOriginalSignal)+&quot;_&quot;&#10;&#10;lDict[&quot;Trend&quot;]=tsplot.decomp_plot_as_png_base64(df,lTime,self.mSignal,lPrefix+'Trend',lPrefix+'Trend_residue',name=&quot;trend&quot;,horizon=self.mTimeInfo.mHorizon,title=&quot;Trend\n&quot;+self.mTrend.mOutName)&#10;&#10;lDict[&quot;Cycle&quot;]=tsplot.decomp_plot_as_png_base64(df,lTime,lPrefix+'Trend_residue',lPrefix+'Cycle',lPrefix+'Cycle_residue',name=&quot;cycle&quot;,horizon=self.mTimeInfo.mHorizon,title=&quot;Cycle\n&quot;+self.mCycle.mOutName)&#10;&#10;lDict[&quot;AR&quot;]=tsplot.decomp_plot_as_png_base64(df,lTime,lPrefix+'Cycle_residue',lPrefix+'AR',lPrefix+'AR_residue',name=&quot;AR&quot;,horizon=self.mTimeInfo.mHorizon,title=&quot;AR\n&quot;+self.mAR.mOutName)&#10;&#10;lDict[&quot;TransformedForecast&quot;]=tsplot.decomp_plot_as_png_base64(df,lTime,self.mSignal,lPrefix+'TransformedForecast',lPrefix+'TransformedResidue',name=&quot;TransformedForecast&quot;,horizon=self.mTimeInfo.mHorizon,title=&quot;Transformed Signal Forecast\n&quot;+self.getFormula())&#10;&#10;lDict[&quot;Forecast&quot;]=tsplot.decomp_plot_as_png_base64(df,lTime,lSignalColumn,lPrefix2+'Forecast',lPrefix2+'Residue',name=&quot;forecast&quot;,horizon=self.mTimeInfo.mHorizon,title=&quot;Signal Forecast\n&quot;+self.mOutName)&#10;&#10;lDict[&quot;Prediction_Intervals&quot;]=self.getPredictionIntervalPlot(df)&#10;if(self.mTimeInfo.mOptions.mAddPredictionIntervals):&#10;lDict[&quot;Forecast_Quantiles&quot;]=self.getForecastQuantilesPlot(df)return lDict&#10;&#10;"/>
        <sourcecode id="u3FBO4zXvlqc2" value="lOutput=df if df is not None else self.getForecastDatasetForPlots()&#10;&#10;lPrefix=self.mOriginalSignal+&quot;_&quot;&#10;&#10;lTime=self.mTime&#10;&#10;lForecastColumn=lPrefix+'Forecast'&#10;&#10;lQuantiles=self.mPredictionIntervalsEstimator.mForecastPerformances[lForecastColumn+&quot;_1&quot;].mErrorQuantiles.keys()&#10;lQuantiles=sorted(lQuantiles)&#10;return tsplot.quantiles_plot_as_png_base64(lOutput,&#10;lTime,self.mOriginalSignal,lForecastColumn,lQuantiles,name=&quot;Forecast_Quantiles [&quot;+self.mOutName+&quot;]&quot;,format=format,horizon=self.mTimeInfo.mHorizon,title=&quot;Forecast_Quantiles\n&quot;+self.mOutName)&#10;"/>
        <sourcecode id="uSyhsb9gbL8BQ" value="lVersionDict=tsutil.getVersions()&#10;&#10;return lVersionDict&#10;&#10;"/>
        <sourcecode id="ug2D6e50zibgw" value="self.mTrend.mSignalFrame=self.mTrend.mSignalFrame[[self.mTime,self.mOriginalSignal,self.mSignal]].copy()&#10;gc.collect()"/>
      </codegenerator>
    </codegeneration>
  </xmi:Extension>
</xmi:XMI>
