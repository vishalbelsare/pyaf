<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="2.1" xmlns:xmi="http://schema.omg.org/spec/XMI/2.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:uml="http://schema.omg.org/spec/UML/2.1">
  <xmi:Documentation exporter="umbrello uml modeller 2.37.3 (Applications 22.12.3) http://umbrello.kde.org" exporterVersion="2.0.4"/>
  <uml:Model xmi:id="m1" name="UML Model">
    <packagedElement xmi:type="uml:Stereotype" xmi:id="folder" name="folder"/>
    <packagedElement xmi:type="uml:Stereotype" xmi:id="dataType" name="dataType"/>
    <packagedElement xmi:type="uml:Stereotype" xmi:id="constructor" name="constructor"/>
    <packagedElement xmi:type="uml:Model" xmi:id="Logical_View" name="Logical View">
      <uml:Package xmi:id="Datatypes" name="Datatypes" stereotype="folder">
        <packagedElement xmi:type="uml:DataType" xmi:id="utltd0oYDqkOo" name="array" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uQ0BSKINVuweD" name="bool" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="un1B0hysBdRCi" name="tuple" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uHQ4DK8ATZDBs" name="float" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="u6t9jgUOzQsmh" name="int" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uPeauoMgBXsNO" name="list" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="u5X8zQLHtddCi" name="long" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="u3oJvBWH8hTVE" name="dict" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uJAtWLWlCcj5E" name="object" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uFNR7e0FOCuLt" name="set" stereotype="dataType"/>
        <packagedElement xmi:type="uml:DataType" xmi:id="uP6qE7iac1f7k" name="str" stereotype="dataType"/>
      </uml:Package>
      <packagedElement xmi:type="uml:Class" xmi:id="uOkC0tcBampbP" name="cSignalGrouping">
        <generalization xmi:type="uml:Generalization" xmi:id="uXNwreHRfHU5C" general="uLZMhhUOKu7qa"/>
        <generalization xmi:type="uml:Generalization" xmi:id="u6nTelmIou0vC" general="u9OLW1Sy03Qlk"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ufCvwqXpNl2OJ" name="mLabels2Tuples" type="u3oJvBWH8hTVE" initialValue="{}"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uZQ3I24wFwN1L" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uQiT1opG7hv7c" name="tuple_to_string" comment="print(k , &quot;=&gt;&quot; , str1);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uP7ftUHJMoNor" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="utb13Djss163J" name="k" visibility="private" type="ul9rgEQWjWHEh" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uBn97K4q9icbq" name="add_level" comment="self.tuple_to_string(group); print(&quot;STRUCTURE_LEVEL&quot; , level, self.mStructure[level]);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="upvdpldsUvuHS" name="previous_level" visibility="private" type="u38BDRt0Igz8M" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uy0J93n63jf8b" name="create_HierarchicalStructure" comment="lGroups = {}; lGroups[&quot;State&quot;] = [&quot;NSW&quot;,&quot;VIC&quot;,&quot;QLD&quot;,&quot;SA&quot;,&quot;WA&quot;,&quot;NT&quot;,&quot;ACT&quot;,&quot;TAS&quot;]; lGroups[&quot;Gender&quot;] = [&quot;female&quot;,&quot;male&quot;]; lHierarchy['GroupOrder']= [&quot;State&quot; , &quot;Gender&quot;]; print(prod); prod = itertools.product(['a' , 'b'] , ['1' , '2'] , ['cc' , 'dd']); print(&quot;PRODUCT_DETAIL&quot;, k); Grouping genrates all possible group combinations. Not all columns are mandatory.  print(&quot;STRUCTURE_LEVEL&quot; , level, self.mStructure[level]); Stabilize the order of nodes print(&quot;STRUCTURE&quot;, self.mStructure);"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="uNHU3eupgTOKr" name="sighier">
        <packagedElement xmi:type="uml:Class" xmi:id="uLZMhhUOKu7qa" name="cSignalHierarchy"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="u9OLW1Sy03Qlk" name="cSignalHierarchy">
        <ownedAttribute xmi:type="uml:Property" xmi:id="uoVW7oyjyuISw" name="mDateColumn" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uDErgHzywpLx9" name="mSignal" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uzgamJBbi4Ma6" name="mHorizon" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="ueKP154Cr74Mr" name="mExogenousData" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uckiMg3JL9ni7" name="mTrainingDataset" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uEBaG6MP7pJVP" name="mOptions" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uxb6sJAg2Nqjc" name="mLevels" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="u7uNb5UyfC7JJ" name="mStructure" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uLvl85dOemWKn" name="mSummingMatrix" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uwItxd5V3G67q" name="mModels" type="uJAtWLWlCcj5E" initialValue="None"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uqJ83zcDEUVCW" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uwCxM1WjQDUzf" name="info">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u8TkZz57F6kqU" type="uP6qE7iac1f7k" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="unCtNYYMEo2x5" name="get_exogenous_data" comment="A signal is a hierarchy node same data for all signals one exogenous data by signal">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uAAgzcVZm643i" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ud1LJwSNH0Ayh" name="signal" visibility="private" type="uDfZDSWekB3s5" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="urP8nVCdX8srr" name="to_dict">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u4mlX1Lo4DRmw" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uch8X5HmbatOF" name="iWithOptions" visibility="private" type="uQ0BSKINVuweD" value="False"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u4awpgYnP0IZg" name="discard_nans_in_aggregate_signals">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ulvFuplrymOLO" type="uQ0BSKINVuweD" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="unizFDc8P7pZ8" name="create_HierarchicalStructure" comment="Stabilize the order of nodes print(self.mStructure);"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u3n9J5ojxdWUR" name="create_SummingMatrix" comment="print(self.mSummingMatrix); print(self.mSummingMatrixInverse);"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uWYNyjb6YyQo8" name="checkData" comment="print(type1) level 0 is the original/physical columns print(type2)">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uRCx6sWqYzMSq" name="df" visibility="private" type="uXY5fSBpqjprS" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u5ZcjDxwqm40h" name="create_all_levels_dataset" comment="level 0 is the original/physical columns">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uPeicR5w85EEs" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u5Z7wOtrD7Zof" name="df" visibility="private" type="uGRZ0Apil22SJ" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uKaF5m5Sar4wi" name="addVars">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="upI191bE87Svl" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uBBf6K9XrvldD" name="df" visibility="private" type="uNGyXDZD7D3JN" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uAO4aO1zqh334" name="transformDataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uoN1Yc63ul9xB" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uzlZ5tkzGNrQG" name="df" visibility="private" type="usWXhePzVF8CH" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uM2XZxsX2N6IS" name="get_specific_date_column_for_signal" comment="only for temporal hierarchies">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uf8RuSkiQotAp" name="level" visibility="private" type="u0BhDi3cLOHi0" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u0TxPKzxHB2QW" name="signal" visibility="private" type="uo8rUV1weXMFh" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uB5YhLpLWPrA9" name="get_horizon" comment="only for temporal hierarchies">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u6oaay0Qh3Vdi" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uxKkrGFXoZhiy" name="level" visibility="private" type="uvKgkwiD2xY1u" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uoycmqlRXKqU2" name="signal" visibility="private" type="uJH4DkWmv6n9j" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u7Nen7x1klhk7" name="create_all_levels_models_with_one_engine" comment="Sampling is not compatible with Temporal Hierarchies (#163) print(&quot;CREATED_MODELS&quot;, self.mLevels, self.mModels)">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uQ4xh200rpGlz" name="iAllLevelsDataset" visibility="private" type="uViHAHnt7KBFj" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u2J8yf7FJpZop" name="H" visibility="private" type="uO74QSazYYbDn" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ujSEEklHaw14S" name="iDateColumn" visibility="private" type="ujR9EWBOq1QEM" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uDNWhaHFW9jXx" name="fit" comment="self.plot();"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ucnmbYfqld6HG" name="getModelInfo"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uxavVFtZQeXZS" name="get_plot_annotations">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uh9b0qqcpAQY8" type="uP6qE7iac1f7k" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uWHGUr60OU9Tz" name="plot">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ur2flD8W3CDEb" name="name" visibility="private" type="uJAtWLWlCcj5E" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uoA2RKY1R5sLf" name="plot_as_png_base64">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uF83x84hPqcTJ" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uONYZmJqdwsnP" name="name" visibility="private" type="uJAtWLWlCcj5E" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u0mA77SFjclYX" name="standardPlots">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uCQu2pZPyluci" name="name" visibility="private" type="uJAtWLWlCcj5E" value="None"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ux1fJNZJ6rzr0" name="getPlotsAsDict">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uSCkMXape6aHS" type="uP6qE7iac1f7k" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uniEQSdKEenVq" name="forecastAllModels_with_one_engine">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="urRevTR1EE3iw" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uG15vTTMkzbx1" name="iAllLevelsDataset" visibility="private" type="uqyT4KF6oVwu5" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uK07iMzYsch0e" name="H" visibility="private" type="uOquNCM3AgWWA" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXGQnfIOvl1jO" name="iDateColumn" visibility="private" type="uvZDcgMkIRsNn" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uA1vzOBRFQfb1" name="getEstimPart">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uRPjWVZvXO8v0" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uTX4eAKNQl3Vk" name="df" visibility="private" type="uIskL4ILmcXDl" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uDIK3UtO30LHU" name="getValidPart">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uDDPL2o12vQ5L" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uUJqpjsCPPT5P" name="df" visibility="private" type="ukzuWbQYfwve1" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u40pZiYxVrisN" name="computeTopDownHistoricalProportions" comment="Compute these proportions only on Estimation. print(&quot;AvgHitProp\n&quot;, self.mAvgHistProp); print(&quot;PropHistAvg\n&quot;, self.mPropHistAvg);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uwJRUZxs5jC26" name="iAllLevelsDataset" visibility="private" type="uM8Stj08K0BvA" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ufd0Y4PkYffEP" name="computeTopDownForecastedProportions" comment="print(&quot;ForecastedProp\n&quot;, self.mForecastedProp);">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVvdSP5AJ1DDX" name="iForecast_DF" visibility="private" type="uvWn4DVwVQfcV" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ud4p3HO7pzCNH" name="computeBottomUpForecast">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uqCkgbtI5jidP" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uN1U57PqSK4Q3" name="iForecast_DF" visibility="private" type="umGdkn87BM8ZS" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ug2EomfhguHLA" name="level" visibility="private" type="uU2MTe0gInR52" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uEwECVi1A9JND" name="signal" visibility="private" type="uEJY9aMBzEhZr" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u1x8M6Y9rgInp" name="iPrefix" visibility="private" type="uP6qE7iac1f7k" value="&quot;BU&quot;"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u2nvGDf685NnY" name="computeBottomUpForecasts" comment="print(&quot;STRUCTURE &quot; , self.mStructure.keys()); print(lForecast_DF_BU.head()); print(lForecast_DF_BU.tail());">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uujneyUtIJVWx" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u2UvnMSl6KkO8" name="iForecast_DF" visibility="private" type="u7VI4ukjU1nWL" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="unmYwhU63m1jS" name="get_clean_signal_and_forecasts">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="utUvu5cImN9Lo" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uqWkXI9sQkUWf" name="iForecast_DF" visibility="private" type="uskb2NKQhW8Vy" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uJqaKNwAHfpbD" name="signal" visibility="private" type="uN75DuqRwca5P" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uaVmzHOWltw1m" name="iPrefixes" visibility="private" type="udGrlwDLIXStK" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uC4MqvACboa5O" name="get_reconciled_forecast_prefixes">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uSnOcFsaAbyZM" type="uP6qE7iac1f7k" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uoip68PDNks4p" name="computePerfOnCombinedForecasts">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uQOQboP27CGRa" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ufPPspM6M3OBQ" name="iForecast_DF" visibility="private" type="uLLbAO9gmwLqX" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="um9SpIwxvb9vQ" name="computeTopDownForecasts" comment="print(&quot;TOPDOWN_STRUCTURE&quot;, self.mStructure) print(&quot;TOPDOWN_LEVELS&quot;, lLevelsReversed) highest levels (fully aggregated) print(lForecast_DF_TD.head()); print(lForecast_DF_TD.tail());">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubhn52okwEGyL" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="usc18mVcCojcG" name="iForecast_DF" visibility="private" type="uA24sBlhf9ISt" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uTFG4wlJEkFbd" name="iProp" visibility="private" type="uno2Yw5PaZxX7" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uZ6o68OCKL3pk" name="iPrefix" visibility="private" type="uunKJk2kTl3FX" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uvjiVDz31FURb" name="computeMiddleOutForecasts" comment="lower levels .... top-down starting from the middle. print(&quot;MIDDLE_OUT_STRUCTURE&quot;, self.mStructure) print(&quot;MIDDLE_OUT_LEVELS&quot;, levels_below) mid-lewvel : do nothing ????  higher levels .... bottom-up starting from the middle print(lForecast_DF_MO.head()); print(lForecast_DF_MO.tail());">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubOeFyhAWJGRY" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u1x8KErAQxLp9" name="iForecast_DF" visibility="private" type="uE4ndO45Mu3Xw" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVu1kZW9rbgqi" name="iProp" visibility="private" type="uyazUsvgOXqyG" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="umKNRVYLU7deo" name="iPrefix" visibility="private" type="uHhaVuk0v7B41" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ukTmeiAufveKx" name="computeOptimalCombination" comment="TODO : use linalg.solve here print(S.shape); print(lBaseForecasts.shape); print(lOptimalForecasts.shape); print(lForecast_DF_OC.head()); print(lForecast_DF_OC.tail());">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uHtnnrEyh2sXW" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ufScvxd4nwbYd" name="iForecast_DF" visibility="private" type="ugejL0cf09SYn" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="ubTxgIzSiBlXM" name="internal_forecast">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uLRqFRkWpvJ2R" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ubJAOBQnwQSUo" name="iInputDS" visibility="private" type="uGKNivoLEThlY" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uNQERfeEPdzAl" name="iHorizon" visibility="private" type="uhmYy2PMzgg1y" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u6nDjRh6D7Jla" name="forecast">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVjkIMrfprSrj" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u9Tf0JWhh2cuk" name="iInputDS" visibility="private" type="uvzKcYgXarkg1" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uJeXPGsB0QtIn" name="iHorizon" visibility="private" type="uPdpt6Bht71sC" value=""/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="uMwHgbwIQuN0n" name="cTemporalHierarchy">
        <generalization xmi:type="uml:Generalization" xmi:id="usyaZBoGfI74g" general="uLZMhhUOKu7qa"/>
        <generalization xmi:type="uml:Generalization" xmi:id="uurd8MsXfwiCD" general="u9OLW1Sy03Qlk"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="uslWOIYT4rn1N" name="mHorizons" type="u3oJvBWH8hTVE" initialValue="{}"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uJf6FCRQivFZC" name="__init__" stereotype="constructor"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uPGP6fPAbt4FY" name="discard_nans_in_aggregate_signals">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u6e42lrAqGIbG" type="uQ0BSKINVuweD" direction="return"/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uEc9cuCWOc4t4" name="get_specific_date_column_for_signal" comment="only for temporal hierarchies">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uUeBRS1l4ibQE" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uY9JfykSRzkv7" name="level" visibility="private" type="uPqvj6l3GKGE4" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ulzbBEZeZGrR4" name="signal" visibility="private" type="ukbPU5UGvWkgy" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u83puB62ikQt0" name="get_beginning_of_period" comment="add this utility function.">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="umGZ0nrSSY5Pw" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uVK47bazhsleM" name="x" visibility="private" type="uySggK5X99et3" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uNNu6jvXENTjo" name="iPeriod" visibility="private" type="unoj0WeGUHgum" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uxuO93T3fQ79D" name="aggregate_time_columns" comment="logical or">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ud3mJWPQAAX9T" name="level" visibility="private" type="uy0gIp6o67EoO" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uXzyCL79APa2l" name="signal" visibility="private" type="uLqhO8x7LjYVl" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uGRAKPTXwX7ye" name="iAllLevelsDataset" visibility="private" type="uV2E8ovDGY75G" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u6oJ7cqMyrETg" name="create_all_levels_dataset">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="u6YVmRIBTfNII" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uGWzAhMK9IDh0" name="df" visibility="private" type="uzXGxAoraZxJF" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uVJzJJ02p0Jjz" name="get_horizon" comment="only for temporal hierarchies">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="urucB8FpvC8NH" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uc0hnBWnAkXRB" name="level" visibility="private" type="uSufXbg1aAa0h" value=""/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uhQ9xbT3YwXbZ" name="signal" visibility="private" type="uGoLDd2r0S1XI" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u8cixXmIK42Ql" name="add_temporal_data" comment="df1.info() synchronize df[[self.mDateColumn , self.mSignal]].info() WData.info() print(&quot;DATE_PERIOD&quot;, list(WData[lName])[:30])">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="ufDHil56CNLof" type="uP6qE7iac1f7k" direction="return"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uxrh09FBnYVY6" name="df" visibility="private" type="uUNdS6QOcmSHr" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uQFT8B68OoWsG" name="compute_horizons" comment="df1.info() synchronize print(&quot;AS_FREQ&quot; , lPeriod , lDate_Period.head()) print(&quot;AS_FREQ_2&quot; , lPeriod , lBaseFreq , lNewFreq , lHorizon)">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="uqZ6AHL13NPQ8" name="df" visibility="private" type="u4tYMOJEpixpX" value=""/>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uNSnJ00eX0lkA" name="checkPhysicalTime"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="uO1osmxuGzEoS" name="check_increasing_periods"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="u7Ua0TYwrTPaA" name="create_HierarchicalStructure" comment="self.add_temporal_data(self.mTrainingDataset) print(self.mStructure);"/>
      </packagedElement>
      <xmi:Extension extender="umbrello">
        <diagrams resolution="96">
          <diagram xmi.id="uQhZaSls008AE" name="class diagram" type="1" documentation="" backgroundcolor="#ffffff" fillcolor="#ffffc0" font="Cantarell,11,-1,5,50,0,0,0,0,0,Regular" griddotcolor="#f7f7f7" linecolor="#990000" linewidth="0" textcolor="#000000" usefillcolor="1" showattribassocs="1" showatts="1" showattsig="0" showops="1" showopsig="0" showpackage="1" showpubliconly="0" showscope="1" showstereotype="1" localid="-1" showgrid="0" snapgrid="0" snapcsgrid="0" snapx="25" snapy="25" zoom="100" canvasheight="800" canvaswidth="1100" isopen="1">
            <widgets>
              <classwidget xmi.id="uMwHgbwIQuN0n" localid="uiHN00s0HbCqL" textcolor="#000000" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="0" usesdiagramusefillcolor="0" fillcolor="#ffffc0" font="Cantarell,11,-1,5,50,0,0,0,0,0,Regular" autoresize="1" x="835" y="606.2" width="279" height="252" isinstance="0" showstereotype="1" showoperations="1" showpubliconly="0" showopsigs="600" showpackage="1" showscope="1" showattributes="1" showattsigs="600"/>
              <classwidget xmi.id="u9OLW1Sy03Qlk" localid="umNWzv7I4IxoG" textcolor="#000000" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="0" usesdiagramusefillcolor="0" fillcolor="#ffffc0" font="Cantarell,11,-1,5,50,0,0,0,0,0,Regular" autoresize="1" x="444.65" y="-54.45" width="321" height="846" isinstance="0" showstereotype="1" showoperations="1" showpubliconly="0" showopsigs="600" showpackage="1" showscope="1" showattributes="1" showattsigs="600"/>
              <classwidget xmi.id="uOkC0tcBampbP" localid="u4Yu63npDdd5G" textcolor="#000000" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="0" usesdiagramusefillcolor="0" fillcolor="#ffffc0" font="Cantarell,11,-1,5,50,0,0,0,0,0,Regular" autoresize="1" x="152" y="591" width="222" height="108" isinstance="0" showstereotype="1" showoperations="1" showpubliconly="0" showopsigs="600" showpackage="1" showscope="1" showattributes="1" showattsigs="600"/>
            </widgets>
            <messages/>
            <associations>
              <assocwidget xmi.id="u6nTelmIou0vC" localid="ufsJSLuRHjCEF" textcolor="none" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="1" usesdiagramusefillcolor="1" fillcolor="none" font="Cantarell,11,-1,5,50,0,0,0,0,0,Regular" autoresize="1" seqnum="" type="500" widgetaid="uOkC0tcBampbP" widgetbid="u9OLW1Sy03Qlk" indexa="0" totalcounta="0" indexb="0" totalcountb="0">
                <linepath layout="Direct">
                  <startpoint startx="329.833" starty="591"/>
                  <endpoint endx="444.65" endy="498.231"/>
                </linepath>
              </assocwidget>
              <assocwidget xmi.id="uurd8MsXfwiCD" localid="u1bSQlDAog9Zv" textcolor="none" linecolor="#990000" linewidth="0" usefillcolor="1" usesdiagramfillcolor="1" usesdiagramusefillcolor="1" fillcolor="none" font="Cantarell,11,-1,5,50,0,0,0,0,0,Regular" autoresize="1" seqnum="" type="500" widgetaid="uMwHgbwIQuN0n" widgetbid="u9OLW1Sy03Qlk" indexa="0" totalcounta="0" indexb="0" totalcountb="0">
                <linepath layout="Direct">
                  <startpoint startx="846.525" starty="606.2"/>
                  <endpoint endx="765.65" endy="526.573"/>
                </linepath>
              </assocwidget>
            </associations>
          </diagram>
        </diagrams>
      </xmi:Extension>
    </packagedElement>
    <packagedElement xmi:type="uml:Model" xmi:id="Use_Case_View" name="Use Case View"/>
    <packagedElement xmi:type="uml:Model" xmi:id="Component_View" name="Component View"/>
    <packagedElement xmi:type="uml:Model" xmi:id="Deployment_View" name="Deployment View"/>
    <packagedElement xmi:type="uml:Model" xmi:id="Entity_Relationship_Model" name="Entity Relationship Model"/>
  </uml:Model>
  <xmi:Extension extender="umbrello">
    <docsettings viewid="uQhZaSls008AE" documentation="" uniqueid="uXfZVHdPekrma"/>
    <listview>
      <listitem id="Views" type="800" open="1">
        <listitem id="Component_View" type="821" open="1"/>
        <listitem id="Deployment_View" type="827" open="1"/>
        <listitem id="Entity_Relationship_Model" type="836" open="1"/>
        <listitem id="Logical_View" type="801" open="1">
          <listitem id="uQhZaSls008AE" type="807" label="class diagram" open="0"/>
          <listitem id="uOkC0tcBampbP" type="813" open="0">
            <listitem id="uZQ3I24wFwN1L" type="815" open="0"/>
            <listitem id="uBn97K4q9icbq" type="815" open="0"/>
            <listitem id="uy0J93n63jf8b" type="815" open="0"/>
            <listitem id="ufCvwqXpNl2OJ" type="814" open="0"/>
            <listitem id="uQiT1opG7hv7c" type="815" open="0"/>
          </listitem>
          <listitem id="u9OLW1Sy03Qlk" type="813" open="0">
            <listitem id="uqJ83zcDEUVCW" type="815" open="0"/>
            <listitem id="uKaF5m5Sar4wi" type="815" open="0"/>
            <listitem id="uWYNyjb6YyQo8" type="815" open="0"/>
            <listitem id="ud4p3HO7pzCNH" type="815" open="0"/>
            <listitem id="u2nvGDf685NnY" type="815" open="0"/>
            <listitem id="uvjiVDz31FURb" type="815" open="0"/>
            <listitem id="ukTmeiAufveKx" type="815" open="0"/>
            <listitem id="uoip68PDNks4p" type="815" open="0"/>
            <listitem id="ufd0Y4PkYffEP" type="815" open="0"/>
            <listitem id="um9SpIwxvb9vQ" type="815" open="0"/>
            <listitem id="u40pZiYxVrisN" type="815" open="0"/>
            <listitem id="u5ZcjDxwqm40h" type="815" open="0"/>
            <listitem id="u7Nen7x1klhk7" type="815" open="0"/>
            <listitem id="unizFDc8P7pZ8" type="815" open="0"/>
            <listitem id="u3n9J5ojxdWUR" type="815" open="0"/>
            <listitem id="u4awpgYnP0IZg" type="815" open="0"/>
            <listitem id="uDNWhaHFW9jXx" type="815" open="0"/>
            <listitem id="u6nDjRh6D7Jla" type="815" open="0"/>
            <listitem id="uniEQSdKEenVq" type="815" open="0"/>
            <listitem id="unmYwhU63m1jS" type="815" open="0"/>
            <listitem id="unCtNYYMEo2x5" type="815" open="0"/>
            <listitem id="uB5YhLpLWPrA9" type="815" open="0"/>
            <listitem id="uxavVFtZQeXZS" type="815" open="0"/>
            <listitem id="uC4MqvACboa5O" type="815" open="0"/>
            <listitem id="uM2XZxsX2N6IS" type="815" open="0"/>
            <listitem id="uA1vzOBRFQfb1" type="815" open="0"/>
            <listitem id="ucnmbYfqld6HG" type="815" open="0"/>
            <listitem id="ux1fJNZJ6rzr0" type="815" open="0"/>
            <listitem id="uDIK3UtO30LHU" type="815" open="0"/>
            <listitem id="uwCxM1WjQDUzf" type="815" open="0"/>
            <listitem id="ubTxgIzSiBlXM" type="815" open="0"/>
            <listitem id="uoVW7oyjyuISw" type="814" open="0"/>
            <listitem id="ueKP154Cr74Mr" type="814" open="0"/>
            <listitem id="uzgamJBbi4Ma6" type="814" open="0"/>
            <listitem id="uxb6sJAg2Nqjc" type="814" open="0"/>
            <listitem id="uwItxd5V3G67q" type="814" open="0"/>
            <listitem id="uEBaG6MP7pJVP" type="814" open="0"/>
            <listitem id="uDErgHzywpLx9" type="814" open="0"/>
            <listitem id="u7uNb5UyfC7JJ" type="814" open="0"/>
            <listitem id="uLvl85dOemWKn" type="814" open="0"/>
            <listitem id="uckiMg3JL9ni7" type="814" open="0"/>
            <listitem id="uoA2RKY1R5sLf" type="815" open="0"/>
            <listitem id="uWHGUr60OU9Tz" type="815" open="0"/>
            <listitem id="u0mA77SFjclYX" type="815" open="0"/>
            <listitem id="urP8nVCdX8srr" type="815" open="0"/>
            <listitem id="uAO4aO1zqh334" type="815" open="0"/>
          </listitem>
          <listitem id="uMwHgbwIQuN0n" type="813" open="0">
            <listitem id="uJf6FCRQivFZC" type="815" open="0"/>
            <listitem id="u8cixXmIK42Ql" type="815" open="0"/>
            <listitem id="uxuO93T3fQ79D" type="815" open="0"/>
            <listitem id="uO1osmxuGzEoS" type="815" open="0"/>
            <listitem id="uNSnJ00eX0lkA" type="815" open="0"/>
            <listitem id="uQFT8B68OoWsG" type="815" open="0"/>
            <listitem id="u6oJ7cqMyrETg" type="815" open="0"/>
            <listitem id="u7Ua0TYwrTPaA" type="815" open="0"/>
            <listitem id="uPGP6fPAbt4FY" type="815" open="0"/>
            <listitem id="u83puB62ikQt0" type="815" open="0"/>
            <listitem id="uVJzJJ02p0Jjz" type="815" open="0"/>
            <listitem id="uEc9cuCWOc4t4" type="815" open="0"/>
            <listitem id="uslWOIYT4rn1N" type="814" open="0"/>
          </listitem>
          <listitem id="Datatypes" type="830" open="0">
            <listitem id="utltd0oYDqkOo" type="829" open="0"/>
            <listitem id="u3oJvBWH8hTVE" type="829" open="0"/>
            <listitem id="uHQ4DK8ATZDBs" type="829" open="0"/>
            <listitem id="uPeauoMgBXsNO" type="829" open="0"/>
            <listitem id="u5X8zQLHtddCi" type="829" open="0"/>
            <listitem id="uJAtWLWlCcj5E" type="829" open="0"/>
            <listitem id="uFNR7e0FOCuLt" type="829" open="0"/>
            <listitem id="un1B0hysBdRCi" type="829" open="0"/>
          </listitem>
          <listitem id="uNHU3eupgTOKr" type="818" open="1">
            <listitem id="uLZMhhUOKu7qa" type="813" open="0"/>
          </listitem>
        </listitem>
        <listitem id="Use_Case_View" type="802" open="1"/>
      </listitem>
    </listview>
    <codegeneration>
      <codegenerator language="Python">
        <sourcecode id="uZQ3I24wFwN1L" value="sighier.cSignalHierarchy.__init__(self)&#10;self.mLabels2Tuples={&#10;}&#10;&#10;&#10;"/>
        <sourcecode id="uQiT1opG7hv7c" value="str1=&quot;_&quot;.join(list(k))&#10;&#10;return str1&#10;&#10;"/>
        <sourcecode id="uBn97K4q9icbq" value="level=previous_level+1&#10;&#10;self.mStructure[level]={&#10;}&#10;&#10;&#10;for group in self.mStructure[previous_level]:&#10;  lGroupLabel=group&#10;&#10;  lTuple=self.mLabels2Tuples[lGroupLabel]&#10;  for k in[previous_level]:&#10;    if(lTuple[k]!=&quot;&quot;):&#10;      new_group=list(lTuple)&#10;&#10;      new_group[k]=&quot;&quot;&#10;&#10;      new_group=tuple(new_group)&#10;&#10;      lNewGroupLabel=self.tuple_to_string(new_group)&#10;&#10;      self.mLabels2Tuples[lNewGroupLabel]=new_group&#10;&#10;      if(lNewGroupLabel not in self.mStructure[level]):&#10;        self.mStructure[level][lNewGroupLabel]=set()&#10;&#10;&#10;      self.mStructure[level][lNewGroupLabel].add(lGroupLabel)&#10;&#10;&#10;&#10;"/>
        <sourcecode id="uy0J93n63jf8b" value="lGroups=self.mHierarchy['Groups']&#10;self.mLevels=list(lGroups.keys())&#10;&#10;self.mLabels2Tuples={&#10;}&#10;&#10;&#10;self.mStructure={&#10;}&#10;&#10;&#10;array1=[sorted(lGroups[k])for k in self.mHierarchy['GroupOrder']]&#10;&#10;prod=itertools.product(*array1)&#10;&#10;level=0&#10;&#10;self.mStructure[level]={&#10;}&#10;&#10;for k in prod:&#10;  lGroupLabel=self.tuple_to_string(k)&#10;&#10;  if(lGroupLabel in self.mTrainingDataset.columns):&#10;    self.mLabels2Tuples[lGroupLabel]=k&#10;&#10;    self.mStructure[level][lGroupLabel]=set()&#10;&#10;&#10;&#10;while(len(self.mStructure[level])&gt;1):&#10;  self.add_level(level)&#10;&#10;  level=level+1&#10;&#10;&#10;for level in sorted(self.mStructure.keys()):&#10;  for col in sorted(self.mStructure[level].keys()):&#10;    self.mStructure[level][col]=sorted(self.mStructure[level][col])&#10;&#10;&#10;pass"/>
        <sourcecode id="uqJ83zcDEUVCW" value="self.mHierarchy=None&#10;&#10;self.mDateColumn=None&#10;&#10;self.mSignal=None&#10;&#10;self.mHorizon=None&#10;&#10;self.mExogenousData=None&#10;&#10;self.mTrainingDataset=None&#10;&#10;self.mOptions=None&#10;&#10;self.mLevels=None&#10;&#10;self.mStructure=None&#10;&#10;self.mSummingMatrix=None&#10;&#10;self.mModels=None&#10;&#10;"/>
        <sourcecode id="uwCxM1WjQDUzf" value="lStr2=&quot;&quot;&#10;return lStr2&#10;&#10;"/>
        <sourcecode id="unCtNYYMEo2x5" value="if(self.mExogenousData is None):&#10;  return None&#10;&#10;if(type(self.mExogenousData)==tuple):&#10;  return self.mExogenousData&#10;&#10;if(type(self.mExogenousData)==dict):&#10;  return self.mExogenousData.get(signal)&#10;&#10;raise tsutil.PyAF_Error(&quot;BAD_EXOGENOUS_DATA_SPECIFICATION&quot;)&#10;&#10;"/>
        <sourcecode id="urP8nVCdX8srr" value="lDict={&#10;}&#10;&#10;&#10;lDict['Structure']=self.mStructure&#10;&#10;lDict['Models']=self.mModels.to_dict(iWithOptions=False)&#10;lDict['Models'].pop('Training_Time')&#10;if(iWithOptions):&#10;  lDict[&quot;Options&quot;]=self.mTimeInfo.mOptions.__dict__&#10;&#10;lDict[&quot;Training_Time&quot;]=self.mTrainingTime&#10;return lDict&#10;&#10;"/>
        <sourcecode id="u4awpgYnP0IZg" value="return False&#10;"/>
        <sourcecode id="unizFDc8P7pZ8" value="self.mLevels=self.mHierarchy['Levels']&#10;&#10;self.mStructure={&#10;}&#10;&#10;&#10;df=self.mHierarchy['Data']&#10;&#10;lLevelCount=len(self.mLevels)&#10;&#10;for level in range(lLevelCount):&#10;  self.mStructure[level]={&#10;}&#10;&#10;&#10;&#10;for row in range(df.shape[0]):&#10;  for level in range(lLevelCount):&#10;    col=df[df.columns[level]][row]&#10;&#10;    if(col not in self.mStructure[level].keys()):&#10;      self.mStructure[level][col]=set()&#10;&#10;&#10;    if(level&gt;0):&#10;      col1=df[df.columns[level-1]][row]&#10;&#10;      self.mStructure[level][col].add(col1)&#10;&#10;&#10;&#10;&#10;for level in sorted(self.mStructure.keys()):&#10;  for col in sorted(self.mStructure[level].keys()):&#10;    self.mStructure[level][col]=sorted(self.mStructure[level][col])&#10;&#10;&#10;pass&#10;"/>
        <sourcecode id="u3n9J5ojxdWUR" value="lNbNodes=sum([len(self.mStructure[level])for level in self.mStructure.keys()])&#10;&#10;lBaseLevelCount=len(self.mStructure[0])&#10;&#10;lIndices={&#10;}&#10;&#10;&#10;self.mSummingMatrix=np.zeros((lNbNodes,lBaseLevelCount))&#10;&#10;for level in sorted(self.mStructure.keys()):&#10;  if(level&gt;0):&#10;    for col in sorted(self.mStructure[level].keys()):&#10;      i=len(lIndices)&#10;&#10;      lIndices[col]=i&#10;&#10;      for col1 in sorted(self.mStructure[level][col]):&#10;        ii=lIndices[col1]&#10;&#10;        for j in range(lBaseLevelCount):&#10;          self.mSummingMatrix[i][j]=self.mSummingMatrix[ii][j]+self.mSummingMatrix[i][j]&#10;&#10;&#10;&#10;&#10;&#10;  else:&#10;    for col in sorted(self.mStructure[level].keys()):&#10;      lNew_index=len(lIndices)&#10;&#10;      lIndices[col]=lNew_index&#10;&#10;      self.mSummingMatrix[lNew_index][lNew_index]=1&#10;&#10;&#10;&#10;&#10;self.mSummingMatrixInverse=np.linalg.pinv(self.mSummingMatrix)&#10;&#10;"/>
        <sourcecode id="uWYNyjb6YyQo8" value="if(self.mHorizon!=int(self.mHorizon)):&#10;  raise tsutil.PyAF_Error(&quot;PYAF_ERROR_NON_INTEGER_HORIZON &quot;+str(self.mHorizon))&#10;&#10;&#10;if(self.mHorizon&lt;1):&#10;  raise tsutil.PyAF_Error(&quot;PYAF_ERROR_NEGATIVE_OR_NULL_HORIZON &quot;+str(self.mHorizon))&#10;&#10;&#10;if(self.mDateColumn not in df.columns):&#10;  raise tsutil.PyAF_Error(&quot;PYAF_ERROR_HIERARCHY_TIME_COLUMN_NOT_FOUND &quot;+str(self.mDateColumn))&#10;&#10;&#10;type1=df[self.mDateColumn].dtype&#10;if(type1.kind!='M'and type1.kind!='i'and type1.kind!='u'and type1.kind!='f'):&#10;  raise tsutil.PyAF_Error(&quot;PYAF_ERROR_TIME_COLUMN_TYPE_NOT_ALLOWED '&quot;+str(self.mDateColumn)+&quot;' '&quot;+str(type1)+&quot;'&quot;)&#10;&#10;&#10;for k in self.mStructure[0]:&#10;  if(k not in df.columns):&#10;    raise tsutil.PyAF_Error(&quot;PYAF_ERROR_HIERARCHY_BASE_COLUMN_NOT_FOUND &quot;+str(k))&#10;&#10;&#10;  type2=df[k].dtype&#10;  if(type2.kind!='i'and type2.kind!='u'and type2.kind!='f'):&#10;    raise tsutil.PyAF_Error(&quot;PYAF_ERROR_HIERARCHY_BASE_SIGNAL_COLUMN_TYPE_NOT_ALLOWED '&quot;+str(k)+&quot;' '&quot;+str(type2)+&quot;'&quot;)&#10;&#10;&#10;&#10;"/>
        <sourcecode id="u5ZcjDxwqm40h" value="self.checkData(df)&#10;&#10;lAllLevelsDataset=df.copy()&#10;&#10;lMapped=True&#10;&#10;for k in self.mStructure[0]:&#10;  if(k not in df.columns):&#10;    lMapped=False&#10;&#10;&#10;&#10;if(not lMapped):&#10;  i=0&#10;&#10;  for k in self.mStructure[0]:&#10;    print(&quot;MAPPING_ORIGINAL_COLUMN&quot;,df.columns[i+1],&quot;=&gt;&quot;,k)&#10;    lAllLevelsDataset[k]=df[df.columns[i+1]]&#10;&#10;    i=i+1&#10;&#10;&#10;&#10;for level in sorted(self.mStructure.keys()):&#10;  if(level&gt;0):&#10;    for col in sorted(self.mStructure[level].keys()):&#10;      new_col=None&#10;&#10;      for col1 in sorted(self.mStructure[level][col]):&#10;        if(new_col is None):&#10;          new_col=lAllLevelsDataset[col1]&#10;&#10;&#10;        else:&#10;          new_col=new_col+lAllLevelsDataset[col1]&#10;&#10;&#10;&#10;      lAllLevelsDataset[col]=new_col&#10;&#10;&#10;&#10;&#10;return lAllLevelsDataset&#10;&#10;"/>
        <sourcecode id="uKaF5m5Sar4wi" value="lAllLevelsDataset=self.create_all_levels_dataset(df)&#10;&#10;return lAllLevelsDataset&#10;&#10;"/>
        <sourcecode id="uAO4aO1zqh334" value="df=self.addVars(df)&#10;&#10;return df&#10;&#10;"/>
        <sourcecode id="uM2XZxsX2N6IS" value="return None&#10;"/>
        <sourcecode id="uB5YhLpLWPrA9" value="return self.mHorizon&#10;"/>
        <sourcecode id="u7Nen7x1klhk7" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;lSignals=[]&#10;lDateColumns={&#10;}&#10;&#10;lExogenousData={&#10;}&#10;&#10;lHorizons={&#10;}&#10;&#10;lDiscardNulls={&#10;}&#10;&#10;for level in sorted(self.mStructure.keys()):&#10;  for signal in sorted(self.mStructure[level].keys()):&#10;    lSignals=lSignals+[signal]&#10;    lExogenousData[signal]=self.get_exogenous_data(signal)&#10;    lDateColumn=self.get_specific_date_column_for_signal(level,signal)&#10;    lDateColumns[signal]=lDateColumn or iDateColumn&#10;    lHorizons[signal]=self.get_horizon(level,signal)&#10;&#10;&#10;lEngine=autof.cForecastEngine()&#10;lEngine.mOptions=copy.copy(self.mOptions)&#10;&#10;if(self.discard_nans_in_aggregate_signals()):&#10;  lEngine.mOptions.mMissingDataOptions.mTimeMissingDataImputation=&quot;DiscardRow&quot;&#10;  lEngine.mOptions.mMissingDataOptions.mSignalMissingDataImputation=&quot;DiscardRow&quot;&#10;  lEngine.mOptions.mActivateSampling=False&#10;&#10;assert(iAllLevelsDataset.shape[0]&gt;0)&#10;lEngine.train(iAllLevelsDataset,lDateColumns,lSignals,lHorizons,iExogenousData=lExogenousData)&#10;&#10;self.mModels=lEngine&#10;"/>
        <sourcecode id="uDNWhaHFW9jXx" value="lTimer=tsutil.cTimer((&quot;HIERARCHICAL_TRAINING&quot;))&#10;self.create_HierarchicalStructure()&#10;&#10;self.create_SummingMatrix()&#10;&#10;lAllLevelsDataset=self.create_all_levels_dataset(self.mTrainingDataset)&#10;&#10;self.create_all_levels_models_with_one_engine(lAllLevelsDataset,self.mHorizon,self.mDateColumn)&#10;&#10;self.computeTopDownHistoricalProportions(lAllLevelsDataset)&#10;&#10;lForecast_DF=self.internal_forecast(self.mTrainingDataset,self.mHorizon)&#10;self.computePerfOnCombinedForecasts(lForecast_DF.head(lForecast_DF.shape[0]-self.mHorizon))&#10;&#10;self.mTrainingTime=lTimer.get_elapsed_time()&#10;"/>
        <sourcecode id="ucnmbYfqld6HG" value="lEngine=self.mModels&#10;lEngine.getModelInfo()&#10;&#10;"/>
        <sourcecode id="uxavVFtZQeXZS" value="lAnnotations=None&#10;&#10;lHasModels=(self.mModels is not None)&#10;if(lHasModels):&#10;  lPrefixes=self.get_reconciled_forecast_prefixes()&#10;  lAnnotations={&#10;}&#10;&#10;&#10;  for level in sorted(self.mStructure.keys()):&#10;    for signal in sorted(self.mStructure[level].keys()):&#10;      lEngine=self.mModels&#10;      lMAPE='MAPE = %.4f'%self.mValidPerfs[str(signal)+&quot;_Forecast&quot;].mMAPE&#10;      lReconciledMAPEs=[]&#10;      for lPrefix in lPrefixes:&#10;        lMAPE_Rec=self.mValidPerfs[str(signal)+&quot;_&quot;+lPrefix+&quot;_Forecast&quot;].mMAPE&#10;        lReconciledMAPEs.append('MAPE_'+lPrefix+' = %.4f'%lMAPE_Rec)&#10;&#10;&#10;      lAnnotations[signal]=[signal,lMAPE]+lReconciledMAPEs&#10;&#10;      for col1 in sorted(self.mStructure[level][signal]):&#10;        lProp=self.mAvgHistProp[signal][col1]*100&#10;&#10;        lAnnotations[str(signal)+&quot;_&quot;+col1]=('%2.2f %%'%lProp)&#10;&#10;&#10;&#10;&#10;return lAnnotations&#10;"/>
        <sourcecode id="uWHGUr60OU9Tz" value="lTimer=tsutil.cTimer((&quot;HIERARCHICAL_PLOTTING&quot;))&#10;lAnnotations=self.get_plot_annotations()&#10;tsplot.plot_hierarchy(self.mStructure,lAnnotations,name)&#10;"/>
        <sourcecode id="uoA2RKY1R5sLf" value="lTimer=tsutil.cTimer((&quot;HIERARCHICAL_PLOTTING_AS_PNG&quot;))&#10;lAnnotations=self.get_plot_annotations()&#10;lBase64=tsplot.plot_hierarchy_as_png_base64(self.mStructure,lAnnotations,name)&#10;return lBase64&#10;"/>
        <sourcecode id="u0mA77SFjclYX" value="lEngine=self.mModels&#10;lEngine.standardPlots(name+&quot;_Hierarchy_Level_Signal_&quot;)&#10;&#10;self.plot(name+&quot;_Hierarchical_Structure.png&quot;)&#10;"/>
        <sourcecode id="ux1fJNZJ6rzr0" value="lDict={&#10;}&#10;&#10;lDict[&quot;Models&quot;]=self.mModels.getPlotsAsDict()&#10;lDict[&quot;Hierarchical_Structure&quot;]=self.plot_as_png_base64()&#10;return lDict&#10;"/>
        <sourcecode id="uniEQSdKEenVq" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;lEngine=self.mModels&#10;lForecast_DF=lEngine.forecast(iAllLevelsDataset,H)&#10;&#10;lDateColumns=[]&#10;lSigColumns=[]&#10;for signal in lEngine.mSignalDecomposition.mSignals:&#10;  lDateColumn=lEngine.mSignalDecomposition.mDateColumns[signal]&#10;  lDateColumns=lDateColumns+[lDateColumn]&#10;  lSigColumns=lSigColumns+[signal,&#10;  str(signal)+'_Forecast',str(signal)+'_Forecast_Lower_Bound',str(signal)+'_Forecast_Upper_Bound']&#10;lColumns=list(set(lDateColumns))+lSigColumns&#10;if(self.discard_nans_in_aggregate_signals()):&#10;  H=self.mHorizon&#10;  N=lForecast_DF.shape[0]&#10;  lForecast_DF.loc[0:N-H,signal]=lForecast_DF.loc[0:N-H,signal].fillna(0.0)&#10;  lForecast_DF[str(signal)+'_Forecast']=lForecast_DF[str(signal)+'_Forecast'].fillna(0.0)&#10;&#10;return lForecast_DF[lColumns]&#10;"/>
        <sourcecode id="uA1vzOBRFQfb1" value="lEngine=self.mModels&#10;lFrameFit=lEngine.mSignalDecomposition.mBestModel.mTimeInfo.mSplit.getEstimPart(df)&#10;&#10;return lFrameFit&#10;&#10;"/>
        <sourcecode id="uDIK3UtO30LHU" value="lEngine=self.mModels&#10;lFrameFit=lEngine.mSignalDecomposition.mBestModel.mTimeInfo.mSplit.getValidPart(df)&#10;&#10;return lFrameFit&#10;&#10;"/>
        <sourcecode id="u40pZiYxVrisN" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;logger.info(&quot;TRAINING_HIERARCHICAL_MODEL_COMPUTE_TOP_DOWN_HISTORICAL_PROPORTIONS&quot;)&#10;&#10;self.mAvgHistProp={&#10;}&#10;&#10;&#10;self.mPropHistAvg={&#10;}&#10;&#10;&#10;lEstim=self.getEstimPart(iAllLevelsDataset)&#10;&#10;for level in sorted(self.mStructure.keys()):&#10;  if(level&gt;0):&#10;    for col in sorted(self.mStructure[level].keys()):&#10;      self.mAvgHistProp[col]={&#10;}&#10;&#10;&#10;      self.mPropHistAvg[col]={&#10;}&#10;&#10;&#10;      for col1 in sorted(self.mStructure[level][col]):&#10;        self.mAvgHistProp[col][col1]=(lEstim[col1]/lEstim[col]).mean()&#10;&#10;        self.mPropHistAvg[col][col1]=lEstim[col1].mean()/lEstim[col].mean()&#10;&#10;&#10;&#10;&#10;&#10;pass&#10;"/>
        <sourcecode id="ufd0Y4PkYffEP" value="self.mForecastedProp={&#10;}&#10;&#10;&#10;for level in sorted(self.mStructure.keys()):&#10;  if(level&gt;0):&#10;    for col in sorted(self.mStructure[level].keys()):&#10;      self.mForecastedProp[col]={&#10;}&#10;&#10;&#10;      for col1 in sorted(self.mStructure[level][col]):&#10;        self.mForecastedProp[col][col1]=(iForecast_DF[col1]/iForecast_DF[col]).mean()&#10;&#10;&#10;&#10;&#10;&#10;pass&#10;"/>
        <sourcecode id="ud4p3HO7pzCNH" value="new_BU_forecast=None&#10;&#10;for col1 in sorted(self.mStructure[level][signal]):&#10;  if(new_BU_forecast is None):&#10;    new_BU_forecast=iForecast_DF[col1+&quot;_Forecast&quot;]&#10;&#10;&#10;  else:&#10;    new_BU_forecast=new_BU_forecast+iForecast_DF[col1+&quot;_&quot;+iPrefix+&quot;_Forecast&quot;]&#10;&#10;&#10;&#10;if(new_BU_forecast is None):&#10;  new_BU_forecast=iForecast_DF[str(signal)+&quot;_Forecast&quot;]&#10;&#10;&#10;return new_BU_forecast&#10;&#10;"/>
        <sourcecode id="u2nvGDf685NnY" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;logger.info(&quot;FORECASTING_HIERARCHICAL_MODEL_BOTTOM_UP_METHOD &quot;+&quot;BU&quot;)&#10;&#10;lForecast_DF_BU=iForecast_DF.copy()&#10;for level in sorted(self.mStructure.keys()):&#10;  for signal in sorted(self.mStructure[level].keys()):&#10;    new_BU_forecast=self.computeBottomUpForecast(lForecast_DF_BU,level,signal)&#10;&#10;    lForecast_DF_BU[str(signal)+&quot;_BU_Forecast&quot;]=new_BU_forecast&#10;&#10;&#10;&#10;return lForecast_DF_BU&#10;&#10;"/>
        <sourcecode id="unmYwhU63m1jS" value="lEngine=self.mModels&#10;lForecasts=[str(signal)+&quot;_Forecast&quot;]&#10;lForecasts=lForecasts+[str(signal)+&quot;_&quot;+lPrefix+&quot;_Forecast&quot;for lPrefix in iPrefixes]&#10;lColumns=[lEngine.mSignalDecomposition.mDateColumns[signal],signal]+lForecasts&#10;lForecast_DF=iForecast_DF[lColumns]&#10;return lForecast_DF&#10;"/>
        <sourcecode id="uC4MqvACboa5O" value="lCombinationMethods=self.mOptions.mHierarchicalCombinationMethod&#10;&#10;if type(lCombinationMethods)is not list:&#10;  lCombinationMethods=[lCombinationMethods]&#10;&#10;&#10;lPrefixes=[lPrefix for lPrefix in lCombinationMethods if(lPrefix!='TD')]&#10;&#10;if('TD'in lCombinationMethods):&#10;  lPrefixes=lPrefixes+['AHP_TD','PHA_TD']&#10;&#10;&#10;return lPrefixes&#10;"/>
        <sourcecode id="uoip68PDNks4p" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;logger.info(&quot;FORECASTING_HIERARCHICAL_MODEL_OPTIMAL_COMBINATION_METHOD&quot;)&#10;&#10;lEngine=self.mModels&#10;lPrefixes=self.get_reconciled_forecast_prefixes()&#10;self.mEstimPerfs={&#10;}&#10;&#10;self.mValidPerfs={&#10;}&#10;&#10;lPerfs={&#10;}&#10;&#10;&#10;logger.info(&quot;STRUCTURE &quot;+str(sorted(list(self.mStructure.keys()))))&#10;&#10;logger.info(&quot;DATASET_COLUMNS &quot;+str(iForecast_DF.columns))&#10;&#10;for level in sorted(self.mStructure.keys()):&#10;  logger.info(&quot;STRUCTURE_LEVEL &quot;+str((level,sorted(list(self.mStructure[level].keys())))))&#10;&#10;  for signal in sorted(self.mStructure[level].keys()):&#10;    lForecast_DF=self.get_clean_signal_and_forecasts(iForecast_DF,signal,lPrefixes)&#10;    lFrameFit=self.getEstimPart(lForecast_DF)&#10;&#10;    lFrameValid=self.getValidPart(lForecast_DF)&#10;&#10;    lColumns=[signal,str(signal)+&quot;_Forecast&quot;]+[str(signal)+&quot;_&quot;+lPrefix+&quot;_Forecast&quot;for lPrefix in lPrefixes]&#10;    lFrameFit=lFrameFit[lColumns]&#10;    lFrameValid=lFrameValid[lColumns]&#10;    if(self.discard_nans_in_aggregate_signals()):&#10;      lFrameFit=lFrameFit.dropna()&#10;      lFrameValid=lFrameValid.dropna()&#10;&#10;    lPerfFit=lEngine.computePerf(lFrameFit[signal],lFrameFit[str(signal)+&quot;_Forecast&quot;],signal)&#10;    lPerfValid=lEngine.computePerf(lFrameValid[signal],lFrameValid[str(signal)+&quot;_Forecast&quot;],signal)&#10;    self.mEstimPerfs[str(signal)+&quot;_Forecast&quot;]=lPerfFit&#10;    self.mValidPerfs[str(signal)+&quot;_Forecast&quot;]=lPerfValid&#10;    for iPrefix in lPrefixes:&#10;      lName=str(signal)+&quot;_&quot;+iPrefix+&quot;_Forecast&quot;&#10;      lPerfFit_Combined=lEngine.computePerf(lFrameFit[signal],lFrameFit[lName],lName)&#10;      lPerfValid_Combined=lEngine.computePerf(lFrameValid[signal],lFrameValid[lName],lName)&#10;      lPerfs[str(signal)+&quot;_&quot;+iPrefix]=(lPerfFit,lPerfValid,lPerfFit_Combined,lPerfValid_Combined)&#10;&#10;      self.mEstimPerfs[lName]=lPerfFit_Combined&#10;      self.mValidPerfs[lName]=lPerfValid_Combined&#10;&#10;&#10;&#10;for(sig,perf)in sorted(lPerfs.items()):&#10;  logger.info(&quot;REPORT_COMBINED_FORECASTS_FIT_PERF &quot;+str(perf[2].to_dict()))&#10;  logger.info(&quot;REPORT_COMBINED_FORECASTS_VALID_PERF &quot;+str(perf[3].to_dict()))&#10;&#10;return lPerfs&#10;&#10;"/>
        <sourcecode id="um9SpIwxvb9vQ" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;logger.info(&quot;FORECASTING_HIERARCHICAL_MODEL_TOP_DOWN_METHOD &quot;+iPrefix)&#10;&#10;lForecast_DF_TD=iForecast_DF.copy()&#10;lLevelsReversed=sorted(self.mStructure.keys(),reverse=True)&#10;&#10;lHighestLevel=lLevelsReversed[0]&#10;&#10;for signal in sorted(self.mStructure[lHighestLevel].keys()):&#10;  lForecast_DF_TD[str(signal)+&quot;_&quot;+iPrefix+&quot;_Forecast&quot;]=iForecast_DF[str(signal)+&quot;_Forecast&quot;]&#10;&#10;&#10;for level in lLevelsReversed:&#10;  for signal in sorted(self.mStructure[level].keys()):&#10;    for col in sorted(self.mStructure[level][signal]):&#10;      new_TD_forecast=lForecast_DF_TD[str(signal)+&quot;_&quot;+iPrefix+&quot;_Forecast&quot;]*iProp[signal][col]&#10;&#10;      lForecast_DF_TD[str(col)+&quot;_&quot;+iPrefix+&quot;_Forecast&quot;]=new_TD_forecast&#10;&#10;&#10;&#10;&#10;return lForecast_DF_TD&#10;&#10;"/>
        <sourcecode id="uvjiVDz31FURb" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;logger.info(&quot;FORECASTING_HIERARCHICAL_MODEL_MIDDLE_OUT_METHOD &quot;+iPrefix)&#10;&#10;lLevels=self.mStructure.keys()&#10;&#10;lMidLevel=len(lLevels)//2&#10;&#10;lForecast_DF_MO=iForecast_DF.copy()&#10;levels_below=sorted([level for level in self.mStructure.keys()if(level&lt;=lMidLevel)],&#10;reverse=True)&#10;for signal in sorted(self.mStructure[lMidLevel].keys()):&#10;  lForecast_DF_MO[str(signal)+&quot;_&quot;+iPrefix+&quot;_Forecast&quot;]=iForecast_DF[str(signal)+&quot;_Forecast&quot;]&#10;&#10;&#10;for level in levels_below:&#10;  for signal in sorted(self.mStructure[level].keys()):&#10;    for col in sorted(self.mStructure[level][signal]):&#10;      new_MO_forecast=lForecast_DF_MO[str(signal)+&quot;_&quot;+iPrefix+&quot;_Forecast&quot;]*iProp[signal][col]&#10;&#10;      lForecast_DF_MO[str(col)+&quot;_&quot;+iPrefix+&quot;_Forecast&quot;]=new_MO_forecast&#10;&#10;&#10;&#10;&#10;for level in range(lMidLevel+1,len(self.mStructure.keys())):&#10;  for signal in sorted(self.mStructure[level].keys()):&#10;    new_MO_forecast=self.computeBottomUpForecast(lForecast_DF_MO,level,signal,iPrefix)&#10;&#10;    lForecast_DF_MO[str(signal)+&quot;_&quot;+iPrefix+&quot;_Forecast&quot;]=new_MO_forecast&#10;&#10;&#10;&#10;return lForecast_DF_MO&#10;&#10;"/>
        <sourcecode id="ukTmeiAufveKx" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;logger.info(&quot;FORECASTING_HIERARCHICAL_MODEL_OPTIMAL_COMBINATION_METHOD &quot;+&quot;OC&quot;)&#10;&#10;lBaseNames=[]&#10;&#10;for level in sorted(self.mStructure.keys()):&#10;  for col in sorted(self.mStructure[level].keys()):&#10;    lBaseNames.append(col)&#10;&#10;&#10;&#10;lBaseForecastNames=[str(col)+&quot;_Forecast&quot;for col in lBaseNames]&#10;lBaseForecasts=iForecast_DF[lBaseForecastNames]&#10;&#10;S=self.mSummingMatrix&#10;&#10;lInv=np.linalg.inv(S.T.dot(S))&#10;lOptimalForecasts=S.dot(lInv).dot(S.T).dot(lBaseForecasts.values.T)&#10;lOptimalNames=[(str(col)+&quot;_OC_Forecast&quot;)for col in lBaseNames]&#10;&#10;df=pd.DataFrame(lOptimalForecasts.T)&#10;&#10;df.columns=lOptimalNames&#10;&#10;lForecast_DF_OC=pd.concat([iForecast_DF,df],axis=1)&#10;&#10;return lForecast_DF_OC&#10;&#10;"/>
        <sourcecode id="ubTxgIzSiBlXM" value="lAllLevelsDataset=self.create_all_levels_dataset(iInputDS)&#10;&#10;lForecast_DF=self.forecastAllModels_with_one_engine(lAllLevelsDataset,iHorizon,self.mDateColumn)&#10;&#10;lCombinationMethods=self.mOptions.mHierarchicalCombinationMethod&#10;&#10;if type(lCombinationMethods)is not list:&#10;  lCombinationMethods=[lCombinationMethods]&#10;&#10;&#10;logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;logger.info(&quot;FORECASTING_HIERARCHICAL_MODEL_COMBINATION_METHODS &quot;+str(lCombinationMethods))&#10;&#10;for lMethod in lCombinationMethods:&#10;  if(lMethod==&quot;BU&quot;):&#10;  lForecast_DF_BU=self.computeBottomUpForecasts(lForecast_DF)&#10;  lForecast_DF=lForecast_DF_BU&#10;  if(lMethod==&quot;TD&quot;):&#10;  lForecast_DF_TD_AHP=self.computeTopDownForecasts(lForecast_DF,self.mAvgHistProp,&quot;AHP_TD&quot;)lForecast_DF=lForecast_DF_TD_AHP&#10;  lForecast_DF_TD_PHA=self.computeTopDownForecasts(lForecast_DF,self.mPropHistAvg,&quot;PHA_TD&quot;)lForecast_DF=lForecast_DF_TD_PHA&#10;  if(lMethod==&quot;MO&quot;):&#10;  lForecast_DF_MO=self.computeMiddleOutForecasts(lForecast_DF,self.mPropHistAvg,&quot;MO&quot;)lForecast_DF=lForecast_DF_MO&#10;  if(lMethod==&quot;OC&quot;):&#10;  lForecast_DF_OC=self.computeOptimalCombination(lForecast_DF)&#10;  lForecast_DF=lForecast_DF_OC&#10;&#10;return lForecast_DF&#10;"/>
        <sourcecode id="u6nDjRh6D7Jla" value="lTimer=tsutil.cTimer((&quot;HIERARCHICAL_FORECAST&quot;))&#10;lForecast_DF=self.internal_forecast(iInputDS,iHorizon)&#10;return lForecast_DF&#10;"/>
        <sourcecode id="uJf6FCRQivFZC" value="sighier.cSignalHierarchy.__init__(self)&#10;self.mHorizons={&#10;}&#10;&#10;"/>
        <sourcecode id="uPGP6fPAbt4FY" value="return True&#10;"/>
        <sourcecode id="uEc9cuCWOc4t4" value="lPeriod=self.mPeriods[level]&#10;lPrefix=&quot;TH&quot;&#10;lName=lPrefix+&quot;_&quot;+lPeriod+&quot;_start&quot;&#10;return lName&#10;"/>
        <sourcecode id="u83puB62ikQt0" value="lHelper=dtfunc.cDateTime_Helper()&#10;return lHelper.get_beginning_of_period(iPeriod,x)&#10;"/>
        <sourcecode id="uxuO93T3fQ79D" value="cols=[col1 for col1 in sorted(self.mStructure[level][signal])]&#10;iAllLevelsDataset[signal]=iAllLevelsDataset[cols[0]]&#10;for col in cols[1:]:&#10;  new_col=iAllLevelsDataset[[signal,col]].apply(lambda x:x[1]if(x[0]is None)else x[0],axis=0)&#10;  iAllLevelsDataset[signal]=new_col&#10;&#10;"/>
        <sourcecode id="u6oJ7cqMyrETg" value="df=df.reset_index(drop=True)&#10;df=self.add_temporal_data(df)&#10;return df&#10;"/>
        <sourcecode id="uVJzJJ02p0Jjz" value="lPeriod=self.mPeriods[level]&#10;return self.mHorizons[lPeriod]&#10;"/>
        <sourcecode id="u8cixXmIK42Ql" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;N=len(df.columns)&#10;df1=df[[self.mDateColumn,self.mSignal]].copy()&#10;df1.set_index(self.mDateColumn,inplace=True,drop=False)&#10;lPrefix=&quot;TH&quot;&#10;df_resampled={&#10;}&#10;&#10;for lPeriod in self.mPeriods:&#10;  lName=lPrefix+&quot;_&quot;+lPeriod+&quot;_start&quot;&#10;  df_resampled[lPeriod]=df1[self.mSignal].resample(lPeriod).sum().reset_index()&#10;  df_resampled[lPeriod].columns=[lName,self.mSignal]&#10;  lShift=df_resampled[lPeriod][lName].iloc[0]-df[self.mDateColumn].iloc[0]&#10;  df_resampled[lPeriod][lName]=df_resampled[lPeriod][lName]-lShift&#10;&#10;for lPeriod in self.mPeriods:&#10;  lName=lPrefix+&quot;_&quot;+lPeriod+&quot;_start&quot;&#10;  WData=df_resampled[lPeriod]&#10;  df_merge=df[[self.mDateColumn,self.mSignal]].merge(WData,left_on=self.mDateColumn,right_on=lName,how='left',suffixes=('_x','_Period'),sort=True)&#10;  df[self.mSignal+'_'+lPeriod]=df_merge[self.mSignal+'_Period']&#10;  df[lName]=df_merge[lName]&#10;  logger.info(&quot;FORECASTING_HIERARCHICAL_TEMPORAL_LEVEL &quot;+str((lPeriod,lName,list(df.columns),WData.shape)))&#10;&#10;return df&#10;"/>
        <sourcecode id="uQFT8B68OoWsG" value="df=df.reset_index(drop=True)&#10;logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;N=len(df.columns)&#10;df1=df[[self.mDateColumn,self.mSignal]].copy()&#10;df1.set_index(self.mDateColumn,inplace=True,drop=False)&#10;lPrefix=&quot;TH&quot;&#10;lHelper=dtfunc.cDateTime_Helper()&#10;lBaseFreq=lHelper.computeTimeFrequency_in_seconds(df1[self.mDateColumn])&#10;df_resampled={&#10;}&#10;&#10;for lPeriod in self.mPeriods:&#10;  lName=lPrefix+&quot;_&quot;+lPeriod+&quot;_start&quot;&#10;  df_resampled[lPeriod]=df1[self.mSignal].resample(lPeriod).sum().reset_index()&#10;  df_resampled[lPeriod].columns=[lName,self.mSignal]&#10;  lShift=df_resampled[lPeriod][lName].iloc[0]-df[self.mDateColumn].iloc[0]&#10;  df_resampled[lPeriod][lName]=df_resampled[lPeriod][lName]-lShift&#10;  lDate_Period=df_resampled[lPeriod][lName]&#10;  lNewFreq=lHelper.computeTimeFrequency_in_seconds(lDate_Period)&#10;  lHorizon=int(self.mHorizon*lBaseFreq/lNewFreq)&#10;  lHorizon=max(1,lHorizon)&#10;  self.mHorizons[lPeriod]=lHorizon&#10;  logger.info(&quot;FORECASTING_HIERARCHICAL_TEMPORAL_HORIZONS_FIRST_RESAMPLED_DATA &quot;+str(lPeriod)+&quot; &quot;+str(df_resampled[lPeriod].head(5).to_dict()))&#10;&#10;logger.info(&quot;FORECASTING_HIERARCHICAL_TEMPORAL_HORIZONS &quot;+str(self.mHorizons))&#10;&#10;"/>
        <sourcecode id="uNSnJ00eX0lkA" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;lHelper=dtfunc.cDateTime_Helper()&#10;lIsPhysical=lHelper.isPhysicalTime(self.mTrainingDataset[self.mDateColumn])&#10;if(not lIsPhysical):&#10;  raise tsutil.PyAF_Error('TIME_HIERARCHY_PHYSICAL_TIME_NEEDED '+str(self.mDateColumn)+&quot; &quot;+str(self.mTrainingDataset[self.mDateColumn].dtype))&#10;&#10;"/>
        <sourcecode id="uO1osmxuGzEoS" value="logger=tsutil.get_pyaf_hierarchical_logger()&#10;&#10;lHelper=dtfunc.cDateTime_Helper()&#10;lSeconds={&#10;}&#10;&#10;for lPeriod in self.mPeriods:&#10;  lSeconds[lPeriod]=lHelper.get_period_length_in_seconds(lPeriod)&#10;&#10;logger.info(&quot;FORECASTING_HIERARCHICAL_TEMPORAL_FREQUENCIES &quot;+str(lSeconds))&#10;lPreviousPeriod=lSeconds[self.mPeriods[0]]&#10;lTimeFreqInSeconds=lHelper.computeTimeFrequency_in_seconds(self.mTrainingDataset[self.mDateColumn])&#10;if(lTimeFreqInSeconds&gt;lPreviousPeriod):&#10;  raise tsutil.PyAF_Error('TIME_HIERARCHY_PHYSICAL_TIME_RESOLUTION_TOO_LOW_FOR_THIS_PERIOD '+str(self.mDateColumn)+&quot; &quot;+str(lTimeFreqInSeconds)+&#10;  &quot; &quot;+self.mPeriods[0]+&quot; &quot;+str(lPreviousPeriod))&#10;for lPeriod in self.mPeriods[1:]:&#10;  if(lSeconds[lPeriod]&lt;lPreviousPeriod):&#10;    raise tsutil.PyAF_Error('TIME_HIERARCHY_NOT_MONOTONOUS '+str(self.mPeriods))&#10;&#10;&#10;  lPreviousPeriod=lSeconds[lPeriod]&#10;&#10;"/>
        <sourcecode id="u7Ua0TYwrTPaA" value="self.mPeriods=self.mHierarchy['Periods']&#10;self.checkPhysicalTime()&#10;self.check_increasing_periods()&#10;self.compute_horizons(self.mTrainingDataset)&#10;self.mLevels=list(range(len(self.mPeriods)))&#10;&#10;self.mStructure={&#10;}&#10;&#10;&#10;for(lLevel,lPeriod)in enumerate(self.mPeriods):&#10;  self.mStructure[lLevel]={&#10;}&#10;&#10;&#10;for(lLevel,lPeriod)in enumerate(self.mPeriods):&#10;  self.mStructure[lLevel][self.mSignal+'_'+lPeriod]=set()&#10;  if(lLevel&gt;0):&#10;    self.mStructure[lLevel][self.mSignal+'_'+lPeriod]=set([self.mSignal+'_'+self.mPeriods[lLevel-1]])&#10;&#10;&#10;pass"/>
      </codegenerator>
    </codegeneration>
  </xmi:Extension>
</xmi:XMI>
